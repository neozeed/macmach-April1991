
: This is a shar archive.  Extract with sh, not csh.
echo x - defs
sed -e 's/^X//' > defs << ''
X#include "stdio.h"
X
X/* 20-Jun-89  Zon Williamson (zon) at Carnegie-Mellon University
X *	Added casts to struct pointers.
X */
X
X#define NO  0
X#define YES 1
X
X#define CNULL (char *) 0
X#define PNULL (ptr) 0
X#define CHNULL (chainp) 0
X
X#define HASHEDTABLE 1
X
X#define XL	6
X
X#define NFTNTYPES 7
X#define NEFLTYPES 13
X
X#define MEMSIZE 12240
X#define YYMAXDEPTH 250
X
X#define MAXSTNO 200
X#define MAXINCLUDEDEPTH 10
X#define MAXBLOCKDEPTH 30
X#define MAXINDIFS 150
X#define MAXFTNAMES 250
X#define MAXEFLNAMES 300
X#define MAXSWITCH 100
X
X#define EXECPOOL 20
X#define EXPRPOOL 40
X
X#define NAMESPERLINE 6
X
X#define LINESPACES 66
X#define INDENTSPACES 3
X
Xtypedef int *ptr;
X
Xextern struct chain
X	{
X	ptr nextp;
X	ptr datap;
X	} ;
X
Xtypedef struct chain *chainp;
X
Xextern int yylineno;
Xextern int dumpic;
Xextern int memdump;
Xextern int dbgflag;
Xextern int nowarnflag;
Xextern int nocommentflag;
Xextern int verbose;
Xextern int dumpcore;
X#define TEST if(dbgflag)
X#define efgetc (efmacp?*efmacp++:getc(yyin))
Xextern char msg[];
X
X#define UNIX 1
X#define GCOS 2
X#define GCOSBCD 3
X#define CRAY	4
X#define IBM	5
X
X#define FIELDMAX 32768.
X
X#define ALLOC(x) (struct x *) intalloc(sizeof(struct x))
X
X#define	calloc	efl_calloc
X#define	alloc	efl_alloc
X#define	malloc	efl_malloc
X#define	cfree	efl_cfree
X#define	free	efl_free
X
Xextern FILE *diagfile;
Xextern FILE *codefile;
Xextern FILE *yyin;
Xextern FILE *fileptrs[];
Xextern char *filenames[];
Xextern char *basefile;
Xextern int  filelines[];
Xextern int filedepth;
Xextern char *efmacp;
Xextern char *filemacs[];
Xextern int pushchars[];
X
Xextern struct fileblock *iifilep;
X
Xextern int mem[];
Xextern unsigned int nmemused;
Xextern long int totfreed;
Xextern long int totalloc;
X
Xextern int nhid[];
Xextern int ndecl[];
X
Xextern int indifs[];
Xextern int nxtindif;
Xextern int afterif;
X
Xextern neflnames;
X
Xextern int nftnch;
Xextern int nftncont;
X
Xextern char ftnames[MAXFTNAMES][7];
Xextern int nftnames;
Xextern int nftnm0;
Xextern int impltype[];
Xextern int ftnmask[];
X
Xextern double fieldmax;
Xextern int ftnefl[];
Xextern int eflftn[];
X
Xextern ptr thisexec;
Xextern ptr thisctl;
Xextern int pushlex;
Xextern int igeol;
Xextern int ateof;
Xextern int eofneed;
Xextern int forcerr;
Xextern int comneed;
Xextern int optneed;
Xextern int defneed;
Xextern int lettneed;
Xextern int iobrlevel;
X
Xextern int prevbg;
X
Xextern chainp hidlist;
Xextern chainp commonlist;
Xextern chainp tempvarlist;
Xextern chainp temptypelist;
Xextern chainp gonelist;
Xextern int blklevel;
Xextern int ctllevel;
Xextern int dclsect;
Xextern int instruct;
Xextern int inbound;
Xextern int inproc;
X
Xextern int ncases;
Xextern ptr comments;
Xextern ptr prevcomments;
Xextern ptr genequivs;
Xextern ptr arrays;
Xextern ptr generlist;
Xextern ptr knownlist;
X
Xextern int graal;
Xextern ptr procname;
Xextern int procclass;
Xextern ptr thisargs;
X
Xextern int langopt;
Xextern int dotsopt;
Xextern int dbgopt;
Xextern int dbglevel;
X
Xextern int stnos[];
Xextern int nxtstno;
Xextern int constno;
Xextern int labno;
Xextern int nerrs;
Xextern int nbad;
Xextern int nwarns;
X
Xstruct headbits
X	{
X	unsigned int tag:8;
X	unsigned int subtype:8;
X	unsigned int blklevel:8;
X	};
X
Xextern struct fileblock
X	{
X	FILE *fileptr;
X	char filename[20];
X	};
X
Xextern struct fileblock *ibfile;
Xextern struct fileblock *icfile;
Xextern struct fileblock *idfile;
Xextern struct fileblock *iefile;
X
X
Xextern struct comentry
X	{
X	struct headbits header;
X	char comname[7];
X	long int comleng;
X	unsigned int cominit:2;
X	chainp comchain;
X	} ;
X
Xextern struct stentry
X	{
X	struct headbits header;
X	char *namep;
X	ptr varp;
X	int hashval;
X	};
X
Xextern struct stentry *hashtab[];
Xextern struct stentry **hashend;
X
Xextern struct typeblock
X	{
X	struct headbits header;
X	ptr sthead;
X	ptr strdesc;
X	int stralign;
X	int strsize;
X	int basetypes;
X	} ;
X
Xextern struct keyblock
X	{
X	struct headbits header;
X	ptr sthead;
X	} ;
X
X
Xextern struct varblock
X	{
X	struct headbits header;
X	ptr sthead;
X	ptr vinit;
X		unsigned int vadjdim:1;
X		unsigned int vdcldone:1;
X		unsigned int vdclstart:1;
X		unsigned int vnamedone:1;
X		unsigned int vprec:1;
X		unsigned int vext:1;
X		unsigned int vproc:2;
X		unsigned int needpar:1;
X		unsigned int vtype:4;
X		unsigned int vclass:3;
X	ptr vtypep;
X	ptr vdim;
X	ptr vsubs;
X	ptr voffset;
X	int vextbase;
X	int vbase[NFTNTYPES];
X	} ;
X
Xextern struct atblock
X	{
X	int atprec;
X	int attype;
X	int atext;
X	int atclass;
X	ptr attypep;
X	ptr atcommon;
X	ptr atdim;
X	} ;
X
Xextern struct dimblock
X	{
X	ptr nextp;
X	ptr lowerb;
X	ptr upperb;
X	} ;
X
Xextern struct exprblock	/* must be same size as varblock */
X	{
X	struct headbits header;
X	ptr leftp;
X	ptr rightp;
X		unsigned int vadjdim:1;
X		unsigned int vdcldone:1;
X		unsigned int vdclstart:1;
X		unsigned int vnamedone:1;
X		unsigned int vprec:1;
X		unsigned int vext:1;
X		unsigned int vproc:2;
X		unsigned int needpar:1;
X		unsigned int vtype:4;
X		unsigned int vclass:3;
X	ptr vtypep;
X	ptr vdim;
X	ptr vsubs;
X	ptr voffset;
X	int vextbase;
X	int vbase[NFTNTYPES];
X	} ;
X
X
Xextern struct execblock
X	{
X	struct headbits header;
X	ptr temps;
X	int labelno;
X		unsigned int uniffable:1;
X		unsigned int brnchend:1;
X		unsigned int labeled:1;
X		unsigned int copylab:1;
X		unsigned int labdefined:1;
X		unsigned int labused:1;
X		unsigned int labinacc:1;
X	ptr execdesc;
X	ptr prevexec;
X	int nxtlabno;
X	int nftnst;
X	} ;
X
X
Xextern struct ctlblock	/* must be same size as execblock */
X	{
X	struct headbits header;
X	ptr loopvar;
X	ptr loopctl;
X	ptr prevctl;
X	int nextlab;
X	int breaklab;
X	int xlab;
X	int indifn;
X	} ;
X
Xextern struct caseblock
X	{
X	struct headbits header;
X	ptr nextcase;
X	int labelno;
X		unsigned int uniffable:1;
X		unsigned int brnchend:1;
X		unsigned int labeled:1;
X		unsigned int copylab:1;
X		unsigned int labdefined:1;
X		unsigned int labused:1;
X		unsigned int labinacc:1;
X	ptr casexpr;
X	} ;
X
Xextern struct labelblock
X	{
X	struct headbits header;
X	ptr sthead;
X	int labelno;
X		unsigned int uniffable:1;
X		unsigned int brnchend:1;
X		unsigned int labeled:1;
X		unsigned int copylab:1;
X		unsigned int labdefined:1;
X		unsigned int labused:1;
X		unsigned int labinacc:1;
X	} ;
X
Xextern struct defblock
X	{
X	struct headbits header;
X	ptr sthead;
X	char *valp;
X	} ;
X
Xextern struct doblock
X	{
X	struct headbits header;
X	ptr dovar;
X	ptr dopar[3];
X	} ;
X
Xextern struct fieldspec
X	{
X	struct headbits header;
X	ptr flbound;
X	ptr frange;
X	ptr frshift;
X	int fanymore;
X	} ;
X
X
Xextern struct genblock
X	{
X	struct headbits header;
X	ptr nextgenf;
X	char *genname;
X	char *genfname[NEFLTYPES];
X	int genftype[NEFLTYPES];
X	} ;
X
X
Xextern struct knownname
X	{
X	struct headbits header;
X	ptr nextfunct;
X	char *funcname;
X	int functype;
X	} ;
X
Xextern struct iostblock
X	{
X	struct headbits header;
X	ptr leftp;	/* padding */
X	ptr right;	/* padding */
X		unsigned int vadjdim:1;
X		unsigned int vdcldone:1;
X		unsigned int vdclstart:1;
X		unsigned int vnamedone:1;
X		unsigned int vprec:1;
X		unsigned int vext:1;
X		unsigned int vproc:2;
X		unsigned int needpar:1;
X		unsigned int vtype:4;
X		unsigned int vclass:3;
X	int iokwd;
X	ptr iounit;
X	ptr iolist;
X	int iojunk[7];	/* padding */
X	} ;
X
Xextern struct ioitem
X	{
X	struct headbits header;
X	ptr ioexpr;
X	char *iofmt;
X	int nrep;
X	} ;
X
X
Xstruct iogroup
X	{
X	struct headbits header;
X	struct doblock *doptr;
X	char *iofmt;
X	int nrep;
X	ptr ioitems;
X	};
X
X
Xextern struct tailoring
X	{
X	int ftnsys;
X	int errmode;
X	int charcomp;
X	int ftnin;
X	int ftnout;
X	int ftncontnu;
X	char *procheader;
X	char *lngcxtype;
X	char *lngcxprefix;
X	int ftnchwd;
X	int ftnsize[NFTNTYPES];
X	int ftnalign[NFTNTYPES];
X	char *dfltfmt[NEFLTYPES];
X	int hollincall;
X	int deltastno;
X	int dclintrinsics;
X	int ftn77;
X	}  tailor;
X
X
Xstruct system
X	{
X	char *sysname;
X	short sysno;
X	short chperwd;
X	short idig;
X	short rdig;
X	short ddig;
X	} systab[];
X
X
X
X
X
X/* Declarations of popular functions */
X
Xchar *copys(), *convic(), *procnm();
Xptr cpexpr(), compconst(), simple(), mknode(), mkint(), mkconst();
Xptr intalloc(), calloc(), allexcblock(), allexpblock();
Xptr mkcall(), coerce(), fold(), builtin(), gent(), errnode();
Xptr arg1(), arg2(), arg4();
Xstruct stentry *name();
Xchainp mkchain(), hookup();
X
X/*Block tags */
X
X#define TAROP 1
X#define TASGNOP 2
X#define TLOGOP 3
X#define TRELOP 4
X#define TCALL 5
X#define TREPOP 6
X#define TLIST 7
X#define TCONST 8
X#define TNAME 9
X#define TERROR 10
X#define TCOMMON 11
X#define TSTRUCT 12
X#define TSTFUNCT 13
X#define TEXEC 14
X#define TTEMP 15
X#define TDEFINE 16
X#define TKEYWORD 17
X#define TLABEL 18
X#define TCASE 19
X#define TNOTOP 20
X#define TNEGOP 21
X#define TDOBLOCK 22
X#define TCONTROL 23
X#define TKNOWNFUNCT 24
X#define TFIELD 25
X#define TGENERIC 26
X#define TIOSTAT 27
X#define TIOGROUP 28
X#define TIOITEM 29
X#define TFTNBLOCK 30
X
X/* Operator subtypes */
X
X#define OPPLUS 1
X#define OPMINUS 2
X#define OPSTAR 3
X#define OPSLASH 4
X#define OPPOWER 5
X
X#define OPNOT 6
X#define OPAND 7
X#define OP2AND 8
X#define OP2OR 9
X#define OPOR 10
X
X#define OPEQ 11
X#define OPLT 12
X#define OPGT 13
X#define OPLE 14
X#define OPGE 15
X#define OPNE 16
X
X#define OPLPAR 17
X#define OPRPAR 18
X#define OPEQUALS 19
X#define OPCOMMA 20
X
X#define OPASGN 0
X#define OPREL 0
X
X
X/* Simplification types */
X
X#define LVAL 1
X#define RVAL 2
X#define SUBVAL 3
X#define IFVAL 4
X
X
X/* Parser return values */
X
X#define PARSERR 1
X#define PARSEOF 2
X#define PARSOPT 3
X#define PARSDCL 4
X#define PARSDEF 5
X#define PARSPROC 6
X
X
X/* Symbol table types */
X
X#define TYUNDEFINED 0
X#define TYINT 1
X#define TYREAL 2
X#define TYLREAL 3
X#define TYLOG 4
X#define TYCOMPLEX 5
X#define TYLCOMPLEX 6
X#define TYCHAR 7
X#define TYSTRUCT 8
X#define TYLABEL 9
X#define TYSUBR 10
X#define TYFIELD 11
X#define TYHOLLERITH 12
X
X
X
X/* Fortran types */
X
X#define FTNINT 0
X#define FTNREAL 1
X#define FTNLOG 2
X#define FTNCOMPLEX 3
X#define FTNDOUBLE 4
X#define FTNCHAR 5
X#define FTNDCOMPLEX 6
X
X
X
X/* symbol table classes */
X
X#define CLUNDEFINED 0
X#define CLARG 1
X#define CLVALUE 2
X#define CLSTAT 3
X#define CLAUTO 4
X#define CLCOMMON 5
X#define CLMOS 6
X#define CLEXT 7
X
X
X/* values of vproc */
X
X#define PROCUNKNOWN 0
X#define PROCNO 1
X#define PROCYES 2
X#define PROCINTRINSIC 3
X
X/* values of procclass */
X
X#define PRBLOCK	1
X#define PRMAIN	2
X#define PRSUBR	3
X#define PRFUNCT	4
X
X
X
X/* ctlblock subtypes */
X
X#define STNULL 1
X#define STIF 2
X#define STIFELSE 3
X#define STREPEAT 4
X#define STWHILE 5
X#define STFOR 6
X#define STDO 7
X#define STSWITCH 8
X#define STRETURN 9
X#define STGOTO 10
X#define STCALL 11
X#define STPROC 12
X
X
X
X/* intermediate code definitions */
X
X#define ICEOF 0
X#define ICBEGIN 1
X#define ICKEYWORD 2
X#define ICOP 3
X#define ICNAME 4
X#define ICCONST 5
X#define ICLABEL 6
X#define ICMARK 7
X#define ICINDENT 8
X#define ICCOMMENT 9
X#define ICINDPTR 10
X#define ICBLANK 11
X
X#define FCONTINUE 2
X#define FCALL 3
X#define FDO 4
X#define FIF1 5
X#define FIF2 6
X#define FGOTO 7
X#define FRETURN 8
X#define FREAD 9
X#define FWRITE 10
X#define FFORMAT 11
X#define FSTOP 12
X#define FDATA 13
X#define FEQUIVALENCE 14
X#define FCOMMON 15
X#define FEXTERNAL 16
X#define FREWIND 17
X#define FBACKSPACE 18
X#define FENDFILE 19
X#define FSUBROUTINE 20
X#define FFUNCTION 21
X#define FPROGRAM 22
X#define FBLOCKDATA 23
X#define FEND 24
X
X
X/* I/O error handling options */
X
X#define IOERRNONE	0
X#define IOERRIBM	1
X#define IOERRFORT77	2
X
X/* casts for struct pointers */
X#define CHAIN(x) ((struct chain *)x)
X#define HEADBITS(x) ((struct headbits *)x)
X#define FILEBLOCK(x) ((struct fileblock *)x)
X#define COMENTRY(x) ((struct comentry *)x)
X#define STENTRY(x) ((struct stentry *)x)
X#define TYPEBLOCK(x) ((struct typeblock *)x)
X#define KEYBLOCK(x) ((struct keyblock *)x)
X#define VARBLOCK(x) ((struct varblock *)x)
X#define ATBLOCK(x) ((struct atblock *)x)
X#define DIMBLOCK(x) ((struct dimblock *)x)
X#define EXPRBLOCK(x) ((struct exprblock *)x)
X#define EXECBLOCK(x) ((struct execblock *)x)
X#define CTLBLOCK(x) ((struct ctlblock *)x)
X#define CASEBLOCK(x) ((struct caseblock *)x)
X#define LABELBLOCK(x) ((struct labelblock *)x)
X#define DEFBLOCK(x) ((struct defblock *)x)
X#define DOBLOCK(x) ((struct doblock *)x)
X#define FIELDSPEC(x) ((struct fieldspec *)x)
X#define GENBLOCK(x) ((struct genblock *)x)
X#define KNOWNNAME(x) ((struct knownname *)x)
X#define IOSTBLOCK(x) ((struct iostblock *)x)
X#define IOITEM(x) ((struct ioitem *)x)
X#define IOGROUP(x) ((struct iogroup *)x)
X#define TAILORING(x) ((struct tailoring *)x)
X#define SYSTEM(x) ((struct system *)x)

echo x - Makefile
sed -e 's/^X//' > Makefile << ''
X#
X# Copyright (c) 1987 Regents of the University of California.
X# All rights reserved.  The Berkeley software License Agreement
X# specifies the terms and conditions for redistribution.
X#
X#	@(#)Makefile	5.1	(Berkeley)	12/12/87
X#
XCFLAGS=	-O -w
XLIBC=	/lib/libc.a
XSRCS=	addr.c alloc.c blklab.c dcl.c dclgen.c error.c exec.c field.c free.c \
X	gram.c icfile.c init.c io.c lex.c main.c misc.c mk.c namgen.c pass2.c \
X	print.c simple.c struct.c symtab.c tailor.c temp.c
XOBJS=	addr.o alloc.o blklab.o dcl.o dclgen.o error.o exec.o field.o free.o \
X	gram.o icfile.o init.o io.o lex.o main.o misc.o mk.o namgen.o pass2.o \
X	print.o simple.o struct.o symtab.o tailor.o temp.o
X
Xall: efl
X
Xefl: ${OBJS} ${LIBC}
X	${CC} -o $@ ${CFLAGS} ${OBJS}
X
X# gram.c can no longer be made on a pdp11 because of yacc limits
Xgram.c: gram.head gram.dcl gram.expr gram.exec tokdefs
X	(sed < tokdefs "s/#define/%token/" ; \
X	cat gram.head gram.dcl gram.expr gram.exec) > gram.in
X	${YACC} ${YFLAGS} gram.in
X	(echo "#define YYDEBUG"; cat y.tab.c) > gram.c
X	rm -f gram.in y.tab.c
X
Xlex.c: fixuplex
X	lex lex.l
X	sh fixuplex
X	mv lex.yy.c lex.c
X
Xtokdefs: tokens
X	grep -n . < tokens | sed "s/\([^:]*\):\(.*\)/#define \2 \1/" > tokdefs
X
Xclean: FRC
X	rm -f ${OBJS} core efl gram.c lex.c tokdefs
X
Xdepend: ${SRCS} FRC
X	mkdep ${CFLAGS} ${SRCS}
X
Xinstall: FRC
X	install -s -o bin -g bin -m 755 efl ${DESTDIR}/usr/bin/efl
X
Xlint: ${SRCS} FRC
X	lint ${CFLAGS} ${SRCS}
X
Xtags: ${SRCS} FRC
X	ctags ${SRCS}
X
Xtest:
X	./efl "system=gcos" efltest/Hard.e >z1 2>z2
X	cmp z1 efltest/Hard.out
X	./efl "system=gcos" efltest/Band.e >z1 2>z2
X	cmp z1 efltest/Band.out
X	./efl "system=gcos" efltest/Buram.e >z1 2>z2
X	cmp z1 efltest/Buram.out
X	./efl "system=gcos" efltest/Dgl.e >z1 2>z2
X	cmp z1 efltest/Dgl.out
X	rm -f z1 z2
X	@echo TEST OK
X
XFRC:
X
X# DO NOT DELETE THIS LINE -- mkdep uses it.
X# DO NOT PUT ANYTHING AFTER THIS LINE, IT WILL GO AWAY.
X
Xaddr.o: addr.c defs /usr/include/stdio.h
Xalloc.o: alloc.c defs /usr/include/stdio.h
Xblklab.o: blklab.c defs /usr/include/stdio.h
Xdcl.o: dcl.c defs /usr/include/stdio.h
Xdclgen.o: dclgen.c defs /usr/include/stdio.h
Xerror.o: error.c defs /usr/include/stdio.h
Xexec.o: exec.c defs /usr/include/stdio.h
Xfield.o: field.c defs /usr/include/stdio.h
Xfree.o: free.c defs /usr/include/stdio.h
Xgram.o: gram.c defs /usr/include/stdio.h
Xicfile.o: icfile.c defs /usr/include/stdio.h
Xinit.o: init.c defs /usr/include/stdio.h tokdefs
Xio.o: io.c /usr/include/ctype.h defs /usr/include/stdio.h
Xlex.o: lex.c /usr/include/stdio.h /usr/include/ctype.h defs
Xlex.o: /usr/include/stdio.h tokdefs
Xmain.o: main.c defs /usr/include/stdio.h
Xmisc.o: misc.c /usr/include/ctype.h defs /usr/include/stdio.h
Xmk.o: mk.c defs /usr/include/stdio.h
Xnamgen.o: namgen.c defs /usr/include/stdio.h
Xpass2.o: pass2.c defs /usr/include/stdio.h /usr/include/ctype.h
Xprint.o: print.c defs /usr/include/stdio.h
Xsimple.o: simple.c /usr/include/ctype.h defs /usr/include/stdio.h
Xstruct.o: struct.c defs /usr/include/stdio.h
Xsymtab.o: symtab.c defs /usr/include/stdio.h
Xtailor.o: tailor.c defs /usr/include/stdio.h
Xtemp.o: temp.c defs /usr/include/stdio.h
X
X# IF YOU PUT ANYTHING HERE IT WILL GO AWAY

echo x - addr.c
sed -e 's/^X//' > addr.c << ''
X#include "defs"
X
Xstruct varblock *subscript(v,s)
Xregister ptr v,s;
X{
Xptr p;
Xregister ptr q;
Xptr bounds, subs;
Xint size, align, mask;
X
Xif(HEADBITS(v)->tag == TERROR)
X	goto ret;
Xif(HEADBITS(v)->tag!=TNAME && HEADBITS(v)->tag!=TTEMP)
X	badtag("subscript", HEADBITS(v)->tag);
Xif(HEADBITS(s)->tag == TERROR)
X	{
X	VARBLOCK(v)->vsubs = 0;
X	goto ret;
X	}
X
Xif(HEADBITS(s)->tag != TLIST)
X	badtag("subscript", HEADBITS(s)->tag);
Xsizalign(v, &size, &align, &mask);
Xif(bounds = VARBLOCK(v)->vdim)
X	bounds = CHAIN(bounds)->datap;
Xsubs = s->leftp;
X
Xwhile ( bounds && subs)
X	{
X	if(bounds->lowerb)
X		{
X		p = mknode(TAROP,OPMINUS,mkint(1),cpexpr(bounds->lowerb));
X		CHAIN(subs)->datap = mknode(TAROP,OPPLUS, CHAIN(subs)->datap, p);
X		}
X	bounds = bounds->nextp;
X	subs = subs->nextp;
X	}
XVARBLOCK(v)->vdim = 0;
Xif(bounds || subs)
X	{
X	exprerr("subscript and bounds of different length", CNULL);
X	VARBLOCK(v)->vsubs = 0;
X	goto ret;
X	}
X
Xif(VARBLOCK(v)->vsubs)
X	{ /* special case of subscripted type element */
X	if(s->leftp==0 || s->leftp->nextp!=0)
X		{
X		exprerr("not exactly one subscript on type member", CNULL);
X		VARBLOCK(v)->vsubs = 0;
X		goto ret;
X		}
X	q = mknode(TAROP,OPMINUS,CHAIN(s->leftp)->datap, mkint(1) );
X	q = mknode(TAROP,OPSTAR, mkint(size), q);
X	if(v->voffset)
X		v->voffset = mknode(TAROP,OPPLUS,v->voffset, q);
X	else	v->voffset = q;
X	goto ret;
X	}
X
XVARBLOCK(v)->vsubs = s;
X
Xif(v->vtype==TYCHAR || v->vtype==TYSTRUCT ||
X	(v->vtype==TYLCOMPLEX && tailor.lngcxtype==NULL) )
X	{ /* add an initial unit subscript */
X	s->leftp = mkchain(mkint(1), s->leftp);
X	}
X
Xelse	{   /* add to offset, set first subscript to 1 */
X	q = mknode(TAROP,OPMINUS,CHAIN(s->leftp)->datap, mkint(1) );
X	q = mknode(TAROP,OPSTAR, mkint(size), q);
X	if(v->voffset)
X		v->voffset = mknode(TAROP,OPPLUS,v->voffset, q);
X	else	v->voffset = q;
X
X	CHAIN(s->leftp)->datap = mkint(1);
X	}
Xret:
X	return(v);
X}
X
X
X
X
X
Xptr strucelt(var, subelt)
Xregister ptr var;
Xptr subelt;
X{
Xregister ptr p, q;
X
Xif(var->tag == TERROR)
X	return(var);
Xif(var->vtype!=TYSTRUCT || var->vtypep==0 || var->vdim!=0)
X	{
X	exprerr("attempt to find a member in an array or non-structure", CNULL);
X	return(errnode());
X	}
Xfor(p = var->vtypep->strdesc ; p ; p = p->nextp)
X	if(subelt == CHAIN(p)->datap->sthead) break;
Xif(p == 0)
X	{
X	exprerr("%s is not in structure\n", subelt->namep);
X	return(errnode());
X	}
Xq = CHAIN(p)->datap;
Xvar->vdim = q->vdim;
Xvar->vtypep = q->vtypep;
Xif(q->voffset)
X	if(var->voffset)
X		var->voffset = mknode(TAROP,OPPLUS,var->voffset,cpexpr(q->voffset));
X	else	{
X		var->voffset = cpexpr(q->voffset);
X		}
Xif( (var->vtype = q->vtype) != TYSTRUCT)
X	convtype(var);
Xreturn(var);
X}
X
X
X
Xconvtype(p)
Xregister ptr p;
X{
Xregister int i, k;
Xptr mksub1();
X
Xswitch(p->vtype)
X	{
X	case TYFIELD:
X	case TYINT:
X	case TYCHAR:
X	case TYREAL:
X	case TYLREAL:
X	case TYCOMPLEX:
X	case TYLOG:
X		k = eflftn[p->vtype];
X		break;
X
X	default:
X		fatal("convtype: impossible type");
X	}
X
Xfor(i=0; i<NFTNTYPES; ++i)
X	if(i != k) p->vbase[i] = 0;
X	else if(p->vbase[i]==0)
X		{
X		exprerr("illegal combination of array and dot",CNULL);
X		mvexpr(errnode(), p);
X		return;
X		}
X
Xif(p->vsubs == 0)
X	p->vsubs = mksub1();
X
X}
X
X
X
Xfixsubs(p)
Xregister ptr p;
X{
Xptr q, *firstsub;
Xint size,align,mask;
X
Xif(p->voffset)
X	{
X	firstsub = &(CHAIN(p->vsubs->leftp)->datap);
X	sizalign(p, &size,&align,&mask);
X	if(p->vtype == TYCHAR)
X		size = tailor.ftnsize[FTNINT];
X
X	q = mknode(TAROP,OPSLASH,p->voffset,mkint(size));
X	*firstsub = mknode(TAROP,OPPLUS, q, *firstsub);
X	p->voffset = 0;
X	}
X}

echo x - alloc.c
sed -e 's/^X//' > alloc.c << ''
X#include "defs"
X
X#define NHISTO 50
Xint histo[NHISTO];
X
Xint mem[MEMSIZE];
Xunsigned int nmemused	= 0;
Xunsigned int nmemavail	= 0;
Xlong int totalloc	= 0;
Xlong int totfreed	= 0;
X
Xint nexpblocks	= 0;
Xptr expblocks	= 0;
Xint nexcblocks	= 0;
Xptr excblocks	= 0;
Xptr chains	= 0;
X
Xptr alloc(), calloc(), malloc();
X
Xptr intalloc(n)
Xint n;
X{
Xint *p;
X
X/*debug*/ if(n>sizeof(struct genblock)) fatal1("intalloc(%d)", n);
Xif( (p = calloc(1,n)) == NULL)
X	{
X	if(memdump)
X		prmem();
X	fatal1("Line %d:  Cannot allocate memory", yylineno);
X	}
X
Xreturn(p);
X}
X
X
X
X
Xptr calloc(m,n)
Xint m, n;
X{
Xreturn(alloc(m*n));
X}
X
X
X
Xptr malloc(m)
Xint m;
X{
Xreturn(alloc(m));
X}
X
X
X
X/* Very stupid memory allocator.  Stores a count word before
X   each block; negative if idle, positive if busy.
X   Looks for a block big enough for current request, and splits it
X   if necessary.  Does not coalesce, always starts at bottom of memory.
X   Checks validity of all count words it encounters.
X*/
X
X
Xptr alloc(k)
Xregister int k;
X{
Xint *p;
Xregister int i, j;
X
Xk = (k + sizeof(int)-1) / sizeof(int);
Xif(k <=0) fprintf(diagfile, "alloc(%d words)\n", k);
Xelse if(k >= NHISTO) ++histo[0];
Xelse ++histo[k];
Xtotalloc += k;
Xif(k > 256) fprintf(diagfile, "calloc(%d words)\n", k);
X
X/* look for a large enough slot */
Xif(nmemavail > k)
X    for(i=0 ; i<nmemused ; )
X	{
X	j = mem[i];
X	if(j>256)
X		{
X		fprintf(diagfile, "Bad count word %d\n", j);
X		goto die;
X		}
X	if(j>=0 ||  (j = -j)<k)
X		i += (j+1);
X	else	{
X		if(j > 256)
X			{
X			fprintf(diagfile, "Bad count word %d\n", j);
X			goto die;
X			}
X		mem[i] = k;
X		if(j > k)
X			mem[i+k+1] = -(j-k-1);
X		for(j = i+k ; j>i ; --j)
X			mem[j] = 0;
X		nmemavail -= (k+1);
X		return(mem + i+1);
X		}
X	}
X
X/* otherwise try to advance the fence */
Xmem[nmemused] = k;
Xp = mem + nmemused + 1;
Xnmemused += (k+1);
Xif(nmemused >= MEMSIZE)
X	{
X	die:
X/*debug*/	fprintf(diagfile, "Highwater mark %d words. ", nmemused);
X/*debug*/	fprintf(diagfile, "%ld words left over\n", totalloc-totfreed);
X/*	prmem();	*/
X	fatal1("Line %d:  out of memory", yylineno);
X	}
Xreturn(p);
X}
X
X
X
Xcfree(p)
Xptr p;
X{
Xif(p==0)
X	fatal("cfree(0)");
Xfree(p);
X}
X
X
X
X
Xfree(p)
Xregister unsigned int *p;
X{
Xif(p<=mem || p>mem+nmemused)
X	{
X	fprintf(diagfile, "attempt to free an unallocated block,  ");
X	goto bad;
X	}
Xif(p[-1]>256 || p[-1]<0)
X	{
X	fprintf(diagfile, "attempted to free a block of length %u\n",p[-1]);
X  bad:	fprintf(diagfile, "location %o    ", p);
X	fprintf(diagfile, "mem=%o   lastused=%o\n", mem, mem+nmemused);
X/*	if(p[-1]>256 || p[-1]<0)	*/
X		fatal("");
X	}
Xtotfreed += p[-1];
Xnmemavail += p[-1]+1;
Xp[-1] = - p[-1];
X;
X}
X
X
Xprhisto()
X{
Xint i;
Xfprintf(diagfile, "allocation histogram:\n%4d big blocks\n",histo[0]);
Xfor(i=1;i<NHISTO;++i)
X	if(histo[i]>0) fprintf(diagfile, "%4d %2d-word blocks\n", histo[i],i);
X}
X
X
X
X
X
Xptr allexpblock()
X{
Xptr p;
X
Xif(expblocks)
X	{
X	p = expblocks;
X	expblocks = expblocks->leftp;
X	zeroout(p, sizeof(struct exprblock));
X	--nexpblocks;
X	return(p);
X	}
Xelse	return( ALLOC(exprblock) );
X}
X
X
X
X
Xfrexpblock(p)
Xregister ptr p;
X{
Xif ( p[-1] != sizeof(struct exprblock)/sizeof(int) )
X	badtag("frexpblock", p->tag);
Xif(nexpblocks < EXPRPOOL)
X	{
X	p->leftp = expblocks;
X	p->tag = 0;
X	expblocks = p;
X	++nexpblocks;
X	}
Xelse	cfree(p);
X}
X
X
X
X
Xptr allexcblock()
X{
Xptr p;
X
Xif(excblocks)
X	{
X	p = excblocks;
X	excblocks = excblocks->leftp;
X	zeroout(p, sizeof(struct execblock));
X	--nexcblocks;
X	return(p);
X	}
Xelse	return( ALLOC(execblock) );
X}
X
X
X
X
Xfrexcblock(p)
Xregister ptr p;
X{
Xif( p[-1] != sizeof(struct execblock)/sizeof(int) )
X	fatal1("invalid frexcblock block of size %d", p[-1]);
Xif(nexcblocks < EXECPOOL)
X	{
X	p->leftp = excblocks;
X	p->tag = 0;
X	excblocks = p;
X	++nexcblocks;
X	}
Xelse	cfree(p);
X}
X
X
X
Xzeroout(p,n)
Xregister int *p;
Xint n;
X{
Xregister int *pn;
X
Xpn = p + (n + sizeof(int)-1)/sizeof(int);
X
Xwhile(p < pn)
X	*p++ = 0;
X}
X
X
X
X
Xfrchain(p0)
Xregister chainp *p0;
X{
Xregister ptr p;
X
Xif(p0==0 || *p0==0) return;
X
Xfor(p = *p0 ; p->nextp ; p = p->nextp)
X	CHAIN(p)->datap = 0;
X
XCHAIN(p)->datap = 0;
Xp->nextp = chains;
Xchains = *p0;
X*p0 = 0;
X}
X
X
Xchainp mkchain(p,q)
Xptr p, q;
X{
Xregister chainp r;
X
Xif(chains)
X	{
X	r = chains;
X	chains = chains->nextp;
X	}
Xelse	r = ALLOC(chain);
XCHAIN(r)->datap = p;
Xr->nextp = q;
Xreturn(r);
X}
X
X
X
X
Xprmem()
X{
Xregister int i,j;
X
Xfprintf(diagfile, "Memory dump:\n");
X
Xfor(i=0 ; i<nmemused ; )
X	{
X	j = mem[i];
X	fprintf(diagfile, "Loc %6o = Word %5d   ", mem+i, i);
X	if(j<0)
X		fprintf(diagfile, "Idle block length %4d   ", j = -j);
X	else	fprintf(diagfile, "Busy block length %4d   ", j);
X	fprintf(diagfile, "tag %3d", mem[i+1].tag);
X	if(mem[i+1].tag==TNAME && mem[i+1].sthead!=0)
X		fprintf(diagfile, "   varname %s", mem[i+1].sthead->namep);
X	else if(j==2)
X		fprintf(diagfile, "  chain %o %o", mem[i+1], mem[i+2]);
X	else if (mem[i+1].tag > TIOSTAT)
X		{
X		char *s, *sn;
X		s = & mem[i+1];
X		sn = s + 12;
X		fprintf(diagfile, "  \"");
X		while(*s!= '\0' && s<sn)
X			putc(*s++, diagfile);
X		}
X	fprintf(diagfile, "\n");
X
X	i += j+1;
X	}
X}

echo x - bigdefs
sed -e 's/^X//' > bigdefs << ''
X#include "stdio.h"
X
X#define HASHEDTABLE 1
X
X
X#define NFTNTYPES 5
X#define NEFLTYPES 12
X
X#define MEMSIZE 12000
X
X#define MAXSTNO 200
X#define MAXINCLUDEDEPTH 10
X#define MAXBLOCKDEPTH 30
X#define MAXINDIFS 100
X#define MAXFTNAMES 200
X#define MAXEFLNAMES 401
X
X#define EXECPOOL 20
X#define EXPRPOOL 40
X
X#define NAMESPERLINE 6
X
X#define LINESPACES 66
X#define INDENTSPACES 3
X
Xextern int yylineno;
Xextern int dumpic;
Xextern int memdump;
Xextern int dbgflag;
Xextern int nowarnflag;
Xextern int nocommentflag;
Xextern int verbose;
Xextern int dumpcore;
X#define TEST if(dbgflag)
X#define efgetc (efmacp?*efmacp++:getc(yyin))
Xextern char msg[];
X
X#define UNIX 1
X#define GCOS 2
X#define GCOSBCD 3
X
X#define FIELDMAX 32768.
X
Xtypedef *ptr;
X#define ALLOC(x) intalloc(sizeof(struct x))
X
Xextern FILE *diagfile;
Xextern FILE *codefile;
Xextern FILE *yyin;
Xextern FILE *fileptrs[];
Xextern char *filenames[];
Xextern int  filelines[];
Xextern int filedepth;
Xextern char *efmacp;
Xextern int filemacs[];
Xextern int pushchars[];
X
Xextern struct fileblock *iifilep;
X
Xextern int mem[];
Xextern unsigned int nmemused;
Xextern long int totfreed;
Xextern long int totalloc;
X
Xextern int nhid[];
Xextern int ndecl[];
X
Xextern int indifs[];
Xextern int nxtindif;
Xextern int afterif;
X
Xextern neflnames;
X
Xextern int nftnch;
Xextern int nftncont;
X
Xextern char ftnames[MAXFTNAMES][7];
Xextern int nftnames;
Xextern int nftnm0;
Xextern int impltype[];
Xextern int ftnmask[];
X
Xextern double fieldmax;
Xextern int ftnefl[];
Xextern int eflftn[];
X
Xextern ptr thisexec;
Xextern ptr thisctl;
Xextern int pushlex;
Xextern int igeol;
Xextern int ateof;
Xextern int eofneed;
Xextern int forcerr;
Xextern int comneed;
Xextern int optneed;
Xextern int defneed;
Xextern int lettneed;
X
Xextern int prevbg;
X
Xextern ptr hidlist;
Xextern ptr commonlist;
Xextern ptr tempvarlist;
Xextern ptr temptypelist;
Xextern ptr gonelist;
Xextern int blklevel;
Xextern int ctllevel;
Xextern int dclsect;
Xextern int instruct;
Xextern int inbound;
Xextern int inproc;
X
Xextern int ncases;
Xextern ptr comments;
Xextern ptr prevcomments;
Xextern ptr genequivs;
Xextern ptr arrays;
Xextern ptr generlist;
Xextern ptr knownlist;
X
Xextern int graal;
Xextern ptr thisproc;
Xextern ptr thisargs;
X
Xextern int langopt;
Xextern int dotsopt;
Xextern int dbgopt;
Xextern int dbglevel;
X
Xextern int stnos[];
Xextern int nxtstno;
Xextern int constno;
Xextern int labno;
Xextern int nerrs;
Xextern int nbad;
Xextern int nwarns;
X
Xstruct headbits
X	{
X	int tag:8;
X	int subtype:8;
X	int blklevel:8;
X	};
X
Xextern struct fileblock
X	{
X	FILE *fileptr;
X	char filename[20];
X	};
X
Xextern struct fileblock *ibfile;
Xextern struct fileblock *icfile;
Xextern struct fileblock *idfile;
Xextern struct fileblock *iefile;
X
Xextern struct chain
X	{
X	ptr nextp;
X	ptr datap;
X	} ;
X
Xtypedef struct chain *chainp;
X
Xextern struct comentry
X	{
X	struct headbits header;
X	char comname[7];
X	long int comleng;
X	int cominit:2;
X	chainp comchain;
X	} ;
X
Xextern struct stentry
X	{
X	struct headbits header;
X	char *namep;
X	ptr varp;
X	int hashval;
X	};
X
Xextern struct stentry *hashtab[];
Xextern struct stentry **hashend;
X
Xextern struct typeblock
X	{
X	struct headbits header;
X	ptr sthead;
X	ptr strdesc;
X	int stralign;
X	int strsize;
X	int basetypes;
X	} ;
X
Xextern struct keyblock
X	{
X	struct headbits header;
X	ptr sthead;
X	} ;
X
X
Xextern struct varblock
X	{
X	struct headbits header;
X	ptr sthead;
X	ptr vinit;
X		int vadjdim:1;
X		int vdcldone:1;
X		int vdclstart:1;
X		int vnamedone:1;
X		int vprec:1;
X		int vext:1;
X		int vproc:2;
X		int needpar:1;
X		int vtype:4;
X		int vclass:3;
X	ptr vtypep;
X	ptr vdim;
X	ptr vsubs;
X	ptr voffset;
X	int vextbase;
X	int vbase[NFTNTYPES];
X	} ;
X
Xextern struct atblock
X	{
X	int atprec;
X	int attype;
X	int atext;
X	int atclass;
X	ptr attypep;
X	ptr atcommon;
X	ptr atdim;
X	} ;
X
Xextern struct dimblock
X	{
X	ptr nextp;
X	ptr lowerb;
X	ptr upperb;
X	} ;
X
Xextern struct exprblock	/* must be same size as varblock */
X	{
X	struct headbits header;
X	ptr leftp;
X	ptr rightp;
X		int vadjdim:1;
X		int vdcldone:1;
X		int vdclstart:1;
X		int vnamedone:1;
X		int vprec:1;
X		int vext:1;
X		int vproc:2;
X		int needpar:1;
X		int vtype:4;
X		int vclass:3;
X	ptr vtypep;
X	ptr vdim;
X	ptr vsubs;
X	ptr voffset;
X	int vextbase;
X	int vbase[NFTNTYPES];
X	} ;
X
X
Xtypedef union { struct varblock ; struct exprblock; } *nodep;
X
Xextern struct execblock
X	{
X	struct headbits header;
X	ptr temps;
X	int labelno;
X		int uniffable:1;
X		int brnchend:1;
X		int labeled:1;
X		int copylab:1;
X		int labdefined:1;
X		int labused:1;
X		int labinacc:1;
X	ptr execdesc;
X	ptr prevexec;
X	int nxtlabno;
X	int nftnst;
X	} ;
X
X
Xextern struct ctlblock	/* must be same size as execblock */
X	{
X	struct headbits header;
X	ptr loopvar;
X	ptr loopctl;
X	ptr prevctl;
X	int nextlab;
X	int breaklab;
X	int xlab;
X	int indifn;
X	} ;
X
Xextern struct caseblock
X	{
X	struct headbits header;
X	ptr nextcase;
X	int labelno;
X		int uniffable:1;
X		int brnchend:1;
X		int labeled:1;
X		int copylab:1;
X		int labdefined:1;
X		int labused:1;
X		int labinacc:1;
X	ptr casexpr;
X	} ;
X
Xextern struct labelblock
X	{
X	struct headbits header;
X	ptr sthead;
X	int labelno;
X		int uniffable:1;
X		int brnchend:1;
X		int labeled:1;
X		int copylab:1;
X		int labdefined:1;
X		int labused:1;
X		int labinacc:1;
X	} ;
X
Xextern struct defblock
X	{
X	struct headbits header;
X	ptr sthead;
X	char *valp;
X	} ;
X
Xextern struct doblock
X	{
X	struct headbits header;
X	ptr dovar;
X	ptr dopar[3];
X	} ;
X
Xextern struct fieldspec
X	{
X	struct headbits header;
X	int flbound;
X	int frange;
X	int frshift;
X	int fanymore;
X	} ;
X
X
Xextern struct genblock
X	{
X	struct headbits header;
X	ptr nextgenf;
X	char *genname;
X	char *genfname[NEFLTYPES];
X	int genftype[NEFLTYPES];
X	} ;
X
X
Xextern struct knownname
X	{
X	struct headbits header;
X	ptr nextfunct;
X	char *funcname;
X	int functype;
X	} ;
X
Xextern struct iostblock
X	{
X	struct headbits header;
X	ptr leftp;	/* padding */
X	ptr right;	/* padding */
X		int vadjdim:1;
X		int vdcldone:1;
X		int vdclstart:1;
X		int vnamedone:1;
X		int vprec:1;
X		int vext:1;
X		int vproc:2;
X		int needpar:1;
X		int vtype:4;
X		int vclass:3;
X	int iokwd;
X	ptr iounit;
X	ptr iolist;
X	int iojunk[7];	/* padding */
X	} ;
X
Xextern struct ioitem
X	{
X	struct headbits header;
X	ptr ioexpr;
X	char *iofmt;
X	} ;
X
X
Xextern struct tailoring
X	{
X	int ftnsys;
X	int errmode;
X	int charcomp;
X	int ftnin;
X	int ftnout;
X	int ftncontnu;
X	char *procheader;
X	int ftnchwd;
X	int ftnsize[NFTNTYPES];
X	int ftnalign[NFTNTYPES];
X	char *dfltfmt[NEFLTYPES];
X	int hollincall;
X	int deltastno;
X	int dclintrinsics;
X	}  tailor;
X
X/*Block tags */
X
X#define TAROP 1
X#define TASGNOP 2
X#define TLOGOP 3
X#define TRELOP 4
X#define TCALL 5
X#define TREPOP 6
X#define TLIST 7
X#define TCONST 8
X#define TNAME 9
X#define TERROR 10
X#define TCOMMON 11
X#define TSTRUCT 12
X#define TSTFUNCT 13
X#define TEXEC 14
X#define TTEMP 15
X#define TDEFINE 16
X#define TKEYWORD 17
X#define TLABEL 18
X#define TCASE 19
X#define TNOTOP 20
X#define TNEGOP 21
X#define TDOBLOCK 22
X#define TCONTROL 23
X#define TKNOWNFUNCT 24
X#define TFIELD 25
X#define TGENERIC 26
X#define TIOSTAT 27
X
X/* Operator subtypes */
X
X#define OPPLUS 1
X#define OPMINUS 2
X#define OPSTAR 3
X#define OPSLASH 4
X#define OPPOWER 5
X
X#define OPNOT 6
X#define OPAND 7
X#define OP2AND 8
X#define OP2OR 9
X#define OPOR 10
X
X#define OPEQ 11
X#define OPLT 12
X#define OPGT 13
X#define OPLE 14
X#define OPGE 15
X#define OPNE 16
X
X#define OPLPAR 17
X#define OPRPAR 18
X#define OPEQUALS 19
X#define OPCOMMA 20
X
X#define OPASGN 0
X#define OPREL 0
X
X
X/* Simplification types */
X
X#define LVAL 1
X#define RVAL 2
X#define SUBVAL 3
X#define IFVAL 4
X
X
X/* Parser return values */
X
X#define PARSERR 1
X#define PARSEOF 2
X#define PARSOPT 3
X#define PARSDCL 4
X#define PARSDEF 5
X#define PARSPROC 6
X
X
X/* Symbol table types */
X
X#define TYUNDEFINED 0
X#define TYINT 1
X#define TYREAL 2
X#define TYLREAL 3
X#define TYLOG 4
X#define TYCOMPLEX 5
X#define TYCHAR 6
X#define TYSTRUCT 7
X#define TYLABEL 8
X#define TYSUBR 9
X#define TYFIELD 10
X#define TYHOLLERITH 11
X
X
X
X/* Fortran types */
X
X#define FTNINT 0
X#define FTNREAL 1
X#define FTNLOG 2
X#define FTNCOMPLEX 3
X#define FTNDOUBLE 4
X#define FTNCHAR 5
X
X
X
X/* symbol table classes */
X
X#define CLUNDEFINED 0
X#define CLARG 1
X#define CLVALUE 2
X#define CLSTAT 3
X#define CLAUTO 4
X#define CLCOMMON 5
X#define CLMOS 6
X#define CLEXT 7
X
X
X/* values of vproc */
X
X#define PROCUNKNOWN 0
X#define PROCNO 1
X#define PROCYES 2
X#define PROCINTRINSIC 3
X
X
X
X/* ctlblock subtypes */
X
X#define STNULL 1
X#define STIF 2
X#define STIFELSE 3
X#define STREPEAT 4
X#define STWHILE 5
X#define STFOR 6
X#define STDO 7
X#define STSWITCH 8
X#define STRETURN 9
X#define STGOTO 10
X#define STCALL 11
X#define STPROC 12
X
X
X
X/* intermediate code definitions */
X
X#define ICEOF 0
X#define ICBEGIN 1
X#define ICKEYWORD 2
X#define ICOP 3
X#define ICNAME 4
X#define ICCONST 5
X#define ICLABEL 6
X#define ICMARK 7
X#define ICINDENT 8
X#define ICCOMMENT 9
X#define ICINDPTR 10
X#define ICBLANK 11
X
X#define FCONTINUE 2
X#define FCALL 3
X#define FDO 4
X#define FIF1 5
X#define FIF2 6
X#define FGOTO 7
X#define FRETURN 8
X#define FREAD 9
X#define FWRITE 10
X#define FFORMAT 11
X#define FSTOP 12
X#define FDATA 13
X#define FEQUIVALENCE 14

echo x - blklab.c
sed -e 's/^X//' > blklab.c << ''
X#include "defs"
X
X
Xhide(p)
Xptr p;
X{
Xwarn1("Name %s hidden by a new declaration", p->namep);
Xhidlist = mkchain(p->varp, hidlist);
Xp->varp = 0;
X++nhid[blklevel];
X}
X
X
X
X/*  remove all symbol table entries in terminated block,
X    revive old hidden names
X*/
Xunhide()
X{
Xchainp p;
Xregister ptr q;
Xregister ptr v;
Xregister struct stentry *s;
Xstruct stentry **hp;
X
Xfor(hp = hashtab ; hp<hashend ; ++hp)
X	if(s = *hp)
X		{
X		if( (v = s->varp) && v->blklevel == blklevel)
X			{
X			if(HEADBITS(v)->tag==TLABEL)
X				if(blklevel <= 1)
X					{
X					if(v->labdefined==0)
X						laberr("%s never defined",
X							v->sthead->namep);
X					s->varp = 0;
X					}
X				else	{ /* move label out a level */
X					if(v->labdefined)
X						v->labinacc = 1;
X					v->blklevel--;
X					++ndecl[blklevel-1];
X					}
X			else	{
X				if(HEADBITS(v)->tag == TNAME)
X					{
X					TEST fprintf(diagfile,"gone(%s) level %d\n",
X						s->namep, blklevel);
X					gonelist = mkchain(s->varp, gonelist);
X					}
X
X				else if(HEADBITS(v)->tag!=TSTRUCT)
X					{
X					++ndecl[blklevel];
X					if(HEADBITS(v)->tag==TDEFINE)
X						frdef(v);
X					}
X				s->varp = 0;
X				}
X			--ndecl[blklevel];
X			}
X		}
X
Xfor( p=hidlist  ;  p && ((v = (q=CHAIN(p)->datap)->sthead)->varp==NULL) ; p=hidlist )
X	{
X	v->varp = q;
X	HEADBITS(v)->tag = q->tag;
X	v->subtype = q->subtype;
X	if(v->blklevel > q->blklevel)
X		v->blklevel = q->blklevel;
X	hidlist = p->nextp;
X	p->nextp = CHNULL;
X	frchain(&p);
X	--nhid[blklevel];
XTEST fprintf(diagfile, "unhide(%s), blklevel %d\n", v->namep, v->blklevel);
X	}
Xif(ndecl[blklevel] != 0)
X	{
X	sprintf(msg, "%d declarations leftover at block level %d",
X		ndecl[blklevel], blklevel);
X	fatal(msg);
X	}
Xif(nhid[blklevel] != 0)
X	fatal("leftover hidden variables");
X}
X
X
X
X
Xptr bgnexec()
X{
Xregister ptr p;
X
Xp = allexcblock();
Xp->tag = TEXEC;
Xp->prevexec = thisexec;
Xif(thisexec && thisexec->copylab)
X	{
X	p->labelno = thisexec->labelno;
X	p->labused = thisexec->labused;
X	thisexec->labelno = 0;
X	}
Xthisexec = p;
Xreturn(p);
X}
X
X
Xptr addexec()
X{
Xregister ptr p;
Xregister ptr q;
X
Xq = thisexec;
Xp = q->prevexec;
X
Xif(q->temps)
X	tempvarlist = hookup(q->temps, tempvarlist);
X
Xp->brnchend = q->brnchend;
Xp->nftnst += q->nftnst;
Xp->labeled |= q->labeled;
Xp->uniffable |= q->uniffable;
X
Xif(q->labelno && !(q->labused))
X	{
X	if(q->nxtlabno)
X		exnull();
X	else q->nxtlabno = q->labelno;
X	}
X
Xthisexec = p;
X
Xif(q->nxtlabno)
X	{
X	if(p->labelno && !(p->labused))
X		exnull();
X	p->labelno = q->nxtlabno;
X	p->labused = 0;
X	}
X
Xfrexcblock(q);
Xreturn(p);
X}
X
X
X
Xpushctl(t,vp)
Xint t;
Xregister ptr vp;
X{
Xregister ptr q;
Xptr p;
Xint junk;
X
Xq = allexcblock();
Xq->tag = TCONTROL;
Xq->subtype = t;
Xq->loopvar = vp;
Xq->prevctl = thisctl;
Xthisctl = q;
X
Xswitch(t)
X	{
X	case STSWITCH:
X		q->xlab = nextlab();
X		q->nextlab = 0;
X		exgoto(q->xlab);
X		ncases = -1;
X		break;
X
X	case STFOR:
X		exlab(0);
X		q->nextlab = nextlab();
X		q->xlab = nextlab();
X		break;
X
X	case STWHILE:
X		q->nextlab = thislab();
X		if(vp)
X			exifgo( mknode(TNOTOP,OPNOT,vp,PNULL),
X				q->breaklab = nextlab() );
X		else	thisexec->copylab = 1;
X		break;
X
X	case STREPEAT:
X		exnull();
X		q->xlab = thislab();
X		thisexec->copylab = 1;
X		junk = nextindif();
X		indifs[junk] = 0;
X		q->indifn = junk;
X		indifs[q->indifn] = q->xlab;
X		break;
X
X	case STDO:
X		q->nextlab = nextlab();
X		exlab(0);
X		putic(ICKEYWORD,FDO);
X		putic(ICLABEL, q->nextlab);
X		putic(ICBLANK, 1);
X		p = mknode(TASGNOP,OPASGN,vp->dovar,vp->dopar[0]);
X		prexpr(p);
X		frexpr(p);
X		putic(ICOP, OPCOMMA);
X		prexpr(vp->dopar[1]);
X		frexpr(vp->dopar[1]);
X		if(vp->dopar[2])
X			{
X			putic(ICOP, OPCOMMA);
X			prexpr(vp->dopar[2]);
X			frexpr(vp->dopar[2]);
X			}
X		cfree(vp);
X		break;
X
X	case STIF:
X		exif(vp);
X		thisexec->nftnst = 0;
X		break;
X
X	default:
X		fatal1("pushctl: invalid control block type %d", t);
X	}
X
X++ctllevel;
X}
X
X
X
Xpopctl()
X{
Xregister ptr p;
Xptr newp;
Xchainp q;
Xint first, deflabno, blab, cmin, cmax, range, caseval, optcase;
Xint labp[MAXSWITCH];
X
Xif(thisctl == 0)
X	fatal("empty control stack popped");
X
Xswitch(thisctl->subtype)
X	{
X	case STSWITCH:
X/*		if(thisexec->brnchend == 0)	*/
X			{
X			if(thisctl->breaklab == 0)
X				thisctl->breaklab = nextlab();
X			exgoto(thisctl->breaklab);
X			}
X		exlab(thisctl->xlab);
X		deflabno = 0;
X		first = YES;
X		optcase = (thisctl->loopvar->vtype == TYINT);
X
X		for(p=thisctl->loopctl ; p!=0 ; p = p->nextcase)
X			if(p->labdefined == 0)
X				{
X				laberr("undefined case label", CNULL);
X				optcase = NO;
X				}
X			else if(p->casexpr == 0)
X				deflabno = p->labelno;
X			else if( isicon(p->casexpr, &caseval))
X				{
X				if(first)
X					{
X					first = NO;
X					cmin = cmax = caseval;
X					}
X				else	{
X					if(caseval < cmin)
X						cmin = caseval;
X					if(caseval > cmax)
X						cmax = caseval;
X					}
X				++ncases;
X				}
X			else	optcase = NO;
X
X		range = cmax - cmin + 1;
X		if(optcase && ncases>2 && range<2*ncases && range<MAXSWITCH)
X			{
X			register int i;
X			for(i=0; i<range ; ++i)
X				labp[i] = 0;
X			for(p=thisctl->loopctl ; p!=0 ; p = p->nextcase)
X				if(p->labdefined && p->casexpr)
X					{
X					isicon(p->casexpr, &caseval);
X					frexpr(p->casexpr);
X					labp[caseval-cmin] = p->labelno;
X					}
X			
X			q = CHNULL;
X			blab = (deflabno ? deflabno : thisctl->breaklab);
X			for(i=range-1 ; i>=0 ; --i)
X				q = mkchain(labp[i] ? labp[i] : blab, q);
X			excompgoto(q, mknode(TAROP,OPPLUS, mkint(1-cmin),
X				     cpexpr(thisctl->loopvar) ));
X			}
X		else	{
X			for(p=thisctl->loopctl ; p!=0 ; p = p->nextcase)
X				if(p->labdefined && p->casexpr)
X					exifgo( mknode(TRELOP,OPEQ,
X					   cpexpr(thisctl->loopvar),p->casexpr),
X					   p->labelno);
X			}
X		if(deflabno)
X			exgoto(deflabno);
X
X		for(p = thisctl->loopctl ; p; p = newp)
X			{
X			newp = p->nextcase;
X			cfree(p);
X			}
X		thisctl->loopctl = NULL;
X		break;
X
X	case STFOR:
X		exgoto(thisctl->nextlab);
X		break;
X
X	case STWHILE:
X		exgoto(thisctl->nextlab);
X		break;
X
X	case STREPEAT:
X		break;
X
X	case STDO:
X		exnull();
X		exlab(thisctl->nextlab);
X		putic(ICKEYWORD,FCONTINUE);
X		break;
X
X	case STIF:
X		break;
X
X	case STPROC:
X		break;
X
X	default:
X		fatal1("popctl: invalid control block type %d",
X			thisctl->subtype);
X	}
X
Xif(thisctl->breaklab != 0)
X	thisexec->nxtlabno = thisctl->breaklab;
Xp = thisctl->prevctl;
Xfrexcblock(thisctl);
Xthisctl = p;
X--ctllevel;
X}

echo x - dcl.c
sed -e 's/^X//' > dcl.c << ''
X#include "defs"
X
X
Xstatic char mess[ ] = "inconsistent attributes";
X
Xattatt(a1 , a2)
Xregister struct atblock *a1, *a2;
X{
X#define MERGE1(x) {if(a1->x==0) a1->x = a2->x; else if(a2->x!=0 && a1->x!=a2->x) dclerr(mess,"x"+2); }
X
XMERGE1(attype);
XMERGE1(attypep);
XMERGE1(atprec);
XMERGE1(atclass);
XMERGE1(atext);
XMERGE1(atcommon);
XMERGE1(atdim);
X
Xif(a1->atprec!=0 && (a1->attype==TYREAL || a1->attype==TYCOMPLEX) )
X	a1->attype += (TYLREAL-TYREAL);
X
Xcfree(a2);
X}
X
X
X
Xattvars(a , v)
Xregister struct atblock * a;
Xregister chainp v;
X{
Xregister chainp p;
X
Xfor(p=v; p!=0 ; p = p->nextp)
X	attvr1(a, CHAIN(p)->datap);
X
Xif(a->attype == TYFIELD)
X	cfree(a->attypep);
Xelse if(a->attype == TYCHAR)
X	frexpr(a->attypep);
X
Xcfree(a);
X}
X
X#define MERGE(x,y) {if(v->y==0) v->y = a->x; else if(a->x!=0 && a->x!=v->y) dclerr(mess,"x"+2); }
X
X
X
X
X
Xattvr1(a, v)
Xregister struct atblock * a;
Xregister struct varblock * v;
X{
Xregister chainp p;
X
Xif(v->vdcldone)
X	{
X	dclerr("attempt to declare variable after use", v->sthead->namep);
X	return;
X	}
Xv->vdclstart = 1;
Xif(v->vclass == CLMOS)
X	dclerr("attempt to redefine structure member", v->sthead->namep);
Xif (VARBLOCK(v)->vdim == 0)
X	VARBLOCK(v)->vdim = a->atdim;
Xelse if(!eqdim(a->atdim, VARBLOCK(v)->vdim))
X	dclerr("inconsistent dimensions", v->sthead->namep);
Xif(v->vprec == 0)
X	v->vprec = a->atprec;
X
XMERGE(attype,vtype);
X
Xif(v->vtypep == 0)
X	{
X	if(a->attypep != 0)
X		if(a->attype == TYFIELD)
X			{
X			v->vtypep = ALLOC(fieldspec);
X			cpblock(a->attypep, v->vtypep, sizeof(struct fieldspec));
X			}
X		else if(a->attype == TYCHAR)
X			v->vtypep = cpexpr(a->attypep);
X		else	v->vtypep = a->attypep;
X	else if(a->attypep!=0 && a->attypep!=v->vtypep)
X		dclerr("inconsistent attributes", "typep");
X	}
X
Xif(v->vprec!=0 && (v->vtype==TYREAL || v->vtype==TYCOMPLEX) )
X	v->vtype += (TYLREAL-TYREAL);
X
Xif(a->atcommon)
X	if(v->vclass !=  0)
X		dclerr("common variable already in common, argument list, or external",
X			v->sthead->namep);
X	else	{
X		if(blklevel != a->atcommon->blklevel)
X			dclerr("inconsistent common block usage", "");
X		for(p = &(a->atcommon->comchain) ; p->nextp!=0 ; p = p->nextp) ;
X		p->nextp = mkchain(v, PNULL);
X	}
X
Xif(a->atext!=0 && v->vext==0)
X	{
X	v->vext = 1;
X	extname(v);
X	}
Xelse if(a->atclass == CLVALUE)
X	if(v->vclass==CLARG || v->vclass==CLVALUE)
X		v->vclass = CLVALUE;
X	else dclerr("cannot value a non-argument variable",v->sthead->namep);
Xelse  MERGE(atclass,vclass);
Xif(v->vclass==CLCOMMON || v->vclass==CLVALUE || v->vclass==CLAUTO)
X	setvproc(v, PROCNO);
X}
X
X
X
X
X
Xeqdim(a,b)
Xregister ptr a, b;
X{
Xif(a==0 || b==0 || a==b)  return(1);
X
Xa = CHAIN(a)->datap;
Xb = CHAIN(b)->datap;
X
Xwhile(a!=0 && b!=0)
X	{
X	if(!eqexpr(a->lowerb,b->lowerb) || !eqexpr(a->upperb,b->upperb))
X		return(0);
X
X	a = a->nextp;
X	b = b->nextp;
X	}
X
Xreturn( a == b );
X}
X
X
Xeqexpr(a,b)
Xregister ptr a, b;
X{
Xif(a==b) return(1);
Xif(a==0 || b==0) return(0);
Xif(a->tag!=b->tag || a->subtype!=b->subtype)
X	return(0);
X
Xswitch(a->tag)
X	{
Xcase TCONST:
X	return( equals(a->leftp, b->leftp) );
X
Xcase TNAME:
X	return( a->sthead ==  b->sthead );
X
Xcase TLIST:
X	a = a->leftp;
X	b = b->leftp;
X
X	while(a!=0 && b!=0)
X		{
X		if(!eqexpr(CHAIN(a)->datap,CHAIN(b)->datap))
X			return(0);
X		a = a->nextp;
X		b = b->nextp;
X		}
X	return( a == b );
X
Xcase TAROP:
Xcase TASGNOP:
Xcase TLOGOP:
Xcase TRELOP:
Xcase TCALL:
Xcase TREPOP:
X	return(eqexpr(a->leftp,b->leftp) && eqexpr(a->rightp,b->rightp));
X
Xcase TNOTOP:
Xcase TNEGOP:
X	return(eqexpr(a->leftp,b->leftp));
X
Xdefault:
X	badtag("eqexpr", a->tag);
X	}
X/* NOTREACHED */
X}
X
X
X
Xsetimpl(type, c1, c2)
Xint type;
Xregister int c1, c2;
X{
Xregister int i;
X
Xif(c1<'a' || c2<c1 || c2>'z')
X	dclerr("bad implicit range", CNULL);
Xelse if(type==TYUNDEFINED || type>TYLCOMPLEX)
X	dclerr("bad type in implicit statement", CNULL);
Xelse
X	for(i = c1 ; i<=c2 ; ++i)
X		impltype[i-'a'] = type;
X}
X
Xdoinits(p)
Xregister ptr p;
X{
Xregister ptr q;
X
Xfor( ; p ; p = p->nextp)
X	if( (q = CHAIN(p)->datap)->vinit)
X		{
X		mkinit(q, q->vinit);
X		q->vinit = 0;
X		}
X}
X
X
X
X
Xmkinit(v, e)
Xregister ptr v;
Xregister ptr e;
X{
Xif(v->vdcldone == 0)
X	dclit(v);
X
Xswii(idfile);
X
Xif(v->vtype!=TYCHAR && v->vtypep)
X	dclerr("structure initialization", v->sthead->namep);
Xelse if(VARBLOCK(v)->vdim==NULL || VARBLOCK(v)->vsubs!=NULL)
X	{
X	if(e->tag==TLIST && (v->vtype==TYCOMPLEX || v->vtype==TYLCOMPLEX) )
X		e = compconst(e);
X	valinit(v, e);
X	}
Xelse
X	arrinit(v,e);
X
Xswii(icfile);
X
Xfrexpr(e);
X}
X
X
X
X
X
Xvalinit(v, e)
Xregister ptr v;
Xregister ptr e;
X{
Xstatic char buf[4] = "1hX";
Xint vt;
X
Xvt = v->vtype;
X/*check for special case of one-character initialization of
X  non-character datum
X*/
Xif(vt==TYCHAR || e->vtype!=TYCHAR || !isconst(e) || strlen(e->leftp)!=1)
X	{
X	e = simple(RVAL, coerce(vt,e) );
X	if(e->tag == TERROR)
X		return;
X	if( ! isconst(e) )
X		{
X		dclerr("nonconstant initializer", v->sthead->namep);
X		return;
X		}
X	}
Xif(vt == TYCHAR)
X	{
X	charinit(v, e->leftp);
X	return;
X	}
Xprexpr( simple(LVAL,v) );
Xputic(ICOP,OPSLASH);
Xif(e->vtype != TYCHAR)
X	prexpr(e);
Xelse if(strlen(e->leftp) == 1)
X	{
X	buf[2] = e->leftp[0];
X	putsii(ICCONST, buf);
X	}
Xelse	dclerr("character initialization of nonchar", v->sthead->namep);
Xputic(ICOP,OPSLASH);
Xputic(ICMARK,0);
X}
X
X
X
Xarrinit(v, e)
Xregister ptr v;
Xregister ptr e;
X{
Xstruct exprblock *listinit(), *firstelt(), *nextelt();
Xptr arrsize();
X
Xif(e->tag!=TLIST && e->tag!=TREPOP)
X	e = mknode(TREPOP, 0, arrsize(v), e);
Xif( listinit(v, firstelt(v), e) )
X	warn("too few initializers");
Xif(VARBLOCK(v)->vsubs)
X	{
X	frexpr(VARBLOCK(v)->vsubs);
X	VARBLOCK(v)->vsubs = NULL;
X	}
X}
X
X
X
Xstruct exprblock *listinit(v, subs, e)
Xregister struct varblock *v;
Xstruct exprblock *subs;
Xregister ptr e;
X{
Xstruct varblock *vt;
Xregister chainp p;
Xint n;
Xstruct varblock *subscript();
Xstruct exprblock *nextelt();
X
Xswitch(e->tag)
X	{
X	case TLIST:
X		for(p = e->leftp; p; p = p->nextp)
X			{
X			if(subs == NULL)
X				goto toomany;
X			subs = listinit(v, subs, CHAIN(p)->datap);
X			}
X		return(subs);
X
X	case TREPOP:
X		if( ! isicon(e->leftp, &n) )
X			{
X			dclerr("nonconstant repetition factor");
X			return(subs);
X			}
X		while(--n >= 0)
X			{
X			if(subs == NULL)
X				goto toomany;
X			subs = listinit(v, subs, e->rightp);
X			}
X		return(subs);
X
X	default:
X		if(subs == NULL)
X			goto toomany;
X		vt = subscript(cpexpr(v), cpexpr(subs));
X		valinit(vt, e);
X		frexpr(vt);
X		return( nextelt(v,subs) );
X
X	}
X
Xtoomany:
X	dclerr("too many initializers", NULL);
X	return(NULL);
X}
X
X
X
X
Xcharinit(v,e)
Xptr v;
Xchar *e;
X{
Xregister char *bp;
Xchar buf[50];
Xregister int i, j;
Xint nwd, nch;
X
Xv = cpexpr(v);
Xif(VARBLOCK(v)->vsubs == 0)
X	VARBLOCK(v)->vsubs = mknode(TLIST,0, mkchain(mkint(1),CHNULL), PNULL);
X
Xnwd = ceil( nch = conval(v->vtypep) , tailor.ftnchwd);
Xsprintf(buf,"%dh", tailor.ftnchwd);
Xfor(bp = buf ; *bp ; ++bp )
X	;
X
X
Xfor(i = 0; i<nwd ; ++i)
X	{
X	if(i > 0) CHAIN(VARBLOCK(v)->vsubs->leftp)->datap = 
X		mknode(TAROP,OPPLUS, CHAIN(VARBLOCK(v)->vsubs->leftp)->datap, mkint(1));
X	prexpr( v = simple(LVAL,v) );
X
X	for(j = 0 ; j<tailor.ftnchwd && *e!='\0' && nch-->0 ; )
X		bp[j++] = *e++;
X	while(j < tailor.ftnchwd)
X		{
X		bp[j++] = ' ';
X		nch--;
X		}
X	bp[j] = '\0';
X
X	putic(ICOP,OPSLASH);
X	putsii(ICCONST, buf);
X	putic(ICOP,OPSLASH);
X	putic(ICMARK,0);
X	}
X
Xfrexpr(v);
X}
X
X
X
X
X
X
X
Xstruct exprblock *firstelt(v)
Xregister struct varblock *v;
X{
Xregister struct dimblock *b;
Xregister chainp s;
Xptr t;
Xint junk;
X
Xif(VARBLOCK(v)->vdim==NULL || VARBLOCK(v)->vsubs!=NULL)
X	fatal("firstelt: bad argument");
Xs = NULL;
Xfor(b = CHAIN(VARBLOCK(v)->vdim)->datap ; b; b = b->nextp)
X	{
X	t = (b->lowerb ? cpexpr(b->lowerb) : mkint(1) );
X	s = hookup(s, mkchain(t,CHNULL) );
X	if(!isicon(b->upperb,&junk) || (b->lowerb && !isicon(b->lowerb,&junk)) )
X		dclerr("attempt to initialize adjustable array",
X			v->sthead->namep);
X	}
Xreturn( mknode(TLIST, 0, s, PNULL) );
X}
X
X
X
X
Xstruct exprblock *nextelt(v,subs)
Xstruct varblock *v;
Xstruct exprblock *subs;
X{
Xregister struct dimblock *b;
Xregister chainp *s;
Xint sv;
X
Xif(v == NULL)
X	return(NULL);
X
Xb = CHAIN(VARBLOCK(v)->vdim)->datap;
Xs = subs->leftp;
X
Xwhile(b && s)
X	{
X	sv = conval(CHAIN(s)->datap);
X	frexpr(CHAIN(s)->datap);
X	if( sv < conval(b->upperb) )
X		{
X		CHAIN(s)->datap =mkint(sv+1);
X		return(subs);
X		}
X	CHAIN(s)->datap = (b->lowerb ? cpexpr(b->lowerb) : mkint(1) );
X
X	b = b->nextp;
X	s = s->nextp;
X	}
X
Xif(b || s)
X	fatal("nextelt: bad subscript count");
Xreturn(NULL);
X}

echo x - dclgen.c
sed -e 's/^X//' > dclgen.c << ''
X#include "defs"
X
X#define DOCOMMON 1
X#define NOCOMMON 0
X
Xdclgen()
X{
Xregister ptr p, q;
Xptr q1;
Xchainp *y, z;
Xregister struct stentry *s;
Xstruct stentry **hp;
Xint first;
Xint i, j;
Xextern char *types[];
Xchar *sp;
X
X/*   print procedure statement and argument list */
X
Xfor(p = prevcomments ; p ; p = p->nextp)
X	{
X	sp = CHAIN(p)->datap;
X	fprintf(codefile, "%s\n", sp+1);
X	cfree(sp);
X	}
Xfrchain(&prevcomments);
X
Xif(tailor.procheader)
X	fprintf(codefile, "%s\n", tailor.procheader);
X
Xif(procname)
X	{
X	p2str("      ");
X	if(procname->vtype==TYSUBR || procname->vtype==TYUNDEFINED)
X		p2key(FSUBROUTINE);
X	else	{
X		p2str(types[procname->vtype]);
X		p2key(FFUNCTION);
X		}
X
X	p2str(procname->sthead->namep);
X	}
Xelse if(procclass == PRBLOCK)
X	{
X	p2stmt(0);
X	p2key(FBLOCKDATA);
X	}
Xelse	{
X	p2str("c  main program");
X	if(tailor.ftnsys == CRAY)
X		{
X		p2stmt(0);
X		p2key(FPROGRAM);
X		}
X	}
X
Xif(thisargs)
X	{
X	p2str( "(" );
X	first = 1;
X
X	for(p = thisargs ; p ; p = p->nextp)
X		if( (q=CHAIN(p)->datap)->vextbase)
X			{
X			if(first) first = 0;
X			else p2str(", ");
X			p2str(ftnames[q->vextbase]);
X			}
X		else	for(i=0 ; i<NFTNTYPES ; ++i)
X				if(j = q->vbase[i])
X					{
X					if(first) first = 0;
X					else p2str( ", " );
X					p2str(ftnames[j]);
X					}
X	p2str( ")" );
X	}
X
X/* first put out declarations of variables that are used as
X   adjustable dimensions
X*/
X
Xy = 0;
Xz = & y;
Xfor(hp = hashtab ; hp<hashend; ++hp)
X	if( *hp && (q = (*hp)->varp) )
X		if(q->tag==TNAME && q->vadjdim && q!=procname)
X			z = z->nextp = mkchain(q,CHNULL);
X
Xdclchain(y, NOCOMMON);
Xfrchain(&y);
X
X/* then declare the rest of the arguments */
Xz = & y;
Xfor(p = thisargs ; p ; p = p->nextp)
X	if(CHAIN(p)->datap->vadjdim == 0)
X		z = z->nextp = mkchain(CHAIN(p)->datap,CHNULL);
Xdclchain(y, NOCOMMON);
Xfrchain(&y);
Xfrchain(&thisargs);
X
X
X/* now put out declarations for common blocks */
Xfor(p = commonlist ; p ; p = p->nextp)
X	prcomm(CHAIN(p)->datap);
X
XTEST fprintf(diagfile, "\nend of common declarations");
Xz = &y;
X
X/* next the other variables that are in the symbol table */
X
Xfor(hp = hashtab ; hp<hashend ; ++hp)
X	if( *hp && (q = (*hp)->varp) )
X		if(q->tag==TNAME && q->vadjdim==0 && q->vclass!=CLCOMMON &&
X		    q->vclass!=CLARG && q!=procname &&
X		    (tailor.dclintrinsics || q->vproc!=PROCINTRINSIC) )
X			z = z->nextp = mkchain(q,CHNULL);
X
Xdclchain(y, NOCOMMON);
Xfrchain(&y);
X
XTEST fprintf(diagfile, "\nend of symbol table, start of gonelist");
X
X/* now declare variables that are no longer in the symbol table */
X
Xdclchain(gonelist, NOCOMMON);
X
XTEST fprintf(diagfile, "\nbeginning of hidlist");
Xdclchain(hidlist, NOCOMMON);
X
Xdclchain(tempvarlist, NOCOMMON);
X
X
X/* finally put out equivalence statements that are generated 
X   because of structure and character variables
X*/
Xfor(p = genequivs; p ; p = p->nextp)
X	{
X	q = p->datap;
X	p2stmt(0);
X	first = 1;
X	p2key(FEQUIVALENCE);
X	p2str( "(" );
X	for(i=0; i<NFTNTYPES; ++i)
X		if(q->vbase[i])
X			{
X			if(first) first = 0;
X			else p2str( ", " );
X			p2str(ftnames[ q->vbase[i] ]);
X			p2str( "(1" );
X			if(q1 = q->vdim)
X				for(q1 = q1->datap; q1 ; q1 = q1->nextp)
X					p2str( ",1" );
X			p2str( ")" );
X			}
X	p2str( ")" );
X	}
Xfrchain(&genequivs);
X}
X
X
X
X
Xprcomm(p)
Xregister ptr p;
X{
Xregister int first;
Xregister ptr q;
X
Xp2stmt(0);
Xp2key(FCOMMON);
Xp2str( "/" );
Xp2str(p->comname);
Xp2str("/ ");
Xfirst = 1;
Xfor(q = p->comchain ; q; q = q->nextp)
X	{
X	if(first) first=0;
X	else p2str(", ");
X	prname(q->datap);
X	}
Xdclchain(p->comchain, DOCOMMON);
X}
X
X
X
Xprname(p)
Xregister ptr p;
X{
Xregister int i;
X
Xswitch(p->tag)
X	{
X	case TCONST:
X		p2str(p->leftp);
X		return;
X
X	case TNAME:
X		if( ! p->vdcldone )
X			if(p->blklevel == 1)
X				dclit(p);
X			else	mkftnp(p);
X		for(i=0; i<NFTNTYPES ; ++i)
X			if(p->vbase[i])
X				{
X				p2str(ftnames[p->vbase[i]]);
X				return;
X				}
X		fatal1("prname: no fortran types for name %s",
X			p->sthead->namep);
X
X	case TFTNBLOCK:
X		for(i=0; i<NFTNTYPES ; ++i)
X			if(p->vbase[i])
X				{
X				p2str(ftnames[p->vbase[i]]);
X				return;
X				}
X		return;
X
X	default:
X		badtag("prname", p->tag);
X	}
X}
X
X
X
X
Xdclchain(chp, okcom)
Xptr chp;
Xint okcom;
X{
Xextern char *ftntypes[];
Xregister ptr pn, p;
Xregister int i;
Xint first, nline;
Xptr q,v;
Xint ntypes;
Xint size,align,mask;
Xint subval;
X
Xnline = 0;
Xfor(pn = chp ; pn ; pn = pn->nextp)
X	{
X	p = pn->datap;
X	if( (p->tag==TNAME || p->tag==TTEMP) && p->vext!=0)
X		{
X		if(nline%NAMESPERLINE == 0)
X			{
X			p2stmt(0);
X			p2key(FEXTERNAL);
X			}
X		else	p2str(", ");
X		++nline;
X		p2str(ftnames[p->vextbase]);
X		}
X	}
X
X
Xfor(pn = chp ; pn ; pn = pn->nextp)
X	{
X	p = pn->datap;
X	if( (p->tag==TNAME || p->tag==TTEMP) &&
X	    p->vtype==TYSTRUCT && p->vclass!=CLARG)
X		{
X		ntypes = 0;
X		for(i=0; i<NFTNTYPES; ++i)
X			if(p->vbase[i])
X				++ntypes;
X		if(ntypes > 1)
X			genequivs = mkchain(p, genequivs);
X		}
X	}
X
Xfor(i=0; i<NFTNTYPES; ++i)
X	{
X	nline = 0;
X	for(pn = chp; pn ; pn = pn->nextp)
X		{
X		p = pn->datap;
X		if( (p->tag==TNAME || p->tag==TTEMP) &&
X		    p->vtype!=TYSUBR && p->vbase[i]!=0 &&
X		    (okcom || p->vclass!=CLCOMMON) )
X			{
X			if(nline%NAMESPERLINE == 0)
X				{
X				p2stmt(0);
X				p2str(ftntypes[i]);
X				}
X			else	p2str( ", " );
X			++nline;
X			p2str(ftnames[p->vbase[i]]);
X			first = -1;
X		
X			if(p->vtype==TYCHAR || p->vtype==TYSTRUCT ||
X			   (p->vtype==TYLCOMPLEX && tailor.lngcxtype==NULL))
X				{
X				p2str( "(" );
X				sizalign(p, &size,&align,&mask);
X				p2int( size/tailor.ftnsize[i] );
X				first = 0;
X				}
X			else if(p->vdim)
X				{
X				p2str( "(" );
X				first = 1;
X				}
X			if(first >=0)
X				{
X				if(q = p->vdim)
X				    for(q = q->datap ; q ; q = q->nextp)
X					{
X					if(q->upperb == 0)
X						{
X						q->upperb = mkint(1);
X						if(q->lowerb)
X							{
X							frexpr(q->lowerb);
X							q->lowerb = 0;
X							}
X						}
X					else if(q->lowerb)
X						{
X						v = fold( mknode(TAROP,OPMINUS,
X							mkint(1),cpexpr(q->lowerb)) );
X						v = fold( mknode(TAROP,OPPLUS,
X							cpexpr(q->upperb),v) );
X						q->lowerb = 0;
X						q->upperb = v;
X						}
X					if(first) first = 0;
X					else p2str( ", " );
X					v = q->upperb = simple(RVAL,q->upperb);
X					if( (HEADBITS(v)->tag==TNAME && v->vclass==CLARG) ||
X					    (isicon(v,&subval) && subval>0) )
X						prname(v);
X					else	dclerr("invalid array bound",
X						p->sthead->namep);
X					}
X				p2str( ")" );
X				}
X			}
X		}
X	}
X}

echo x - error.c
sed -e 's/^X//' > error.c << ''
X#include "defs"
X
Xchar *linerr()
X{
Xstatic char buff[50];
Xregister int i;
X
Xfor(i = filedepth; i>0 && filenames[i]==NULL ; --i)
X	;
Xif(i > 0)
X	sprintf(buff, "on line %d of file %s", yylineno, filenames[i]);
Xelse
X	sprintf(buff, "on line %d", yylineno);
Xreturn(buff);
X}
X
X
X
Xlaberr(s,t)
Xchar *s;
Xchar *t;
X{
Xerrmess("Label error", s, t);
X}
X
X
X
X
X
Xexprerr(s,t)
Xchar *s;
Xptr t;
X{
Xerrmess("Expression error", s, t);
X}
X
X
X
X
Xexecerr(s,t)
Xchar *s, *t;
X{
Xerrmess("Error", s, t);
X}
X
X
Xerrmess(m,s,t)
Xchar *m, *s, *t;
X{
Xfprintf(diagfile, "**%s %s:  ", m, linerr());
Xif(s)
X	fprintf(diagfile, s, t);
Xfprintf(diagfile, "\n");
X++nerrs;
X}
X
X
X
Xdclerr(s, n)
Xchar *s, *n;
X{
Xextern int nerrs;
X
Xfprintf(diagfile, "**Error %s: Declaration for %s: %s\n",
X		linerr(), n, s);
X++nerrs;
X}
X
X
X
X
Xbadtag(routine, tag)
Xchar *routine;
Xint tag;
X{
Xchar buff[100];
Xsprintf(buff, "impossible tag %d in routine %s", tag, routine);
Xfatal(buff);
X}
X
X
X
Xfatal1(s,t)
Xchar *s;
Xint t;
X{
X
Xsprintf(msg, s, t);
Xfatal(msg);
X}
X
X
X
Xfatal(s)
Xchar *s;
X{
Xfprintf(diagfile, "\n***Compiler error %s.", linerr());
Xif(s) fprintf(diagfile, "   %s.", s);
Xfprintf(diagfile, "\n");
Xfflush(stdout);
X
Xif(dumpcore)
X	abort(0);
Xelse	{
X	rmiis();
X	exit(-1);
X	}
X}
X
X
X
Xwarn1(s,t)
Xchar *s;
Xint t;
X{
Xsprintf(msg, s, t);
Xwarn(msg);
X}
X
X
X
X
Xwarn(s)
Xchar *s;
X{
X++nwarns;
Xif( !nowarnflag)
X	fprintf(diagfile, "*Warning: %s\n", s);
X}
X
X
X
Xyyerror(s)
Xchar *s;
X{
Xerrmess(s, CNULL, CNULL);
X}

echo x - exec.c
sed -e 's/^X//' > exec.c << ''
X#include "defs"
X
Xexlab(n)
Xregister int n;
X{
Xif(n==0 && thisexec->labelno && !(thisexec->labused))
X	{
X	thisexec->labused = 1;
X	n = thisexec->labelno;
X	}
X
Xif(!prevbg || n!=0)  /* avoid empty statement */
X	{
X	if(comments && !afterif) putcomment();
X	putic(ICBEGIN, n);
X	putic(ICINDENT, ctllevel);
X	if(n != 0)
X		if(stnos[n] != 0)
X			fatal("statement number changed");
X		else	stnos[n] = ( nxtstno += tailor.deltastno) ;
X	TEST fprintf(diagfile, "LABEL %d\n", n);
X	thisexec->nftnst++;
X	afterif = 0;
X	}
X}
X
X
Xexgoto(n)
Xint n;
X{
Xexlab(0);
Xexgo1(n);
X}
X
Xexgoind(n)
Xint n;
X{
Xexlab(0);
Xputic(ICKEYWORD,FGOTO);
Xputic(ICINDPTR,n);
XTEST fprintf(diagfile, "goto indirect %o\n", n);
X}
X
X
X
Xexgo1(n)
Xint n;
X{
Xputic(ICKEYWORD,FGOTO);
Xputic(ICLABEL,n);
XTEST fprintf(diagfile, "goto %d\n", n);
X}
X
X
Xexcompgoto(labs,index)
Xptr labs;
Xregister ptr index;
X{
Xregister int first;
Xregister ptr p;
X
Xindex = simple(LVAL,index);
Xif(tailor.ftn77)
X	exlab(0);
Xelse
X	{
X	int ncases = 0;
X	for(p = labs ; p ; p = p->nextp)
X		++ncases;
X	exif1( mknode(TLOGOP, OPAND,
X		mknode(TRELOP,OPGT, cpexpr(index), mkint(0)),
X		mknode(TRELOP,OPLE, cpexpr(index), mkint(ncases)) ));
X	}
X
Xputic(ICKEYWORD, FGOTO);
Xputic(ICOP,OPLPAR);
X
Xfirst = 1;
Xfor(p = labs ; p ; p = p->nextp)
X	{
X	if(first)   first = 0;
X	else   putic(ICOP,OPCOMMA);
X	putic(ICLABEL,p->datap);
X	}
Xputic(ICOP,OPRPAR);
Xfrchain(&labs);
X
Xputic(ICOP,OPCOMMA);
Xprexpr(index);
Xfrexpr(index);
XTEST fprintf(diagfile, "computed goto\n");
X}
X
X
X
X
Xexcall(p)
Xregister ptr p;
X{
Xregister ptr q1, q2, q3;
Xptr mkholl(), exioop();
X
Xif(p->tag==TNAME || p->tag==TFTNBLOCK)
X	p = mkcall(p, PNULL);
X
Xif(p->tag == TERROR)
X	{
X	frexpr(p);
X	return;
X	}
Xif(p->tag != TCALL)
X	badtag("excall", p->tag);
X
Xq1 = p->leftp;
Xq2 = (q1->tag==TFTNBLOCK ? q1 : q1->sthead->varp);
Xif(q2->vtype!=TYUNDEFINED && q2->vtype!=TYSUBR)
X	{
X	dclerr("attempt to use a variable as a subroutine", p->sthead->namep);
X	frexpr(p);
X	return;
X	}
Xq1->vtype = q2->vtype = TYSUBR;
Xif(q1->vdcldone==0)
X	dclit(q1);
X
Xif(q1->tag == TNAME)
X	{
X	if( equals(q2->sthead->namep, "stop") )
X		{
X		exlab(0);
X		putic(ICKEYWORD, FSTOP);
X		TEST fprintf(diagfile,"stop ");
X		if( (q1 = p->rightp) && (q1 = q1->leftp) )
X			prexpr( simple(RVAL, q1->datap) );
X		goto done;
X		}
X	if( ioop(q2->sthead->namep) )
X		{
X		exioop(p,NO);
X		goto done;
X		}
X	}
X
Xp = simple(RVAL,p);
Xexlab(0);
Xputic(ICKEYWORD,FCALL);
XTEST fprintf(diagfile, "call ");
X/* replace character constant arguments with holleriths */
Xif( (q1=p->rightp) && tailor.hollincall)
X	for(q1 = q1->leftp ; q1 ; q1 = q1->nextp)
X		if( (q2 = q1->datap)->tag==TCONST
X		    && q2->vtype==TYCHAR)
X			{
X			q2->vtype = TYHOLLERITH;
X			frexpr(q2->vtypep);
X			q2->vtypep = 0;
X			q2->leftp = mkholl(q3 = q2->leftp);
X			cfree(q3);
X			}
Xprexpr( p );
X
Xdone:	frexpr(p);
X}
X
X
X
X
Xptr mkholl(p)
Xregister char *p;
X{
Xregister char *q, *t, *s;
Xint n;
X
Xn = strlen(p);
Xq = convic(n);
Xs = t = calloc(n + 2 + strlen(q) , 1);
Xwhile(*q)
X	*t++ = *q++;
X*t++ = 'h';
Xwhile(*t++ = *p++ )
X	;
Xreturn(s);
X}
X
X
Xptr ifthen()
X{
Xptr p;
Xptr addexec();
X
Xp = addexec();
Xthisexec->brnchend = 0;
Xif(thisexec->nftnst == 0)
X	{
X	exlab(0);
X	putic(ICKEYWORD,FCONTINUE);
X	thisexec->nftnst = 1;
X	}
Xif(thisexec->nftnst>1 || thisexec->labeled || thisexec->uniffable )
X	{
X	if(thisctl->breaklab == 0)
X		thisctl->breaklab = nextlab();
X	indifs[thisctl->indifn] = thisctl->breaklab;
X	}
Xelse	thisctl->breaklab = 0;
Xreturn(p);
X}
X
X
X
Xexasgn(l,o,r)
Xptr l;
Xint o;
Xptr r;
X{
Xexlab(0);
Xif(l->vdcldone == 0)
X	dclit(l);
Xfrexpr( simple(LVAL , mknode(TASGNOP,o,l,r)) );
X}
X
Xexretn(p)
Xptr p;
X{
Xif(p)
X	{
X	if(procname && procname->vtype && procname->vtype!=TYCHAR &&
X	  (procname->vtype!=TYLCOMPLEX || tailor.lngcxtype!=NULL) )
X		{
X		if(p->tag!=TNAME || p->sthead!=procname->sthead)
X			exasgn( cpexpr(procname) , OPASGN, p);
X		}
X	else execerr("can only return values in a function", PNULL);
X	}
Xelse if(procname && procname->vtype)
X	 warn("function return without data value");
Xexlab(0);
Xputic(ICKEYWORD, FRETURN);
X
XTEST {fprintf(diagfile, "exec: return( " );  prexpr(p);  fprintf(diagfile, ")\n" );  }
X}
X
X
Xexnull()
X{
Xif(thisexec->labelno && !(thisexec->labused) )
X	{
X	exlab(0);
X	putic(ICKEYWORD,FCONTINUE);
X	}
X}
X
X
X
X
Xexbrk(opnext,levskip,btype)
Xint opnext;
Xptr levskip;
Xint btype;
X{
X
Xif(opnext && (btype==STSWITCH || btype==STPROC))
X	execerr("illegal next", PNULL);
Xelse if(!opnext && btype==STPROC)
X	exretn(PNULL);
Xelse  brknxtlab(opnext,levskip,btype);
XTEST fprintf(diagfile, "exec: %s\n", (opnext ? "next" : "exit"));
X
X}
X
X
X
Xexif(e)
Xregister ptr e;
X{
Xint tag;
X
Xif( (tag = e->tag)==TERROR || e->vtype!=TYLOG)
X	{
X	frexpr(e);
X	e = mkconst(TYLOG, ".true.");
X	if(tag != TERROR)
X		execerr("non-logical conditional expression in if", PNULL);
X	}
XTEST fprintf(diagfile, "exif called\n");
Xe = simple(RVAL,e);
Xexlab(0);
Xputic(ICKEYWORD,FIF2);
Xindifs[thisctl->indifn = nextindif()] = 0;
Xputic(ICINDPTR, thisctl->indifn);
Xputic(ICOP,OPLPAR);
Xprexpr(e);
Xputic(ICOP,OPRPAR);
Xputic(ICMARK,0);
Xputic(ICOP,OPLPAR);
Xprexpr(e = simple(RVAL, mknode(TNOTOP,OPNOT,e,PNULL)));
Xputic(ICOP,OPRPAR);
Xputic(ICMARK,0);
Xafterif = 1;
Xfrexpr(e);
X}
X
X
Xexifgo(e,l)
Xptr e;
Xint l;
X{
Xexlab(0);
Xexif1(e);
Xexgo1(l);
X}
X
X
Xexif1(e)
Xregister ptr e;
X{
Xe = simple(RVAL,e);
Xexlab(0);
Xputic(ICKEYWORD,FIF1);
Xputic(ICOP,OPLPAR);
XTEST fprintf(diagfile, "if1 ");
Xprexpr( e );
Xfrexpr(e);
Xputic(ICOP,OPRPAR);
Xputic(ICBLANK, 1);
X}
X
X
X
X
X
X
X
Xbrkcase()
X{
Xptr bgnexec();
X
Xif(ncases==0 /* && thisexec->prevexec->brnchend==0 */ )
X	{
X	exbrk(0, PNULL, 0);
X	addexec();
X	bgnexec();
X	}
Xncases = 1;
X}
X
X
Xbrknxtlab(opnext, levp, btype)
Xint opnext;
Xptr levp;
Xint btype;
X{
Xregister ptr p;
Xint levskip;
X
Xlevskip = ( levp ? convci(levp->leftp) : 1);
Xif(levskip <= 0)
X	{
X	execerr("illegal break count %d", levskip);
X	return;
X	}
X
Xfor(p = thisctl ; p!=0 ; p = p->prevctl)
X	if( (btype==0 || p->subtype==btype) &&
X	    p->subtype!=STIF && p->subtype!=STPROC &&
X	    (!opnext || p->subtype!=STSWITCH) )
X		if(--levskip == 0) break;
X
Xif(p == 0)
X	{
X	execerr("invalid break/next", PNULL);
X	return;
X	}
X
Xif(p->subtype==STREPEAT && opnext)
X	exgoind(p->indifn);
Xelse if(opnext)
X	exgoto(p->nextlab);
Xelse	{
X	if(p->breaklab == 0)
X		p->breaklab = nextlab();
X	exgoto(p->breaklab);
X	}
X}
X
X
X
Xptr doloop(p1,p2,p3)
Xptr p1;
Xptr p2;
Xptr p3;
X{
Xregister ptr p, q;
Xregister int i;
Xint val[3];
X
Xp = ALLOC(doblock);
Xp->tag = TDOBLOCK;
X
Xif(p1->tag!=TASGNOP || p1->subtype!=OPASGN || p1->leftp->tag!=TNAME)
X	{
X	p->dovar = gent(TYINT, PNULL);
X	p->dopar[0] = p1;
X	}
Xelse	{
X	p->dovar = p1->leftp;
X	p->dopar[0] = p1->rightp;
X	frexpblock(p1);
X	}
Xif(p2 == 0)
X	{
X	p->dopar[1] = p->dopar[0];
X	p->dopar[0] = mkint(1);
X	}
Xelse	p->dopar[1] = p2;
Xp->dopar[2] = p3;
X
Xfor(i = 0; i<3 ; ++i)
X	{
X	if(q = p->dopar[i])
X		{
X		if( (q->tag==TNAME || q->tag==TTEMP) &&
X		   (q->vsubs || q->voffset) )
X			p->dopar[i] = simple(RVAL,mknode(TASGNOP,0,
X				gent(TYINT,PNULL), q));
X		else
X			p->dopar[i] = simple(LVAL, coerce(TYINT, q) );
X
X		if(isicon(p->dopar[i], &val[i]))
X			{
X			if(val[i] <= 0)
X				execerr("do parameter out of range", PNULL);
X			}
X		else	val[i] = -1;
X		}
X	}
X
Xif(val[0]>0 && val[1]>0 && val[0]>val[1])
X	execerr("do parameters out of order", PNULL);
Xreturn(p);
X}

echo x - field.c
sed -e 's/^X//' > field.c << ''
X#include "defs"
X
X
X
Xptr mkfield(q)
Xregister ptr q;
X{
Xregister ptr p;
X
Xif(!instruct)
X	goto err;
Xelse if(q->upperb == 0)
X	dclerr("must have upper bound in field spcification", "");
Xelse
X	{
X	p = ALLOC(fieldspec);
X	p->tag = TFIELD;
X	if(q->lowerb)
X		{
X		p->flbound = q->lowerb;
X		p->frange = mknode(TAROP,OPPLUS,mknode(TAROP,OPMINUS,
X				q->upperb, cpexpr(q->lowerb)),
X				mkconst(TYINT,"1") );
X		}
X	else	{
X		p->flbound = mkconst(TYINT,"1");
X		p->frange = q->upperb;
X		}
X	p->frange = simple(RVAL,p->frange);
X	if(p->frange->tag != TCONST)
X		{
X		dclerr("field range must be constant", "");
X		cfree(p);
X		goto err;
X		}
X	cfree(q);
X	return(p);
X	}
X
Xerr:
X	cfree(q);
X	return( errnode() );
X}
X
X
X
X
X
Xptr extrfield(p)
Xregister ptr p;
X{
Xregister ptr t;
X
Xt = p->vtypep;
Xp->vtype = TYINT;
Xp->vtypep = 0;
X
Xif(t->frshift)
X	p = mknode(TAROP,OPSLASH, p, cpexpr(t->frshift));
Xif(t->fanymore)
X	p = mkcall(builtin(TYINT, "mod"), arg2(p, cpexpr(t->frange)) );
Xp = mknode(TAROP,OPPLUS, p, cpexpr(t->flbound));
Xreturn(p);
X}
X
X
X
X
Xptr setfield(e)
Xptr e;
X{
Xptr lp, rp;
Xregister ptr f, p;
Xint subt;
X
Xlp = cpexpr(e->leftp);
Xrp = e->rightp;
Xsubt = e->subtype;
Xf = lp->vtypep;
Xlp->vtype = TYINT;
Xlp->vtypep = 0;
X
Xif(subt==OPPLUS || subt==OPMINUS)
X	{
X	if(f->frshift)
X		rp = mknode(TAROP,OPSTAR,rp,cpexpr(f->frshift));
X	}
Xelse	{
X	if(subt != OPASGN)
X		{
X		rp = mknode(TAROP,subt, extrfield(cpexpr(e->leftp)), rp);
X		subt = OPASGN;
X		}
X	rp = coerce(TYINT,rp);
X	if(f->flbound)
X		rp = simple(RVAL, mknode(TAROP,OPMINUS,rp,cpexpr(f->flbound)) );
X	
X	if(f->frshift==0)
X		{
X		if(f->fanymore)
X			{
X			p = mknode(TAROP,OPSLASH,cpexpr(lp),cpexpr(f->frange));
X			p->needpar = YES;
X			p = mknode(TAROP,OPSTAR,cpexpr(f->frange),p);
X			rp = mknode(TAROP,OPPLUS,p,rp);
X			}
X		}
X	else if(f->fanymore==0)
X		{
X		rp = mknode(TAROP,OPSTAR,cpexpr(f->frshift),rp);
X		p = mkcall(builtin(TYINT,"mod"),
X			arg2(cpexpr(lp),cpexpr(f->frshift)) );
X		rp = mknode(TAROP,OPPLUS, p,rp);
X		}
X	else	{
X		p = mknode(TAROP,OPSLASH,cpexpr(lp),cpexpr(f->frshift));
X		p = mkcall(builtin(TYINT,"mod"), 
X			arg2(p, cpexpr(f->frange)) );
X		if( rp->tag!=TCONST || !equals(rp->leftp, "0") )
X			p = mknode(TAROP,OPMINUS, p, rp);
X		rp = mknode(TAROP,OPSTAR, cpexpr(f->frshift), p);
X		rp = mknode(TAROP,OPMINUS, cpexpr(lp), rp);
X		}
X	}
Xfrexpr( simple(LVAL, mknode(TASGNOP,subt,lp,rp) ));
Xreturn(extrfield(e->leftp));
X}

echo x - fixuplex
sed -e 's/^X//' > fixuplex << ''
X#! /bin/sh
Xed - lex.yy.c <<!
X/input/s/getc(yyin)/efgetc/
X/yylex/+1a
Xif(pushlex)
X	if(pushlex==1)
X		{
X		pushlex = 2;
X		yylval.ival = 0;
X		return(EOS);
X		}
X	else	{
X		pushlex = 0;
X		if(rket == 2)
X			rket = 1;
X		else	RETL(prevv,prevl);
X		}
Xif(rket > 0)
X	{
X	if(rket==1)
X		{
X		rket = 2;
X		RET(RBRACK);
X		}
X	else	{
X		rket = 0;
X		RET(EOS);
X		}
X	}
Xif(eofneed) return(0);
Xif(forcerr) return(-1);
X.
Xw
Xq
X!

echo x - free.c
sed -e 's/^X//' > free.c << ''
X#include "defs"
X
X
Xcleanst()
X{
Xregister ptr p, q;
Xptr pjunk;
Xint i;
Xregister struct stentry *s;
Xstruct stentry **hp;
X
XTEST fprintf(diagfile, "\n");
X
Xclcomm();
X
Xfor(hp = hashtab ; hp<hashend ; ++hp)
X    while( s = *hp )
X	{
X	if( q = s->varp )
X		{
X		if( q->blklevel > 0 )
X			{
X			TEST fprintf(diagfile, "remove %s from st\n", s->namep);
X			switch(q->tag)
X				{
X				case TNAME:
X					frvar(q);
X					break;
X
X				case TSTRUCT:
X					frtype(q);
X					break;
X
X				case TDEFINE:
X					frdef(q);
X					break;
X
X				case TLABEL:
X					cfree(q);
X					break;
X
X				default:
X					sprintf(msg, "cleanst: illegal entry tag %d, ptr %o, name %s.",
X						q->tag, q, s->namep);
X					fatal(msg);
X				}
X			}
X		else if( q->tag == TNAME )
X			{
X			q->vdcldone = 0;
X			q->vnamedone = 0;
X			q->vextbase = 0;
X			for(i = 0 ; i<NFTNTYPES ; ++i)
X				q->vbase[i] = 0;
X			}
X		}
X	if(s->blklevel > 0)
X		name(s->namep,-1);
X	else	break;
X	}
X
Xfor(p = gonelist ; p ; p = p->nextp)
X	frvar(p->datap);
Xfrchain(&gonelist);
X
Xif(hidlist) fatal("cleanst: hidlist not empty");
Xfor(p = hidlist ; p ; p = p->nextp)
X	frvar(p->datap);
Xfrchain(&hidlist);
X
Xfor(p = tempvarlist ; p ; p = p->nextp)
X	frvar(p->datap);
Xfrchain(&tempvarlist);
X
Xfor(p = temptypelist ; p ; p = p->nextp)
X	if(p->datap->blklevel > 0)
X		frtype(p->datap);
Xfrchain(&temptypelist);
X
Xq = &arrays;
Xfor(p = arrays ; p ; p = q->nextp)
X	if(p->datap == 0)
X		{
X		q->nextp = p->nextp;
X		p->nextp = 0;
X		pjunk = p;
X		frchain(&pjunk);
X		}
X	else	q = p;
X}
X
X
X
Xfrvar(p)
Xregister ptr p;
X{
Xregister ptr q, qn;
X
Xif(p==0) return;
X
Xswitch(p->tag)
X	{
X	case TSTRUCT:
X		frtype(p);
X		return;
X
X	case TDEFINE:
X		frdef(p);
X		return;
X
X	case TNAME:
X	case TTEMP:
X		if(q = p->vdim)
X		    for(q = q->datap ; q ; q = qn)
X			{
X			if(q->lowerb) frexpr(q->lowerb);
X			frexpr(q->upperb);
X			qn = q->nextp;
X			cfree(q);
X			}
X		
X		if(p->vdim)
X			p->vdim->datap = 0;
X		if(p->vtype == TYCHAR)
X			frexpr(p->vtypep);
X		frexpblock(p);
X		return;
X
X	default:
X		badtag("frvar",p->tag);
X	}
X}
X
X
Xfrtype(p)
Xregister ptr p;
X{
Xregister ptr q;
X
Xif(p==0 || p->tag!=TSTRUCT)
X	fatal("frtype: bad argument");
Xfor(q = p->strdesc ; q; q = q->nextp)
X	frvar(q->datap);
Xfrchain( &(p->strdesc) );
Xcfree(p);
X}
X
X
X
Xfrdef(p)
Xptr p;
X{
Xcfree(p->valp);
Xcfree(p);
X}
X
X
X
Xfrexpr(p)
Xregister ptr p;
X{
Xregister ptr q;
X
Xif(p == 0) return;
X
Xswitch(p->tag)
X	{
X	case TAROP:
X	case TRELOP:
X	case TLOGOP:
X	case TASGNOP:
X	case TREPOP:
X	case TCALL:
X		frexpr(p->rightp);
X
X
X	case TNOTOP:
X	case TNEGOP:
X		frexpr(p->leftp);
X		break;
X
X	case TCONST:
X		cfree(p->leftp);
X		if(p->vtype == TYCHAR)
X			frexpr(p->vtypep);
X		if(p->rightp)
X			cfree(p->rightp);
X		break;
X
X	case TLIST:
X		for(q = p->leftp ; q ; q = q->nextp)
X			frexpr(q->datap);
X		frchain( &(p->leftp) );
X		break;
X
X	case TTEMP:
X	case TNAME:
X	case TFTNBLOCK:
X		if(p->vsubs)
X			frexpr(p->vsubs);
X		if(p->voffset)
X			frexpr(p->voffset);
X
X	case TERROR:
X/*debug*/ case TIOSTAT:
X		break;
X
X	default:
X		badtag("frexpr", p->tag);
X	}
Xfrexpblock(p);
X}
X
X
X
X
Xclcomm()	/* clean up common lists */
X{
Xptr p, oldp, q;
X
Xfor(oldp = &commonlist ; p = oldp->nextp ;  )
X	{
X	q = p->datap;
X
X	if(q->blklevel > 0)
X		{
X		frchain( &(q->comchain) );
X		cfree(q);
X		oldp->nextp = p->nextp;
X		cfree(p);
X		}
X	else   oldp = p;
X	}
X}

echo x - gram.c
sed -e 's/^X//' > gram.c << ''
X#define YYDEBUG
X# define EOS 1
X# define NEWLINE 2
X# define LPAR 3
X# define RPAR 4
X# define LBRACK 5
X# define RBRACK 6
X# define COMMA 7
X# define COLON 8
X# define ASGNOP 9
X# define REPOP 10
X# define OR 11
X# define AND 12
X# define NOT 13
X# define RELOP 14
X# define ADDOP 15
X# define MULTOP 16
X# define POWER 17
X# define DOUBLEADDOP 18
X# define ARROW 19
X# define QUALOP 20
X# define NAME 21
X# define OPTNAME 22
X# define STRUCTNAME 23
X# define COMNAME 24
X# define CONST 25
X# define COMMON 26
X# define INTERNAL 27
X# define EXTERNAL 28
X# define AUTOMATIC 29
X# define STATIC 30
X# define VALUE 31
X# define PROCEDURE 32
X# define BLOCKDATA 33
X# define OPTION 34
X# define INCLUDE 35
X# define DEFINE 36
X# define END 37
X# define INTEGER 38
X# define REAL 39
X# define COMPLEX 40
X# define LOGICAL 41
X# define CHARACTER 42
X# define STRUCT 43
X# define FIELD 44
X# define ARRAY 45
X# define DIMENSION 46
X# define LONG 47
X# define SHORT 48
X# define INITIAL 49
X# define EQUIVALENCE 50
X# define IMPLICIT 51
X# define DEBUG 52
X# define IF 53
X# define ELSE 54
X# define WHILE 55
X# define UNTIL 56
X# define REPEAT 57
X# define DO 58
X# define FOR 59
X# define SWITCH 60
X# define CASE 61
X# define DEFAULT 62
X# define GO 63
X# define GOTO 64
X# define BREAK 65
X# define EXIT 66
X# define NEXT 67
X# define RETURN 68
X# define CONTINUE 69
X# define CALL 70
X# define DOUBLE 71
X# define PRECISION 72
X# define DOUBLEPRECISION 73
X# define SIZEOF 74
X# define LENGTHOF 75
X# define LETTER 76
X# define READ 77
X# define WRITE 78
X# define READBIN 79
X# define WRITEBIN 80
X# define TRUE 81
X# define FALSE 82
X# define ESCAPE 83
X
X# line 85 "gram.in"
X#include "defs"
Xptr bgnexec(), addexec(), bgnproc(), mkvar(), mkcomm(), mkstruct(), mkarrow();
Xptr mkiost(), mkioitem(), mkiogroup(), mkformat();
Xptr funcinv(), extrfield(), typexpr(), strucelt(), mkfield();
Xptr esizeof(), elenof(), mkilab();
Xptr ifthen(), doloop();
Xstruct varblock *subscript();
X
X# line 95 "gram.in"
Xtypedef union  { int ival; ptr pval; char *cval; } YYSTYPE;
X
X# line 124 "gram.in"
Xextern int prevv;
Xextern YYSTYPE prevl;
Xptr p;
Xptr procattrs;
Xint i,n;
Xstatic int imptype;
Xstatic int ininit =NO;
X
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern short yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 1009 "gram.in"
X
X
Xsetyydeb()
X{
X#ifdef YYDEBUG
X	extern int yydebug;
X	yydebug = 1;
X#endif
X}
Xshort yyexca[] ={
X-1, 0,
X	0, 1,
X	-2, 175,
X-1, 1,
X	0, -1,
X	-2, 0,
X-1, 80,
X	9, 152,
X	19, 152,
X	20, 152,
X	-2, 178,
X-1, 165,
X	19, 152,
X	20, 152,
X	-2, 179,
X-1, 262,
X	6, 191,
X	-2, 14,
X-1, 351,
X	14, 0,
X	-2, 144,
X	};
X# define YYNPROD 284
X# define YYLAST 1451
Xshort yyact[]={
X
X 225, 247, 408, 431, 412, 124, 409, 337, 223, 197,
X 157,  20, 258, 224, 185, 156,  19,   6, 140,   3,
X  20, 155,  61, 139, 286,  19,  59, 314,   5, 131,
X 297, 152, 212,  44, 182, 198,  37,  34,  36,  32,
X  33,  35,  21,  22,  16, 191,  14, 135,  38,  39,
X  40,  41,  26,  45,  27,  30,  31,  46,  47,  10,
X  12,  11,  72, 227, 121,  77,  64,  17,  20, 446,
X  66,  60, 413,  19, 179, 189, 425,  58, 195, 196,
X 338,  42, 149,  43, 141,  65,  80,  73, 109, 129,
X  78,  87,  71, 199, 400, 399, 170, 200, 172, 178,
X 167, 175, 176, 177, 154, 211, 233, 305, 120, 315,
X 203, 325, 218, 243, 326, 137,  62, 220, 218,  68,
X 447, 148, 147, 356,  74, 209, 222, 242, 199, 123,
X 204, 256, 200, 201, 202, 213, 229, 216, 215, 214,
X 217, 213,  68, 216, 215, 214, 217, 134,  62,  73,
X 169, 245, 165,  20, 164,  80, 166, 109,  19,  78,
X  87, 278,  76, 132, 260, 133, 273, 161, 201, 202,
X 144, 148, 147, 163, 382, 267, 250, 263, 160, 265,
X 271, 272, 273, 148, 147, 259, 433, 280, 394, 282,
X 148, 147, 228, 268, 269, 270, 239, 279,  69, 287,
X 272, 273, 289, 235, 250, 127, 295, 296, 298, 298,
X  58, 303, 240, 291, 292, 238, 262, 146, 128,  18,
X  65, 252, 251, 344, 343, 449, 307, 148, 147,  55,
X 310, 460, 429, 417, 253, 254, 434, 264, 283, 300,
X 293,  20, 329,  20, 304, 173,  19,  20,  19, 319,
X 322, 321,  19, 171, 372, 428, 316, 330, 429, 317,
X 327, 323, 281, 141, 392, 377,   7, 393, 378, 367,
X 342, 248, 348, 349, 350, 351, 352, 353, 354, 355,
X 335, 364, 143, 154, 365, 357, 360, 234, 339, 363,
X 462, 340, 333, 463, 287, 334, 277, 275, 276, 159,
X 274, 271, 272, 273, 274, 271, 272, 273, 373, 376,
X 255, 158, 375, 159, 380, 145, 302, 371, 366, 358,
X 361, 276, 301, 274, 271, 272, 273, 379, 418, 389,
X 423, 236, 396, 390, 420, 391, 237, 277, 275, 276,
X 414, 274, 271, 272, 273, 398, 134, 416, 331, 397,
X 415, 332, 451, 395, 277, 275, 276, 381, 274, 271,
X 272, 273, 369, 259, 312, 277, 275, 276, 410, 274,
X 271, 272, 273, 279, 445, 407, 279, 436, 465, 427,
X 250, 150, 419, 250, 277, 275, 276, 421, 274, 271,
X 272, 273, 125, 406,  20, 125, 403, 306, 285,  19,
X 284, 424, 422, 308,  74, 122, 277, 275, 276, 249,
X 274, 271, 272, 273, 219, 210, 207, 206, 435,  48,
X 205, 439, 437,  50, 438,  52,  53, 162, 442, 126,
X 410, 125, 441, 440, 444, 388, 443, 410, 448, 450,
X 387, 386, 385, 383, 347, 453, 456, 345, 457, 458,
X 150,  49, 414, 459,  51, 411, 142,   9, 461, 454,
X 188, 370, 186, 208, 464, 187, 107, 192,  68,  99,
X  44,  97, 180,  37,  34,  36,  32,  33,  35,  96,
X 426,  95, 266, 174,  88,  38,  39,  40,  41,  26,
X  45,  27,  30,  31,  46,  47, 455,  86,  84, 341,
X 168, 452, 277, 275, 276, 116, 274, 271, 272, 273,
X 277, 275, 276, 261, 274, 271, 272, 273,  42,  82,
X  43, 193, 194, 150, 113, 114, 111, 112, 195, 196,
X 384, 230, 328, 188, 221, 186, 226, 336, 187, 153,
X 192,  68, 241,  44,  70, 180,  37,  34,  36,  32,
X  33,  35, 151,  63, 136,  54,   8,  75,  38,  39,
X  40,  41,  26,  45,  27,  30,  31,  46,  47, 430,
X  13, 277, 275, 276, 404, 274, 271, 272, 273, 232,
X 277, 275, 276, 231, 274, 271, 272, 273,   4,   2,
X 102,  42, 432,  43, 193, 194, 110, 113, 114, 111,
X 112, 195, 196, 150, 181,  29,  23, 288,  25, 294,
X 299, 290, 346, 188,  85, 186,  15, 246, 187,  67,
X 192,  68, 184,  44, 183, 180,  37,  34,  36,  32,
X  33,  35,  28,  56, 309,  24, 318, 138,  38,  39,
X  40,  41,  26,  45,  27,  30,  31,  46,  47, 401,
X 130, 257, 320,   1,   0, 277, 275, 276,   0, 274,
X 271, 272, 273,   0,   0,   0,   0,   0,   0,   0,
X   0,  42,   0,  43, 193, 194,   0, 113, 114, 111,
X 112, 195, 196,   0, 150, 244,   0,   0,   0,   0,
X   0,   0,   0,   0, 188,   0, 186,   0,   0, 187,
X   0, 192,  68, 190,  44,   0, 180,  37,  34,  36,
X  32,  33,  35,   0,   0,   0,   0,   0,   0,  38,
X  39,  40,  41,  26,  45,  27,  30,  31,  46,  47,
X 374,   0,   0,   0,   0,   0, 277, 275, 276,   0,
X 274, 271, 272, 273,   0,   0,   0,   0,   0,   0,
X   0,   0,  42,   0,  43, 193, 194, 150, 113, 114,
X 111, 112, 195, 196,   0,   0,   0, 188,   0, 186,
X   0,   0, 187,   0, 192,  68, 190,  44,   0, 180,
X  37,  34,  36,  32,  33,  35,   0,   0,   0,   0,
X   0,   0,  38,  39,  40,  41,  26,  45,  27,  30,
X  31,  46,  47, 368,   0,   0,   0,   0,   0, 277,
X 275, 276,   0, 274, 271, 272, 273,   0,   0,   0,
X   0,   0,   0,   0,   0,  42,   0,  43, 193, 194,
X   0, 113, 114, 111, 112, 195, 196, 150,   0,   0,
X   0,   0,   0,   0,   0,   0,   0, 188,   0, 186,
X   0,   0, 187,   0, 192,  68, 190,  44,   0, 180,
X  37,  34,  36,  32,  33,  35,   0,   0,   0,   0,
X   0,   0,  38,  39,  40,  41, 362,  45,  27,  30,
X  31,  46,  47, 313,   0, 277, 275, 276, 311, 274,
X 271, 272, 273,   0, 277, 275, 276,   0, 274, 271,
X 272, 273,   0,   0,   0,  42,   0,  43, 193, 194,
X   0, 113, 114, 111, 112, 195, 196,   0, 150,   0,
X   0,   0,   0,   0,   0,   0,   0,   0, 188,   0,
X 186,   0,   0, 187,   0, 192,  68, 190,  44,   0,
X 180,  37,  34,  36,  32,  33,  35,   0,   0,   0,
X   0,   0,   0,  38,  39,  40,  41, 359,  45,  27,
X  30,  31,  46,  47,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,  42,   0,  43, 193,
X 194,   0, 113, 114, 111, 112, 195, 196,  44,   0,
X   0,  37,  34,  36,  32,  33,  35,   0,   0,   0,
X 190,  14,   0,  38,  39,  40,  41,  26,  45,  27,
X  30,  31,  46,  47,  10,  12,  11,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,  83,
X  57,   0,   0,   0,   0,   0,  42,   0,  43,   0,
X   0,   0,  79,   0,   0,  91,  62,   0,  44,  92,
X   0,  37,  34,  36,  32,  33,  35,  21,  22,   0,
X   0,   0,   0,  38,  39,  40,  41,  26,  45,  27,
X  30,  31,  46,  47,   0,   0,  90, 104,   0, 106,
X 190, 105, 116, 115, 108,  94,  93, 101, 100, 118,
X 119, 117,  98, 103,  81,   0,  42,   0,  43,   0,
X   0, 113, 114, 111, 112,   0,  62,  89,  44,   0,
X   0,  37,  34,  36,  32,  33,  35,   0,   0,   0,
X   0,   0,   0,  38,  39,  40,  41,  26,  45,  27,
X  30,  31,  46,  47,  10,  12,  11,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,  44,   0,   0,
X  37,  34,  36,  32,  33,  35,  42,   0,  43,   0,
X   0, 190,  38,  39,  40,  41,  26,  45,  27,  30,
X  31,  46,  47,  10,  12,  11,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0, 150, 405,   0,
X   0,   0,   0,   0,   0,  42,   0,  43,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,  44,   0,   0,
X  37,  34,  36,  32,  33,  35,   0,   0,   0,   0,
X   0, 324,  38,  39,  40,  41,  26,  45,  27,  30,
X  31,  46,  47,   0,   0,   0, 150, 402,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,  42,  44,  43,   0,  37,
X  34,  36,  32,  33,  35,   0,   0,   0,   0,   0,
X   0,  38,  39,  40,  41,  26,  45,  27,  30,  31,
X  46,  47,   0,   0,   0,   0,   0,  57,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,  62,  42,  44,  43,   0,  37,  34,
X  36,  32,  33,  35,   0,   0,   0,   0,   0,   0,
X  38,  39,  40,  41,  26,  45,  27,  30,  31,  46,
X  47,   0,   0,   0, 150,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,  42,  44,  43,   0,  37,  34,  36,
X  32,  33,  35,   0,   0,   0,   0,   0,   0,  38,
X  39,  40,  41,  26,  45,  27,  30,  31,  46,  47,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X  44,   0,   0,  37,  34,  36,  32,  33,  35,   0,
X   0,   0,  42,   0,  43,  38,  39,  40,  41,  26,
X  45,  27,  30,  31,  46,  47,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,  42,   0,
X  43 };
Xshort yypact[]={
X
X  10,-1000, 450, 450, 453, 450, 450,-1000,-1000,1035,
X  98,-1000, 121, 141,-1000,1034,-1000,-1000,-1000, 402,
X 402,-1000,-1000,-1000,-1000,-1000, 428, 426,-1000,-1000,
X-1000,-1000,-1000,-1000,-1000,-1000,-1000, 202,-1000,-1000,
X-1000,-1000,  17,-1000,-1000, 142,-1000,-1000,-1000,-1000,
X-1000,-1000,-1000,-1000,  93,-1000,-1000,1095,-1000, 275,
X-1000, 402,-1000, 308,-1000, 208,-1000, 378,-1000,1377,
X 304, 292,-1000, 171,  98, 424,-1000,-1000, 164,  98,
X-1000,  98,-1000,-1000,1034,-1000,-1000,-1000,-1000,-1000,
X-1000, 245,-1000, 237,-1000,-1000,-1000,-1000, 754,-1000,
X 107, 109, 417,-1000, 414,-1000, 413,-1000, 412,-1000,
X  80,-1000,-1000,-1000,-1000, 411, 754,-1000,-1000,-1000,
X-1000,-1000,-1000,-1000,-1000, 754, 520,-1000,-1000,-1000,
X-1000,-1000,-1000,-1000,-1000,  69, 280, 194, 330,-1000,
X-1000, 275,1292,  95, 187,  98,-1000, 106,  90,-1000,
X 681, 264,-1000, 406,1377,-1000,-1000, 402, 401,  98,
X  98, 306, 127, 754, 102,-1000, 102,-1000,-1000,-1000,
X-1000,-1000, 229,-1000, 754,-1000,-1000,-1000, 355, 152,
X-1000,-1000,1341,-1000,-1000,-1000, 754,  98, 754,-1000,
X-1000,-1000,  -3, 397, 395,-1000,-1000,-1000, 600,-1000,
X-1000, 754,-1000,  72, 107, 754, 754, 754, 754, 315,
X 754,  86,  82,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
X 396, 520, 884, 360,-1000, 875,-1000,  85,  85, 341,
X1134,-1000, 975,-1000,-1000,  89,1095,-1000,-1000,-1000,
X-1000, 754, 378,-1000,-1000, 344, 288,-1000,1377,   4,
X-1000,-1000,-1000, 102, 102,-1000,-1000, 284,-1000,-1000,
X 355,-1000,-1000,-1000,-1000,-1000, 216, 355, 446, 443,
X-1000, 754, 754, 754, 754, 754, 754, 754, 754,-1000,
X 149, 102, 290, 103, 915, 834,-1000, 355, 754, 355,
X 277,-1000,-1000, 600, 262, 355, 799, 358, 355,-1000,
X 247,-1000,-1000, 726,-1000,-1000,-1000,-1000, 754, 261,
X-1000,-1000,-1000, 520, 353,-1000, 158,-1000, 442,-1000,
X-1000, 441, 440, 439, 434,-1000,-1000,-1000, 754, 355,
X-1000,-1000, 754,-1000, 754,-1000, 260,-1000, 173,-1000,
X  95, 326,-1000,-1000, 754,  41,-1000,  38, 184, 149,
X 149, 165, 309, 290, 355, 355,-1000, 645,1243, 392,
X 570,1194, 389, 355,-1000,  72,-1000, 447,-1000,-1000,
X-1000, 346,-1000, 226,-1000,-1000, 327,-1000, 520,-1000,
X 355,-1000,-1000,1134, 324,-1000,-1000,-1000,-1000, 355,
X 355, 355,-1000,   4,   0,-1000,-1000,-1000, 355,-1000,
X 376,-1000,-1000,-1000,-1000,-1000,-1000,-1000, 251,-1000,
X 561,-1000, 228, 335,-1000,-1000,-1000,-1000,-1000,-1000,
X 754,-1000,-1000, 432,-1000,-1000,-1000, 754,-1000, 447,
X-1000,-1000, 371,  44,-1000, 217, 447, 348,-1000, 500,
X-1000,-1000, 492,-1000,-1000, 754,-1000,-1000,-1000,-1000,
X 225,-1000,-1000,-1000,-1000,-1000, 286,-1000,-1000,-1000,
X-1000,-1000,-1000, 754, 374,-1000 };
Xshort yypgo[]={
X
X   0, 653,  18, 652,  17,  47, 219, 651,  12,  22,
X  27, 650,  23, 637, 636,  34,  92, 456,  67, 635,
X 108,  64, 634,   8,  13, 633,  26,  71,  21,  15,
X 632,  29,   0,  74,  14,  75, 624, 622,  70, 619,
X 617, 616, 614, 612, 611,  35,  24,  72,  30, 610,
X 609,   2,   6,   4,   3, 608, 606, 605, 604,  45,
X 596,  32, 592, 590,   9, 589, 419, 588, 583,  28,
X 579, 570, 557, 556, 555, 554,   5, 553, 186, 552,
X   1, 544,  66, 542,  31, 539, 537,   7,  62,  10,
X 534, 532,  63, 531, 530,  65, 519, 513, 500, 499,
X 498, 497, 484, 483, 482, 481, 480, 479, 471, 469,
X 466, 463, 461, 377 };
Xshort yyr1[]={
X
X   0,   1,   1,   1,   1,   1,   1,   1,  66,   3,
X   3,   3,   3,   5,  70,   5,  67,  67,  67,  67,
X  72,  71,  71,   6,   6,   7,   7,   8,  65,  73,
X  74,  74,  74,  75,  75,  75,  69,  68,  76,  13,
X  13,  13,  12,  12,   2,   2,   2,   2,   2,   2,
X  14,  14,  14,  77,  77,  83,  82,  79,  79,  84,
X  84,  85,  86,  86,  87,  87,  81,  81,  88,  16,
X  16,  17,  17,  18,  18,  20,  20,  90,  21,  22,
X  22,  23,  23,  24,  24,  25,  25,  26,  26,  27,
X  91,  27,   9,  15,  15,  28,  28,  29,  29,  29,
X  29,  29,  29,  29,  56,  56,  56,  56,  56,  19,
X  19,  92,  10,  10,  55,  55,  55,  55,  55,  55,
X  30,  30,  30,  11,  11,  93,  94,  31,  89,  89,
X  57,  57,  32,  32,  32,  32,  32,  32,  32,  32,
X  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
X  32,  32,  33,  38,  38,  38,  38,  38,  39,  34,
X  34,  34,  40,  40,  36,  36,  36,  37,  37,  37,
X  58,  58,  59,  59,   4,  41,  95,  95,  95,  95,
X  95,  95,  95,  95,  95,  95,  95,  95, 102, 102,
X  98,  99, 100, 100, 100, 100, 103, 100, 104, 104,
X  42,  42,  42,  42, 105, 106, 107,  43,  43, 101,
X 101, 101, 101, 101, 101, 101,  45,  44,  44,  46,
X  46,  64,  64,  64,  64, 109, 109, 109, 109, 109,
X  60,  60,  60,  61,  61,  61,  61,  61,  61, 108,
X 108, 108, 108,  47,  47,  47,  47,  47,  47, 110,
X 111, 111,  49, 112, 112,  48,  48,  96,  97,  35,
X  63,  63,  63,  63,  50,  50,  51,  51,  52,  52,
X  52,  52,  52,  52,  52, 113,  53,  54,  54,  54,
X  54,  62,  78,  80 };
Xshort yyr2[]={
X
X   0,   0,   2,   2,   4,   2,   2,   1,   1,   2,
X   2,   2,   2,   0,   0,   3,   1,   2,   4,   5,
X   1,   1,   2,   1,   1,   1,   3,   1,   2,   1,
X   0,   2,   3,   1,   3,   3,   1,   1,   0,   1,
X   2,   3,   1,   1,   2,   4,   2,   4,   2,   2,
X   1,   2,   3,   1,   3,   0,   4,   1,   3,   1,
X   4,   1,   1,   3,   1,   3,   1,   3,   3,   3,
X   3,   1,   2,   2,   2,   0,   1,   0,   4,   1,
X   3,   1,   3,   1,   1,   0,   1,   1,   3,   2,
X   0,   5,   1,   1,   2,   1,   2,   1,   2,   1,
X   4,   4,   1,   1,   1,   1,   1,   1,   1,   5,
X   5,   0,   0,   1,   1,   1,   1,   1,   2,   1,
X   1,   4,   2,   1,   1,   0,   0,   6,   1,   1,
X   1,   1,   1,   1,   1,   2,   1,   1,   1,   3,
X   3,   3,   2,   2,   3,   3,   3,   2,   3,   3,
X   1,   1,   1,   1,   2,   3,   4,   3,   1,   2,
X   3,   3,   3,   3,   4,   4,   4,   4,   4,   4,
X   1,   3,   1,   1,   2,   0,   3,   2,   1,   2,
X   3,   5,   2,   1,   1,   1,   1,   1,   0,   1,
X   0,   0,   3,   2,   4,   3,   0,   5,   1,   3,
X   8,   4,   4,   3,   4,   0,   1,   1,   5,   1,
X   2,   1,   2,   3,   3,   4,   3,   1,   3,   1,
X   2,   1,   1,   2,   1,   1,   2,   2,   3,   3,
X   1,   1,   1,   1,   1,   1,   1,   1,   1,   4,
X   4,   4,   1,   4,   3,   6,   5,   8,   7,   2,
X   2,   4,   2,   2,   4,   0,   1,   2,   0,   6,
X   1,   1,   1,   1,   1,   0,   1,   3,   1,   3,
X   2,   1,   2,   4,   3,   0,   4,   1,   4,   6,
X   3,   3,   0,   0 };
Xshort yychk[]={
X
X-1000,  -1, -65,  -2, -67, -69,  -4, 256, -73, -17,
X  49,  51,  50, -71,  36, -41,  34, -18,  -6, -29,
X -89,  32,  33, -56, -19, -55,  42,  44, -30, -57,
X  45,  46,  29,  30,  27,  31,  28,  26,  38,  39,
X  40,  41,  71,  73,  23,  43,  47,  48, -66,   1,
X -66,   1, -66, -66, -74,  -6, -25,   5, -18, -26,
X -27,  -9,  21, -77, -82, -33, -38, -39,  21, -78,
X -81, -16, -88, -33,   3, -72,  21, -95, -33,  18,
X -38,  70, -96,   5,-100, -42,-101, -35,-102,  83,
X  52,  21,  25,  62,  61,-105,-107,-108,  68,-109,
X  64,  63, -63,  69,  53,  57,  55,-110,  60, -47,
X -60,  79,  80,  77,  78,  59,  58,  67,  65,  66,
X -20, -21,   3, -20, -76,   3,   3,   3,  16,  72,
X -11, -31,  21,  23,   5,  -5, -75,  22, -13, -12,
X  -2, -26, -17,   7, -20,   7,   9,  20,  19, -34,
X   3, -79, -84, -85, -15, -28, -29, -89,   7,   7,
X   7, -16,   3,   9, -33, -38, -33,  -4, -98, -95,
X -76,   8, -76,   8,-103, -76, -76, -76, -32, -33,
X  25, -58, -15, -36, -37, -34,  15,  18,  13, -35,
X 256, -59,  20,  74,  75,  81,  82, -64, -45,  21,
X  25,  61,  62,   3,  21,   3,   3,   3,-111,  -4,
X   3,  25, -61,  55,  59,  58,  57,  60,  32,   3,
X -32, -90, -32, -23, -24, -32,  16, -92, -92, -76,
X -93, -68, -70,  37,   7,   9,   1,   6, -27,   9,
X -82, -83,  21,  23,   4, -32, -40, -80,   7,   3,
X -28, -21, -88, -33, -33,   4,   4,  -7,  -8,  -9,
X -32, -97,  -5, -76,   8, -76,-104, -32,  -4,  -4,
X  -4,  15,  16,  17,  14,  11,  12,  10,   9, -34,
X -32, -33, -32, -59,   3,   3, -46, -32,   7, -32,
X -44, -64, -64, -45, -50, -32, -32, -48, -32, -49,
X -48,   7,   1, -32, -61,  25,   1, -76,   7, -22,
X -23,   4,   4,   8, -10,  24, -10, -31, -14,  -2,
X  -3,  -2,  -4, -69, 256,  22,  25, -12, -91, -32,
X -34,   4,   7,   4,   7, -84, -86, -87,  76,   4,
X   7, -99, -76,   8,   7,   1, -43,   1, -32, -32,
X -32, -32, -32, -32, -32, -32,  20, -32, -15,  42,
X -32, -15,  42, -32,   4,   7, -46,   7,   4,   4,
X-112,  -4,   7, -76,   4, -76, -32,   4,   7, -24,
X -32,   4,  16,   1, -94,   1,   1,   1,   1, -32,
X -32, -32,   4,   7,  15,  -8,   6, -76, -32,  54,
X  56,   4,   4,   4,   4,   4,   4, -64, -51, -52,
X -32,   8, -53, -47,   5,   4,   1,   7,   1, -76,
X   7, -23,  -2,   6, -87,  76,-106,   3,   4,   7,
X   8, -54, -62, -78,   8, -53,-113, -76, -76, -32,
X   1, -76, -32, -52, -54,   3,  25,  76, -54,   8,
X -51,   4,   1, -76,  -4,   4, -32, -80, -80, -54,
X   6, -76,   4,   7, -32,   4 };
Xshort yydef[]={
X
X  -2,  -2,   0,   0,   0,   0,   0,   7,  30,  85,
X   0, 282,   0,  16,  36, 188,  29,  71,  21,  75,
X  75,  23,  24,  97,  38,  99,   0,   0, 102, 103,
X 128, 129, 104, 105, 106, 107, 108,   0, 114, 115,
X 116, 117,   0, 119, 120,   0, 130, 131,   2,   8,
X   3,  13,   5,   6,  28,  22,  44,   0,  72,  86,
X  87,  75,  92,  46,  53,   0, 152, 153, 158,   0,
X  48,  49,  66,   0,   0,  17,  20, 174,   0,   0,
X  -2,   0, 175, 190, 188, 183, 184, 185, 186, 187,
X  38, 158,  38,   0, 196,  38,  38,  38, 209, 211,
X   0,   0,   0, 189,   0, 206,   0, 175,   0, 242,
X 225, 260, 261, 262, 263,   0,   0, 230, 231, 232,
X  73,  76,  77,  74,  98,   0,   0, 111, 111, 118,
X  38, 122, 123, 124, 125,  14,  31,  33,   0,  39,
X  42,  43,  85,   0,  89,   0,  55,   0,   0, 154,
X   0, 283,  57,  59,  61,  93,  95,   0,   0,   0,
X   0,   0,   0,   0, 177,  -2,   0, 258,  13, 182,
X 257,  38, 193,  38,   0, 175, 175, 175, 210, 132,
X 133, 134,   0, 136, 137, 138,   0,   0,   0, 150,
X 151, 170,   0,   0,   0, 172, 173, 212,   0, 221,
X 222,   0, 224,   0,   0, 265,   0, 255, 255,   0,
X   0, 226, 227, 233, 234, 235, 236, 237, 238, 249,
X  38,   0,   0,   0,  81,  83,  84, 112, 112,   0,
X   0,   4, 175,  37,  32,   0,  40,  45,  88,  90,
X  54,   0, 155, 157, 159,   0,   0,  47,   0,   0,
X  94,  96,  67,  70,  69,  68,  18,   0,  25,  27,
X 176, 180,  -2, 192,  38, 195,   0, 198,   0,   0,
X 203,   0,   0,   0,   0,   0,   0,   0,   0, 135,
X 142, 143, 147,   0,   0,   0, 214, 219,   0, 223,
X   0, 217, 213,   0,   0, 264,   0,   0, 256, 175,
X   0, 250,  38,   0, 228, 229,  38, 244,   0,   0,
X  79, 100, 101,   0,   0, 113,   0, 121, 126,  50,
X  15,   0,   0,   0,   0,  34,  35,  41,   0,  56,
X 156, 160,   0, 161,   0,  58,   0,  62,  64,  19,
X   0,   0, 194,  38,   0, 201, 202, 207, 139, 140,
X 141,  -2, 145, 146, 149, 148, 171,   0,   0,   0,
X   0,   0,   0, 220, 216,   0, 215,   0, 204, 239,
X 240,   0, 252,   0, 241, 243,  38,  78,   0,  82,
X  83, 109, 110,  51,   0,   9,  10,  11,  12,  91,
X 162, 163,  60,   0,   0,  26, 181, 197, 199, 205,
X   0, 164, 165, 166, 167, 168, 169, 218,   0, 266,
X 268, 282, 271,   0, 275, 253,  38, 251,  38, 246,
X   0,  80,  52,   0,  63,  65,  38,   0, 259,   0,
X 282, 270, 277,   0, 282, 272,   0,   0, 245,  38,
X 127, 175,   0, 267, 269,   0, 283, 283, 274, 282,
X   0, 254,  38, 248, 200, 208,   0, 280, 281, 273,
X 276, 247, 278,   0,   0, 279 };
X#ifndef lint
Xstatic char yaccpar_sccsid[] = "@(#)yaccpar	4.1	(Berkeley)	2/11/83";
X#endif not lint
X
X#
X# define YYFLAG -1000
X# define YYERROR goto yyerrlab
X# define YYACCEPT return(0)
X# define YYABORT return(1)
X
X/*	parser for yacc output	*/
X
X#ifdef YYDEBUG
Xint yydebug = 0; /* 1 for debugging */
X#endif
XYYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
Xint yychar = -1; /* current input token number */
Xint yynerrs = 0;  /* number of errors */
Xshort yyerrflag = 0;  /* error recovery flag */
X
Xyyparse() {
X
X	short yys[YYMAXDEPTH];
X	short yyj, yym;
X	register YYSTYPE *yypvt;
X	register short yystate, *yyps, yyn;
X	register YYSTYPE *yypv;
X	register short *yyxi;
X
X	yystate = 0;
X	yychar = -1;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yyps= &yys[-1];
X	yypv= &yyv[-1];
X
X yystack:    /* put a state and value onto the stack */
X
X#ifdef YYDEBUG
X	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );
X#endif
X		if( ++yyps> &yys[YYMAXDEPTH] ) { yyerror( "yacc stack overflow" ); return(1); }
X		*yyps = yystate;
X		++yypv;
X		*yypv = yyval;
X
X yynewstate:
X
X	yyn = yypact[yystate];
X
X	if( yyn<= YYFLAG ) goto yydefault; /* simple state */
X
X	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
X	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;
X
X	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
X		yychar = -1;
X		yyval = yylval;
X		yystate = yyn;
X		if( yyerrflag > 0 ) --yyerrflag;
X		goto yystack;
X		}
X
X yydefault:
X	/* default state action */
X
X	if( (yyn=yydef[yystate]) == -2 ) {
X		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
X		/* look through exception table */
X
X		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */
X
X		while( *(yyxi+=2) >= 0 ){
X			if( *yyxi == yychar ) break;
X			}
X		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
X		}
X
X	if( yyn == 0 ){ /* error */
X		/* error ... attempt to resume parsing */
X
X		switch( yyerrflag ){
X
X		case 0:   /* brand new error */
X
X			yyerror( "syntax error" );
X		yyerrlab:
X			++yynerrs;
X
X		case 1:
X		case 2: /* incompletely recovered error ... try again */
X
X			yyerrflag = 3;
X
X			/* find a state where "error" is a legal shift action */
X
X			while ( yyps >= yys ) {
X			   yyn = yypact[*yyps] + YYERRCODE;
X			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
X			      yystate = yyact[yyn];  /* simulate a shift of "error" */
X			      goto yystack;
X			      }
X			   yyn = yypact[*yyps];
X
X			   /* the current yyps has no shift onn "error", pop stack */
X
X#ifdef YYDEBUG
X			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
X#endif
X			   --yyps;
X			   --yypv;
X			   }
X
X			/* there is no state on the stack with an error shift ... abort */
X
X	yyabort:
X			return(1);
X
X
X		case 3:  /* no shift yet; clobber input char */
X
X#ifdef YYDEBUG
X			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
X#endif
X
X			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
X			yychar = -1;
X			goto yynewstate;   /* try again in the same state */
X
X			}
X
X		}
X
X	/* reduction by production yyn */
X
X#ifdef YYDEBUG
X		if( yydebug ) printf("reduce %d\n",yyn);
X#endif
X		yyps -= yyr2[yyn];
X		yypvt = yypv;
X		yypv -= yyr2[yyn];
X		yyval = yypv[1];
X		yym=yyn;
X			/* consult goto table to find next state */
X		yyn = yyr1[yyn];
X		yyj = yypgo[yyn] + *yyps + 1;
X		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
X		switch(yym){
X			
Xcase 1:
X# line 138 "gram.in"
X{ graal = PARSEOF; } break;
Xcase 2:
X# line 140 "gram.in"
X{ graal = PARSOPT; } break;
Xcase 3:
X# line 142 "gram.in"
X{ graal = PARSDCL; doinits(yypvt[-1].pval);  frchain( & yypvt[-1].pval); } break;
Xcase 4:
X# line 144 "gram.in"
X{ endproc(); graal = PARSPROC; } break;
Xcase 5:
X# line 146 "gram.in"
X{ graal = PARSDEF; } break;
Xcase 6:
X# line 148 "gram.in"
X{ graal = PARSERR; } break;
Xcase 7:
X# line 150 "gram.in"
X{ graal = PARSERR;
X		  errmess("Syntax error", "", "");
X		} break;
Xcase 8:
X# line 155 "gram.in"
X{ eofneed = 1; } break;
Xcase 9:
X# line 158 "gram.in"
X{ if(!dclsect)
X			warn("declaration amid executables");
X		    yyval.pval = bgnexec();
X		   TEST fprintf(diagfile,"stat: dcl\n");
X		  doinits(yypvt[-1].pval); frchain( & yypvt[-1].pval); } break;
Xcase 10:
X# line 164 "gram.in"
X{ if(dclsect && yypvt[-1].pval->tag!=TSTFUNCT)
X			dclsect = 0;
X		    TEST fprintf(diagfile, "stat: exec\n"); } break;
Xcase 11:
X# line 168 "gram.in"
X{ yyval.pval = bgnexec(); } break;
Xcase 12:
X# line 170 "gram.in"
X{ yyerrok;
X		  errmess("Syntax error", "", "");
X		  yyval.pval = bgnexec();
X		} break;
Xcase 13:
X# line 177 "gram.in"
X{ yyval.pval = bgnexec(); } break;
Xcase 14:
X# line 178 "gram.in"
X{ thisexec->copylab = 1; } break;
Xcase 15:
X# line 179 "gram.in"
X{ yyval.pval = addexec(); thisexec->copylab = 0; } break;
Xcase 16:
X# line 183 "gram.in"
X{ procname = 0; thisargs = 0;
X		  if(procclass == 0) procclass = PRMAIN;
X		  goto proctype;
X		} break;
Xcase 17:
X# line 188 "gram.in"
X{ thisargs = 0; goto proctype; } break;
Xcase 18:
X# line 190 "gram.in"
X{ thisargs = 0; goto proctype; } break;
Xcase 19:
X# line 192 "gram.in"
X{ thisargs = yypvt[-1].pval;
X	proctype:
X		if(procattrs)
X			if(procname == 0)
X				dclerr("attributes on unnamed procedure", "");
X			else	{
X				attvars(procattrs, mkchain(procname,CHNULL));
X				procclass = PRFUNCT;
X				}
X		fprintf(diagfile, "Procedure %s:\n", procnm() );
X		if(verbose)
X			fprintf(diagfile, "    Pass 1\n");
X		} break;
Xcase 20:
X# line 208 "gram.in"
X{ procname = mkvar(yypvt[-0].pval);
X		  extname(procname);
X		} break;
Xcase 21:
X# line 214 "gram.in"
X{ procattrs = 0; } break;
Xcase 22:
X# line 216 "gram.in"
X{ procattrs = yypvt[-1].pval;
X		  if(procclass == 0) procclass = PRFUNCT;
X		} break;
Xcase 23:
X# line 222 "gram.in"
X{ yyval.pval = bgnproc(); procclass = 0; } break;
Xcase 24:
X# line 224 "gram.in"
X{ yyval.pval = bgnproc(); procclass = PRBLOCK; } break;
Xcase 25:
X# line 228 "gram.in"
X{ yyval.pval = mkchain(yypvt[-0].pval,CHNULL); } break;
Xcase 26:
X# line 230 "gram.in"
X{ hookup(yypvt[-2].pval, mkchain(yypvt[-0].pval,CHNULL) ); } break;
Xcase 27:
X# line 234 "gram.in"
X{ if(yypvt[-0].pval->vclass == CLUNDEFINED)
X			yypvt[-0].pval->vclass = CLARG;
X		  else dclerr("argument already used", yypvt[-0].pval->sthead->namep);
X		} break;
Xcase 28:
X# line 240 "gram.in"
X{ optneed = 0; } break;
Xcase 29:
X# line 244 "gram.in"
X{ if(blklevel > 0)
X			{
X			execerr("Option statement inside procedure", "");
X			execerr("procedure %s terminated prematurely", procnm());
X			endproc();
X			}
X		  optneed = 1;
X		  } break;
Xcase 33:
X# line 260 "gram.in"
X{ setopt(yypvt[-0].pval,CNULL); cfree(yypvt[-0].pval); } break;
Xcase 34:
X# line 262 "gram.in"
X{ setopt(yypvt[-2].pval,yypvt[-0].pval); cfree(yypvt[-2].pval); cfree(yypvt[-0].pval); } break;
Xcase 35:
X# line 264 "gram.in"
X{ setopt(yypvt[-2].pval,yypvt[-0].pval->leftp); cfree(yypvt[-2].pval); cfree(yypvt[-0].pval); } break;
Xcase 36:
X# line 268 "gram.in"
X{ defneed = 1; } break;
Xcase 37:
X# line 272 "gram.in"
X{ if(thisctl->subtype != STPROC)
X			execerr("control stack not empty upon END", "");
X		  exnull();
X		  popctl();
X		} break;
Xcase 38:
X# line 280 "gram.in"
X{ igeol=1; /* continue past newlines  */ } break;
Xcase 41:
X# line 285 "gram.in"
X{ yyval.pval = hookup(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 44:
X# line 293 "gram.in"
X{ attvars(yypvt[-1].pval,yypvt[-0].pval); yyval.pval = yypvt[-0].pval; } break;
Xcase 45:
X# line 295 "gram.in"
X{ attvars(yypvt[-3].pval,yypvt[-1].pval); yyval.pval = yypvt[-1].pval; } break;
Xcase 46:
X# line 297 "gram.in"
X{ yyval.pval = 0; } break;
Xcase 47:
X# line 299 "gram.in"
X{ yyval.pval = 0; } break;
Xcase 48:
X# line 301 "gram.in"
X{ yyval.pval = 0; } break;
Xcase 49:
X# line 303 "gram.in"
X{ mkequiv(yypvt[-0].pval); yyval.pval = 0; } break;
Xcase 52:
X# line 309 "gram.in"
X{ yyval.pval = hookup(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 55:
X# line 316 "gram.in"
X{ininit = YES; } break;
Xcase 56:
X# line 317 "gram.in"
X { ininit = NO;  mkinit(yypvt[-3].pval,yypvt[-0].pval);  frexpr(yypvt[-3].pval); } break;
Xcase 59:
X# line 325 "gram.in"
X{ setimpl(imptype, 'a', 'z'); } break;
Xcase 61:
X# line 330 "gram.in"
X{ imptype = yypvt[-0].pval->attype; cfree(yypvt[-0].pval); } break;
Xcase 64:
X# line 338 "gram.in"
X{ setimpl(imptype, yypvt[-0].ival, yypvt[-0].ival); } break;
Xcase 65:
X# line 340 "gram.in"
X{ setimpl(imptype, yypvt[-2].ival, yypvt[-0].ival); } break;
Xcase 68:
X# line 348 "gram.in"
X{ mkequiv(yypvt[-1].pval); } break;
Xcase 69:
X# line 352 "gram.in"
X{ yyval.pval = mkchain(yypvt[-2].pval, mkchain(yypvt[-0].pval,CHNULL)); } break;
Xcase 70:
X# line 354 "gram.in"
X{ yyval.pval = hookup(yypvt[-2].pval, mkchain(yypvt[-0].pval,CHNULL)); } break;
Xcase 72:
X# line 358 "gram.in"
X{ attatt(yypvt[-1].pval,yypvt[-0].pval); } break;
Xcase 73:
X# line 361 "gram.in"
X{ yypvt[-1].pval->atdim = yypvt[-0].pval; } break;
Xcase 74:
X# line 362 "gram.in"
X{ yyval.pval = ALLOC(atblock); yyval.pval->atdim = yypvt[-0].pval; } break;
Xcase 75:
X# line 365 "gram.in"
X{ yyval.pval = 0; } break;
Xcase 77:
X# line 369 "gram.in"
X{ inbound = 1; } break;
Xcase 78:
X# line 370 "gram.in"
X{ inbound = 0;  yyval.pval = arrays = mkchain(yypvt[-1].pval,arrays); } break;
Xcase 80:
X# line 374 "gram.in"
X{ hookup(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 81:
X# line 378 "gram.in"
X{
X		yyval.pval = ALLOC(dimblock);
X		yyval.pval->lowerb = 0;
X		yyval.pval->upperb = yypvt[-0].pval;
X		} break;
Xcase 82:
X# line 384 "gram.in"
X{
X		yyval.pval = ALLOC(dimblock);
X		yyval.pval->lowerb = yypvt[-2].pval;
X		yyval.pval->upperb = yypvt[-0].pval;
X		} break;
Xcase 84:
X# line 392 "gram.in"
X{ yyval.pval = 0; } break;
Xcase 85:
X# line 395 "gram.in"
X{ yyval.pval = 0; } break;
Xcase 88:
X# line 400 "gram.in"
X{ hookup(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 89:
X# line 404 "gram.in"
X{
X		if(yypvt[-0].pval!=0)
X			if(yypvt[-1].pval->vdim==0)
X				yypvt[-1].pval->vdim = yypvt[-0].pval;
X			else if(!eqdim(yypvt[-0].pval,yypvt[-1].pval->vdim))
X				dclerr("multiple dimension", yypvt[-1].pval->namep);
X		yyval.pval = mkchain(yypvt[-1].pval,CHNULL);
X		} break;
Xcase 90:
X# line 412 "gram.in"
X{ ininit = YES; } break;
Xcase 91:
X# line 413 "gram.in"
X{
X		ininit = NO;
X		if(yypvt[-2].ival!=OPASGN)
X			dclerr("illegal initialization operator", yypvt[-4].pval->sthead->namep);
X		if(yypvt[-3].pval!=0)
X			if(yypvt[-4].pval->vdim==0)
X				yypvt[-4].pval->vdim = yypvt[-3].pval;
X			else if(!eqdim(yypvt[-3].pval,yypvt[-4].pval->vdim))
X				dclerr("multiple dimension", yypvt[-4].pval->sthead->namep);
X		if(yypvt[-0].pval!=0 && yypvt[-4].pval->vinit!=0)
X			dclerr("multiple initialization", yypvt[-4].pval->sthead->namep);
X		yypvt[-4].pval->vinit = yypvt[-0].pval;
X		yyval.pval = mkchain(yypvt[-4].pval,CHNULL);
X		} break;
Xcase 92:
X# line 430 "gram.in"
X{ yyval.pval = mkvar(yypvt[-0].pval); } break;
Xcase 94:
X# line 435 "gram.in"
X{ attatt(yypvt[-1].pval,yypvt[-0].pval); } break;
Xcase 96:
X# line 440 "gram.in"
X{ yyval.pval = ALLOC(atblock); yyval.pval->atdim = yypvt[-0].pval; } break;
Xcase 97:
X# line 444 "gram.in"
X{
X		yyval.pval = ALLOC(atblock);
X		if(yypvt[-0].ival == CLEXT)
X			yyval.pval->atext = 1;
X		yyval.pval->atclass = yypvt[-0].ival;
X		} break;
Xcase 98:
X# line 451 "gram.in"
X{
X		yyval.pval = ALLOC(atblock);
X		yyval.pval->atclass = CLCOMMON;
X		yyval.pval->atcommon = yypvt[-1].pval;
X		} break;
Xcase 99:
X# line 457 "gram.in"
X{ yyval.pval = ALLOC(atblock); yyval.pval->attype = yypvt[-0].ival; } break;
Xcase 100:
X# line 459 "gram.in"
X{ yyval.pval = ALLOC(atblock); yyval.pval->attype = TYCHAR; yyval.pval->attypep = yypvt[-1].pval; } break;
Xcase 101:
X# line 461 "gram.in"
X{ yyval.pval = ALLOC(atblock); yyval.pval->attype = TYFIELD;
X		  yyval.pval->attypep = mkfield(yypvt[-1].pval); } break;
Xcase 102:
X# line 464 "gram.in"
X{ yyval.pval = ALLOC(atblock); yyval.pval->attype = TYSTRUCT;
X		  yyval.pval->attypep = yypvt[-0].pval; } break;
Xcase 103:
X# line 467 "gram.in"
X{ yyval.pval = ALLOC(atblock); yyval.pval->atprec = yypvt[-0].ival; } break;
Xcase 104:
X# line 470 "gram.in"
X{ yyval.ival = CLAUTO;
X			  fprintf(diagfile,"AUTOMATIC not yet implemented\n"); } break;
Xcase 105:
X# line 472 "gram.in"
X{ yyval.ival = CLSTAT; } break;
Xcase 106:
X# line 473 "gram.in"
X{ yyval.ival = CLSTAT; } break;
Xcase 107:
X# line 474 "gram.in"
X{ yyval.ival = CLVALUE;
X			  fprintf(diagfile, "VALUE not yet implemented\n");  } break;
Xcase 108:
X# line 476 "gram.in"
X{ yyval.ival = CLEXT; } break;
Xcase 109:
X# line 480 "gram.in"
X{ yyval.pval = yypvt[-1].pval; } break;
Xcase 110:
X# line 482 "gram.in"
X{ yyval.pval = yypvt[-1].pval; } break;
Xcase 111:
X# line 485 "gram.in"
X{ comneed = 1; } break;
Xcase 112:
X# line 488 "gram.in"
X{ yyval.pval = mkcomm(""); } break;
Xcase 114:
X# line 492 "gram.in"
X{ yyval.ival = TYINT; } break;
Xcase 115:
X# line 493 "gram.in"
X{ yyval.ival = TYREAL; } break;
Xcase 116:
X# line 494 "gram.in"
X{ yyval.ival = TYCOMPLEX; } break;
Xcase 117:
X# line 495 "gram.in"
X{ yyval.ival = TYLOG; } break;
Xcase 118:
X# line 497 "gram.in"
X{ yyval.ival = TYLREAL; /* holdover from Fortran */ } break;
Xcase 119:
X# line 499 "gram.in"
X{ yyval.ival = TYLREAL; /* holdover from Fortran */ } break;
Xcase 120:
X# line 503 "gram.in"
X{ yyval.pval = yypvt[-0].pval->varp; } break;
Xcase 121:
X# line 505 "gram.in"
X{ yyval.pval = mkstruct(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 122:
X# line 507 "gram.in"
X{ yyval.pval = mkstruct(PNULL,yypvt[-0].pval); } break;
Xcase 123:
X# line 511 "gram.in"
X{ if(yypvt[-0].pval->varp && yypvt[-0].pval->varp->blklevel<blklevel)
X			hide(yypvt[-0].pval);
X		  yypvt[-0].pval->tag = TSTRUCT;
X		} break;
Xcase 124:
X# line 516 "gram.in"
X{ if(yypvt[-0].pval->varp)
X			if(yypvt[-0].pval->varp->blklevel<blklevel)
X				hide(yypvt[-0].pval);
X			else dclerr("multiple declaration for type %s", yypvt[-0].pval->namep);
X		} break;
Xcase 125:
X# line 523 "gram.in"
X{ ++instruct; } break;
Xcase 126:
X# line 523 "gram.in"
X{ --instruct; } break;
Xcase 127:
X# line 524 "gram.in"
X{ yyval.pval = yypvt[-3].pval; prevv = -1; } break;
Xcase 130:
X# line 531 "gram.in"
X{ yyval.ival = 1; } break;
Xcase 131:
X# line 532 "gram.in"
X{ yyval.ival = 0; } break;
Xcase 132:
X# line 535 "gram.in"
X{ if(yypvt[-0].pval->tag == TCALL)
X			yypvt[-0].pval = funcinv(yypvt[-0].pval);
X		  if(yypvt[-0].pval->vtype==TYUNDEFINED && yypvt[-0].pval->vext==0)
X			impldecl(yypvt[-0].pval);
X		  else if(yypvt[-0].pval->tag==TNAME && yypvt[-0].pval->vdcldone==0
X			  && yypvt[-0].pval->vext==0 && !inbound)
X				dclit(yypvt[-0].pval);
X		  if(yypvt[-0].pval->vtype==TYFIELD)
X			yyval.pval = extrfield(yypvt[-0].pval);
X		} break;
Xcase 134:
X# line 547 "gram.in"
X{ yyval.pval = mkconst(TYLOG, (yypvt[-0].ival == TRUE ? ".true." : ".false.") ); } break;
Xcase 135:
X# line 549 "gram.in"
X{ yyval.pval = typexpr(yypvt[-1].pval,yypvt[-0].pval); } break;
Xcase 138:
X# line 553 "gram.in"
X{ if( !ininit && yypvt[-0].pval->tag== TLIST)
X			yyval.pval = compconst(yypvt[-0].pval); 
X		  else yypvt[-0].pval->needpar = 1; } break;
Xcase 139:
X# line 557 "gram.in"
X{ yyval.pval = mknode(TAROP,yypvt[-1].ival,yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 140:
X# line 559 "gram.in"
X{ yyval.pval = mknode(TAROP,yypvt[-1].ival,yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 141:
X# line 561 "gram.in"
X{ yyval.pval = mknode(TAROP,yypvt[-1].ival,yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 142:
X# line 563 "gram.in"
X{ if(yypvt[-1].ival==OPMINUS)
X			yyval.pval = mknode(TNEGOP,OPMINUS, yypvt[-0].pval, PNULL);
X		  else	yyval.pval = yypvt[-0].pval;  } break;
Xcase 143:
X# line 567 "gram.in"
X{ yyval.pval =  mknode(TASGNOP,yypvt[-1].ival,yypvt[-0].pval,mkint(1)); } break;
Xcase 144:
X# line 569 "gram.in"
X{ yyval.pval = mknode(TRELOP,yypvt[-1].ival,yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 145:
X# line 571 "gram.in"
X{ yyval.pval = mknode(TLOGOP,yypvt[-1].ival,yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 146:
X# line 573 "gram.in"
X{ yyval.pval = mknode(TLOGOP,yypvt[-1].ival,yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 147:
X# line 575 "gram.in"
X{ yyval.pval = mknode(TNOTOP,yypvt[-1].ival,yypvt[-0].pval,PNULL); } break;
Xcase 148:
X# line 577 "gram.in"
X{ if(yypvt[-2].pval->tag == TCALL)
X			{
X			exprerr("may not assign to a function", CNULL);
X			yyval.pval = errnode();
X			}
X		  else
X			yyval.pval = mknode(TASGNOP,yypvt[-1].ival,yypvt[-2].pval,yypvt[-0].pval);
X		} break;
Xcase 149:
X# line 586 "gram.in"
X{ yyval.pval = mknode(TREPOP,0,yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 151:
X# line 589 "gram.in"
X{ yyval.pval = errnode(); } break;
Xcase 152:
X# line 593 "gram.in"
X{ if(yypvt[-0].pval->tag==TNAME && yypvt[-0].pval->vdcldone==0 &&
X			yypvt[-0].pval->vsubs==0 && yypvt[-0].pval->vext==0 && !inbound)
X				dclit(yypvt[-0].pval);
X		} break;
Xcase 154:
X# line 601 "gram.in"
X{
X		if(yypvt[-0].pval->tag!=TLIST)
X			yypvt[-0].pval = mknode(TLIST,0, mkchain(yypvt[-0].pval,CHNULL), PNULL);
X		if(yypvt[-1].pval->vdim)
X			{
X			if(yypvt[-1].pval->vdcldone==0 && yypvt[-1].pval->vext==0)
X				dclit(yypvt[-1].pval);
X			yyval.pval = subscript(yypvt[-1].pval,yypvt[-0].pval);
X			}
X		else	yyval.pval = mkcall(yypvt[-1].pval,yypvt[-0].pval);
X		} break;
Xcase 155:
X# line 613 "gram.in"
X{ yyval.pval = strucelt(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 156:
X# line 615 "gram.in"
X{ if(yypvt[-0].pval->tag != TLIST)
X			yypvt[-0].pval = mknode(TLIST,0, mkchain(yypvt[-0].pval,CHNULL), PNULL);
X		  yyval.pval = subscript(strucelt(yypvt[-3].pval,yypvt[-1].pval), yypvt[-0].pval);
X		} break;
Xcase 157:
X# line 620 "gram.in"
X{ yyval.pval = mkarrow(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 158:
X# line 624 "gram.in"
X{ if(yypvt[-0].pval->varp == 0) mkvar(yypvt[-0].pval);
X		  if(inbound)
X			  yypvt[-0].pval->varp->vadjdim = 1;
X		  yyval.pval = cpexpr(yypvt[-0].pval->varp); } break;
Xcase 159:
X# line 631 "gram.in"
X{ yyval.pval = mknode(TLIST, 0, PNULL, PNULL); } break;
Xcase 160:
X# line 633 "gram.in"
X{ yyval.pval = yypvt[-1].pval; } break;
Xcase 161:
X# line 635 "gram.in"
X{ yyval.pval = mknode(TLIST,0,yypvt[-1].pval,PNULL); } break;
Xcase 162:
X# line 639 "gram.in"
X{ yyval.pval = mkchain(yypvt[-2].pval, mkchain(yypvt[-0].pval, CHNULL) ); } break;
Xcase 163:
X# line 641 "gram.in"
X{ hookup(yypvt[-2].pval, mkchain(yypvt[-0].pval,CHNULL) ); } break;
Xcase 164:
X# line 645 "gram.in"
X{ yyval.pval = esizeof(yypvt[-1].pval->vtype, yypvt[-1].pval->vtypep, yypvt[-1].pval->vdim);
X		  frexpr(yypvt[-1].pval); } break;
Xcase 165:
X# line 648 "gram.in"
X{ if(yypvt[-1].pval->attype==TYREAL && yypvt[-1].pval->atprec)
X			yypvt[-1].pval->attype = TYLREAL;
X		  yyval.pval = esizeof(yypvt[-1].pval->attype, yypvt[-1].pval->attypep, yypvt[-1].pval->atdim);
X		  cfree(yypvt[-1].pval);
X		} break;
Xcase 166:
X# line 654 "gram.in"
X{ yyval.pval = mkint(tailor.ftnsize[FTNINT]/tailor.ftnchwd); } break;
Xcase 167:
X# line 658 "gram.in"
X{ yyval.pval = elenof(yypvt[-1].pval->vtype, yypvt[-1].pval->vtypep, yypvt[-1].pval->vdim);
X		  frexpr(yypvt[-1].pval); } break;
Xcase 168:
X# line 661 "gram.in"
X{ yyval.pval = elenof(yypvt[-1].pval->attype, yypvt[-1].pval->attypep, yypvt[-1].pval->atdim);
X		  cfree(yypvt[-1].pval);
X		} break;
Xcase 169:
X# line 665 "gram.in"
X{ yyval.pval = mkint(1); } break;
Xcase 171:
X# line 670 "gram.in"
X{ yyval.ival = yypvt[-1].ival; } break;
Xcase 174:
X# line 677 "gram.in"
X{ TEST fprintf(diagfile, "exec done\n"); } break;
Xcase 175:
X# line 681 "gram.in"
X{ yyval.pval = bgnexec();  if(ncases > 0) ncases = 0; } break;
Xcase 176:
X# line 685 "gram.in"
X{
X		if(yypvt[-2].pval->tag==TCALL)
X			{
X			dclerr("no statement functions in EFL",
X				yypvt[-2].pval->sthead->namep);
X			frexpr(yypvt[-2].pval);
X			frexpr(yypvt[-0].pval);
X			}
X		else exasgn(yypvt[-2].pval,yypvt[-1].ival,yypvt[-0].pval);
X		} break;
Xcase 177:
X# line 696 "gram.in"
X{ exasgn(yypvt[-0].pval, yypvt[-1].ival, mkint(1) ); } break;
Xcase 178:
X# line 698 "gram.in"
X{ excall(yypvt[-0].pval); } break;
Xcase 179:
X# line 700 "gram.in"
X{ excall(yypvt[-0].pval); } break;
Xcase 181:
X# line 703 "gram.in"
X{ TEST fprintf(diagfile, "exec: { stats }\n");
X		  addexec(); } break;
Xcase 182:
X# line 706 "gram.in"
X{ thisexec->labeled = 1; } break;
Xcase 183:
X# line 708 "gram.in"
X{ thisexec->uniffable = 1;  popctl(); } break;
Xcase 184:
X# line 710 "gram.in"
X{ thisexec->brnchend = 1; } break;
Xcase 185:
X# line 712 "gram.in"
X{ exio(yypvt[-0].pval, 0); } break;
Xcase 186:
X# line 714 "gram.in"
X{ exnull(); } break;
Xcase 187:
X# line 716 "gram.in"
X{
X		exnull();
X		putsii(ICCOMMENT, yypvt[-0].pval);
X		cfree(yypvt[-0].pval);
X		exnull();
X		} break;
Xcase 188:
X# line 725 "gram.in"
X{ TEST fprintf(diagfile, "exec:empty\n"); } break;
Xcase 189:
X# line 727 "gram.in"
X{ TEST fprintf(diagfile, "exec: continue\n"); } break;
Xcase 190:
X# line 731 "gram.in"
X{
X		thisexec->copylab = 1;
X		++blklevel;
X		dclsect = 1;
X		ndecl[blklevel] = 0;
X		nhid [blklevel] = 0;
X		} break;
Xcase 191:
X# line 741 "gram.in"
X{
X		if(ndecl[blklevel]) unhide();
X		--blklevel;
X		dclsect = 0;
X		} break;
Xcase 192:
X# line 749 "gram.in"
X{ mklabel(yypvt[-2].pval,YES); } break;
Xcase 193:
X# line 751 "gram.in"
X{ mklabel(mkilab(yypvt[-1].pval),YES); } break;
Xcase 194:
X# line 753 "gram.in"
X{ mklabel(mkilab(yypvt[-3].pval),YES); } break;
Xcase 195:
X# line 755 "gram.in"
X{ brkcase(); mkcase(PNULL,1); } break;
Xcase 196:
X# line 756 "gram.in"
X{ brkcase(); } break;
Xcase 198:
X# line 760 "gram.in"
X{ mkcase(yypvt[-0].pval,1); } break;
Xcase 199:
X# line 762 "gram.in"
X{ mkcase(yypvt[-0].pval,1); } break;
Xcase 200:
X# line 766 "gram.in"
X{ TEST fprintf(diagfile, "if-then-else\n");
X		  i = yypvt[-5].pval->brnchend & yypvt[-0].pval->brnchend;
X		  addexec();
X		  yyval.pval = addexec();
X		  thisexec->brnchend = i;
X		  TEST fprintf(diagfile, "exec: if(expr) exec else exec\n"); } break;
Xcase 201:
X# line 773 "gram.in"
X{ TEST fprintf(diagfile, "if-then\n");
X		  pushlex = 1;
X		  yyclearin;
X		  yyval.pval = ifthen();
X		  TEST fprintf(diagfile, "exec: if(expr) exec\n"); } break;
Xcase 202:
X# line 779 "gram.in"
X{ TEST fprintf(diagfile, "repeat done\n"); } break;
Xcase 203:
X# line 781 "gram.in"
X{ TEST fprintf(diagfile, "exec: control exec\n"); yyval.pval = addexec(); } break;
Xcase 204:
X# line 785 "gram.in"
X{ pushctl(STIF,yypvt[-1].pval); } break;
Xcase 205:
X# line 789 "gram.in"
X{
X		if(thisctl->breaklab == 0)
X			thisctl->breaklab = nextlab();
X		/* if(thisexec->prevexec->brnchend == 0) */
X			exgoto(thisctl->breaklab);
X		exlab( indifs[thisctl->indifn] = nextlab() );
X		} break;
Xcase 206:
X# line 799 "gram.in"
X{ pushctl(STREPEAT, PNULL); } break;
Xcase 207:
X# line 803 "gram.in"
X{ pushlex = 1;
X		  yyclearin;
X		  yyval.pval = addexec();
X		  exgoto(thisctl->xlab);
X		  TEST fprintf(diagfile, " no until\n"); } break;
Xcase 208:
X# line 809 "gram.in"
X{ yyval.pval = addexec();
X		  exnull();
X		  exlab( indifs[thisctl->indifn] = nextlab() );
X		  exifgo(mknode(TNOTOP,OPNOT,yypvt[-1].pval,PNULL), thisctl->xlab);
X		  TEST fprintf(diagfile, "until\n");
X		} break;
Xcase 209:
X# line 818 "gram.in"
X{ exretn(PNULL); } break;
Xcase 210:
X# line 820 "gram.in"
X{ exretn(yypvt[-0].pval); } break;
Xcase 212:
X# line 823 "gram.in"
X{ exgoto(yypvt[-0].ival); } break;
Xcase 213:
X# line 825 "gram.in"
X{ if( !equals(yypvt[-1].pval->namep, "to") )
X			execerr("go %s ??\n", yypvt[-1].pval->namep);
X		  else	 exgoto(yypvt[-0].ival);
X		} break;
Xcase 214:
X# line 830 "gram.in"
X{ excompgoto(yypvt[-1].pval, yypvt[-0].pval); } break;
Xcase 215:
X# line 832 "gram.in"
X{ if(!equals(yypvt[-2].pval->namep, "to") )
X			execerr("go %s ??\n", yypvt[-2].pval->namep);
X		  else excompgoto(yypvt[-1].pval, yypvt[-0].pval);
X		} break;
Xcase 216:
X# line 839 "gram.in"
X{ yyval.pval = yypvt[-1].pval; } break;
Xcase 217:
X# line 844 "gram.in"
X{ yyval.pval = mkchain(yypvt[-0].ival,CHNULL); } break;
Xcase 218:
X# line 846 "gram.in"
X{ yyval.pval = hookup(yypvt[-2].pval, mkchain(yypvt[-0].ival,CHNULL) ); } break;
Xcase 220:
X# line 851 "gram.in"
X{ yyval.pval = yypvt[-0].pval; } break;
Xcase 221:
X# line 856 "gram.in"
X{ yyval.ival = mklabel(yypvt[-0].pval,NO); } break;
Xcase 222:
X# line 858 "gram.in"
X{ yyval.ival = mklabel(mkilab(yypvt[-0].pval),NO); } break;
Xcase 223:
X# line 860 "gram.in"
X{ yyval.ival = mkcase(yypvt[-0].pval,0); } break;
Xcase 224:
X# line 862 "gram.in"
X{ yyval.ival = mkcase(PNULL,0); } break;
Xcase 225:
X# line 866 "gram.in"
X{ exbrk(yypvt[-0].ival, PNULL, 0); } break;
Xcase 226:
X# line 868 "gram.in"
X{ exbrk(yypvt[-1].ival, yypvt[-0].pval, 0); } break;
Xcase 227:
X# line 870 "gram.in"
X{ exbrk(yypvt[-1].ival, PNULL, yypvt[-0].ival); } break;
Xcase 228:
X# line 872 "gram.in"
X{ exbrk(yypvt[-2].ival,yypvt[-1].pval,yypvt[-0].ival); } break;
Xcase 229:
X# line 874 "gram.in"
X{ exbrk(yypvt[-2].ival,yypvt[-0].pval,yypvt[-1].ival); } break;
Xcase 230:
X# line 877 "gram.in"
X{ yyval.ival = 1; } break;
Xcase 231:
X# line 878 "gram.in"
X{ yyval.ival = 0; } break;
Xcase 232:
X# line 879 "gram.in"
X{ yyval.ival = 0; } break;
Xcase 233:
X# line 882 "gram.in"
X{ yyval.ival = STWHILE; } break;
Xcase 234:
X# line 883 "gram.in"
X{ yyval.ival = STFOR; } break;
Xcase 235:
X# line 884 "gram.in"
X{ yyval.ival = STDO; } break;
Xcase 236:
X# line 885 "gram.in"
X{ yyval.ival = STREPEAT; } break;
Xcase 237:
X# line 886 "gram.in"
X{ yyval.ival = STSWITCH; } break;
Xcase 238:
X# line 887 "gram.in"
X{ yyval.ival = STPROC; } break;
Xcase 239:
X# line 891 "gram.in"
X{ pushctl(STWHILE, yypvt[-1].pval);
X		    TEST fprintf(diagfile, "while(expr)\n"); } break;
Xcase 240:
X# line 894 "gram.in"
X{ exlab(thisctl->xlab);
X		  if(yypvt[-1].pval)
X			exifgo(mknode(TNOTOP,OPNOT,yypvt[-1].pval,PNULL),
X				thisctl->breaklab = nextlab() );
X		  else exnull();
X		  TEST fprintf(diagfile, "for (forlist)\n"); } break;
Xcase 241:
X# line 901 "gram.in"
X{ pushctl(STSWITCH,  simple(LVAL,yypvt[-1].pval));
X		  TEST fprintf(diagfile, "switch (expr)\n"); } break;
Xcase 242:
X# line 904 "gram.in"
X{ pushctl(STDO, yypvt[-0].pval);
X		  TEST fprintf(diagfile, "do loop\n"); } break;
Xcase 243:
X# line 909 "gram.in"
X{ yyval.pval = doloop(yypvt[-2].pval, PNULL, PNULL); } break;
Xcase 244:
X# line 911 "gram.in"
X{ yyval.pval = doloop(yypvt[-1].pval, PNULL, PNULL); } break;
Xcase 245:
X# line 913 "gram.in"
X{ yyval.pval = doloop(yypvt[-4].pval, yypvt[-2].pval, PNULL); } break;
Xcase 246:
X# line 915 "gram.in"
X{ yyval.pval = doloop(yypvt[-3].pval, yypvt[-1].pval, PNULL); } break;
Xcase 247:
X# line 917 "gram.in"
X{ yyval.pval = doloop(yypvt[-6].pval,yypvt[-4].pval,yypvt[-2].pval); } break;
Xcase 248:
X# line 919 "gram.in"
X{ yyval.pval = doloop(yypvt[-5].pval,yypvt[-3].pval,yypvt[-1].pval); } break;
Xcase 249:
X# line 923 "gram.in"
X{ pushctl(STFOR, PNULL); } break;
Xcase 250:
X# line 927 "gram.in"
X{ exgoto(thisctl->xlab);
X		  exlab(thisctl->nextlab);
X		  addexec();
X		  } break;
Xcase 251:
X# line 932 "gram.in"
X{ exgoto(thisctl->xlab);
X		  exlab(thisctl->nextlab);
X		  addexec();
X		  } break;
Xcase 253:
X# line 942 "gram.in"
X{ addexec(); } break;
Xcase 254:
X# line 944 "gram.in"
X{ addexec(); } break;
Xcase 255:
X# line 947 "gram.in"
X{ yyval.pval = 0; } break;
Xcase 257:
X# line 952 "gram.in"
X{ if(dbgopt) ++dbglevel; } break;
Xcase 258:
X# line 956 "gram.in"
X{ if(dbgopt) --dbglevel; } break;
Xcase 259:
X# line 960 "gram.in"
X{ yyval.pval = mkiost(yypvt[-5].ival, yypvt[-3].pval, yypvt[-1].pval); } break;
Xcase 260:
X# line 963 "gram.in"
X{ yyval.ival = 0; } break;
Xcase 261:
X# line 964 "gram.in"
X{ yyval.ival = 1; } break;
Xcase 262:
X# line 965 "gram.in"
X{ yyval.ival = 2; } break;
Xcase 263:
X# line 966 "gram.in"
X{ yyval.ival = 3; } break;
Xcase 265:
X# line 970 "gram.in"
X{ yyval.pval = NULL; } break;
Xcase 266:
X# line 973 "gram.in"
X{ yyval.pval = mkchain(yypvt[-0].pval,CHNULL); } break;
Xcase 267:
X# line 974 "gram.in"
X{ hookup(yypvt[-2].pval, mkchain(yypvt[-0].pval,CHNULL)); } break;
Xcase 268:
X# line 977 "gram.in"
X{ yyval.pval = mkioitem(yypvt[-0].pval,CNULL); } break;
Xcase 269:
X# line 978 "gram.in"
X{ yyval.pval = mkioitem(yypvt[-2].pval,yypvt[-0].pval); } break;
Xcase 270:
X# line 979 "gram.in"
X{ yyval.pval = mkioitem(PNULL,yypvt[-0].pval); } break;
Xcase 271:
X# line 980 "gram.in"
X{ yyval.pval = mkiogroup(yypvt[-0].pval, CNULL, PNULL); } break;
Xcase 272:
X# line 981 "gram.in"
X{ yyval.pval = mkiogroup(yypvt[-0].pval, CNULL, yypvt[-1].pval); } break;
Xcase 273:
X# line 982 "gram.in"
X{ yyval.pval = mkiogroup(yypvt[-2].pval,yypvt[-0].pval,yypvt[-3].pval); } break;
Xcase 274:
X# line 983 "gram.in"
X{ yyval.pval = mkiogroup(yypvt[-2].pval,yypvt[-0].pval,PNULL); } break;
Xcase 275:
X# line 986 "gram.in"
X{ ++iobrlevel; } break;
Xcase 276:
X# line 987 "gram.in"
X{ --iobrlevel;  yyval.pval = yypvt[-1].pval; } break;
Xcase 277:
X# line 991 "gram.in"
X{ yyval.pval = mkformat(yypvt[-0].ival, PNULL, PNULL); } break;
Xcase 278:
X# line 993 "gram.in"
X{ yyval.pval = mkformat(yypvt[-3].ival, yypvt[-1].pval, PNULL); } break;
Xcase 279:
X# line 995 "gram.in"
X{ yyval.pval = mkformat(yypvt[-5].ival,yypvt[-3].pval,yypvt[-1].pval); } break;
Xcase 280:
X# line 997 "gram.in"
X{ yyval.pval = yypvt[-1].pval->leftp; frexpblock(yypvt[-1].pval); } break;
Xcase 281:
X# line 1000 "gram.in"
X{ yyval.ival = yypvt[-1].ival; } break;
Xcase 282:
X# line 1003 "gram.in"
X{ lettneed = YES;} break;
Xcase 283:
X# line 1006 "gram.in"
X{ lettneed = NO; } break;
X		}
X		goto yystack;  /* stack new state and value */
X
X	}

echo x - gram.dcl
sed -e 's/^X//' > gram.dcl << ''
Xdcls1:	  dcl1
X	| dcls1 EOS
X	| dcls1 EOS dcl1
X		{ $$ = hookup($1,$3); }
X	;
X
Xdcl1:	  dcl
X	| varlist
X	;
X
Xdcl:	  attrs vars
X		{ attvars($1,$2); $$ = $2; }
X	| attrs LBRACK dcls1 RBRACK
X		{ attvars($1,$3); $$ = $3; }
X	| INITIAL initlist
X		{ $$ = 0; }
X	| IMPLICIT letton implist lettoff
X		{ $$ = 0; }
X	| EQUIVALENCE equivsets
X		{ $$ = 0; }
X	| EQUIVALENCE equivlist
X		{ mkequiv($2); $$ = 0; }
X	;
X
Xdcls:	  dcl
X	| dcls EOS
X	| dcls EOS dcl
X		{ $$ = hookup($1,$3); }
X	;
X
Xinitlist:	init
X	| initlist COMMA init
X	;
X
Xinit:	  lhs ASGNOP  {ininit = YES; }   expr
X		= { ininit = NO;  mkinit($1,$4);  frexpr($1); }
X	;
X
Ximplist:  impgroup
X	| implist COMMA impgroup;
X	;
X
Ximpgroup:  impspec
X		{ setimpl(imptype, 'a', 'z'); }
X	| impspec LPAR impsets RPAR
X	;
X
Ximpspec:  specs
X		{ imptype = $1->attype; cfree($1); }
X	;
X
Ximpsets:  impset
X	| impsets COMMA impset
X	;
X
Ximpset:	  LETTER
X		{ setimpl(imptype, $1, $1); }
X	| LETTER ADDOP LETTER
X		{ setimpl(imptype, $1, $3); }
X	;
X
Xequivsets:	equivset
X	| equivsets COMMA equivset
X	;
X
Xequivset:  LPAR equivlist RPAR
X		{ mkequiv($2); }
X	;
X
Xequivlist:  lhs COMMA lhs
X		{ $$ = mkchain($1, mkchain($3,CHNULL)); }
X	| equivlist COMMA lhs
X		{ $$ = hookup($1, mkchain($3,CHNULL)); }
X	;
X
Xattrs:	  attr
X	| attrs attr	{ attatt($1,$2); }
X	;
X
Xattr:	  spec dim	{ $1->atdim = $2; }
X	| array dim	{ $$ = ALLOC(atblock); $$->atdim = $2; }
X	;
X
Xdim:		{ $$ = 0; }
X	| dimbound
X	;
X
Xdimbound:  LPAR { inbound = 1; }  bounds RPAR
X			{ inbound = 0;  $$ = arrays = mkchain($3,arrays); }
X	;
X
Xbounds:	  bound
X	| bounds COMMA bound	{ hookup($1,$3); }
X	;
X
Xbound:	  ubound
X		{
X		$$ = ALLOC(dimblock);
X		$$->lowerb = 0;
X		$$->upperb = $1;
X		}
X	| expr COLON ubound
X		{
X		$$ = ALLOC(dimblock);
X		$$->lowerb = $1;
X		$$->upperb = $3;
X		}
X	;
X
Xubound:	  expr
X	| MULTOP  { $$ = 0; }
X	;
X
Xvars:		{ $$ = 0; }
X	| varlist
X	;
X
Xvarlist:  var
X	| varlist COMMA var	{ hookup($1,$3); }
X	;
X
Xvar:	  varname dim
X		{
X		if($2!=0)
X			if($1->vdim==0)
X				$1->vdim = $2;
X			else if(!eqdim($2,$1->vdim))
X				dclerr("multiple dimension", $1->namep);
X		$$ = mkchain($1,CHNULL);
X		}
X	| varname dim ASGNOP  { ininit = YES; }   expr
X		{
X		ininit = NO;
X		if($3!=OPASGN)
X			dclerr("illegal initialization operator", $1->sthead->namep);
X		if($2!=0)
X			if($1->vdim==0)
X				$1->vdim = $2;
X			else if(!eqdim($2,$1->vdim))
X				dclerr("multiple dimension", $1->sthead->namep);
X		if($5!=0 && $1->vinit!=0)
X			dclerr("multiple initialization", $1->sthead->namep);
X		$1->vinit = $5;
X		$$ = mkchain($1,CHNULL);
X		}
X	;
X
Xvarname:  NAME
X		{ $$ = mkvar($1); }
X	;
X
X
Xspecs:	  specarray
X	| specs specarray	{ attatt($1,$2); }
X	;
X
Xspecarray:  spec
X	| array dimbound
X		{ $$ = ALLOC(atblock); $$->atdim = $2; }
X	;
X
Xspec:	  sclass 
X		{
X		$$ = ALLOC(atblock);
X		if($1 == CLEXT)
X			$$->atext = 1;
X		$$->atclass = $1;
X		}
X	| comclass contnu
X		{
X		$$ = ALLOC(atblock);
X		$$->atclass = CLCOMMON;
X		$$->atcommon = $1;
X		}
X	| stype
X		{ $$ = ALLOC(atblock); $$->attype = $1; }
X	| CHARACTER LPAR expr RPAR
X		{ $$ = ALLOC(atblock); $$->attype = TYCHAR; $$->attypep = $3; }
X	| FIELD LPAR bound RPAR
X		{ $$ = ALLOC(atblock); $$->attype = TYFIELD;
X		  $$->attypep = mkfield($3); }
X	| deftype
X		{ $$ = ALLOC(atblock); $$->attype = TYSTRUCT;
X		  $$->attypep = $1; }
X	| prec
X		{ $$ = ALLOC(atblock); $$->atprec = $1; }
X	;
X
Xsclass:	  AUTOMATIC	{ $$ = CLAUTO;
X			  fprintf(diagfile,"AUTOMATIC not yet implemented\n"); }
X	| STATIC	{ $$ = CLSTAT; }
X	| INTERNAL	{ $$ = CLSTAT; }
X	| VALUE		{ $$ = CLVALUE;
X			  fprintf(diagfile, "VALUE not yet implemented\n");  }
X	| EXTERNAL	{ $$ = CLEXT; }
X	;
X
Xcomclass:  COMMON LPAR comneed comname RPAR
X			{ $$ = $4; }
X	| COMMON MULTOP comneed comname MULTOP
X			{ $$ = $4; }
X	;
X
Xcomneed:	{ comneed = 1; }
X	;
X
Xcomname:		{ $$ = mkcomm(""); }
X	| COMNAME
X	;
X
Xstype:	  INTEGER	{ $$ = TYINT; }
X	| REAL		{ $$ = TYREAL; }
X	| COMPLEX	{ $$ = TYCOMPLEX; }
X	| LOGICAL	{ $$ = TYLOG; }
X	| DOUBLE PRECISION
X			{ $$ = TYLREAL; /* holdover from Fortran */ }
X	| DOUBLEPRECISION
X			{ $$ = TYLREAL; /* holdover from Fortran */ }
X	;
X
Xdeftype:  STRUCTNAME
X		{ $$ = $1->varp; }
X	| STRUCT structname contnu struct
X		  { $$ = mkstruct($2,$4); }
X	| STRUCT struct
X		{ $$ = mkstruct(PNULL,$2); }
X	;
X
Xstructname:  NAME
X		{ if($1->varp && $1->varp->blklevel<blklevel)
X			hide($1);
X		  $1->tag = TSTRUCT;
X		}
X	| STRUCTNAME
X		{ if($1->varp)
X			if($1->varp->blklevel<blklevel)
X				hide($1);
X			else dclerr("multiple declaration for type %s", $1->namep);
X		}
X	;
X
Xstruct:	  LBRACK  { ++instruct; }   dcls  { --instruct; }   RBRACK EOS
X			{ $$ = $3; prevv = -1; }
X	;
X
Xarray:	  ARRAY
X	| DIMENSION
X	;
X
Xprec:	  LONG	{ $$ = 1; }
X	| SHORT	{ $$ = 0; }
X	;

echo x - gram.exec
sed -e 's/^X//' > gram.exec << ''
Xexec:	  beginexec exec1
X		{ TEST fprintf(diagfile, "exec done\n"); }
X	;
X
Xbeginexec:
X		{ $$ = bgnexec();  if(ncases > 0) ncases = 0; }
X	;
X
Xexec1:	  lhs ASGNOP expr
X		{
X		if($1->tag==TCALL)
X			{
X			dclerr("no statement functions in EFL",
X				$1->sthead->namep);
X			frexpr($1);
X			frexpr($3);
X			}
X		else exasgn($1,$2,$3);
X		}
X	| DOUBLEADDOP lhs
X		{ exasgn($2, $1, mkint(1) ); }
X	| lhs1
X		{ excall($1); }
X	| CALL lhs1
X		{ excall($2); }
X	| debug exec enddebug
X	| LBRACK beginblock stats endblock RBRACK
X		{ TEST fprintf(diagfile, "exec: { stats }\n");
X		  addexec(); }
X	| labels exec1
X		{ thisexec->labeled = 1; }
X	| control
X		{ thisexec->uniffable = 1;  popctl(); }
X	| branch
X		{ thisexec->brnchend = 1; }
X	| iostat
X		{ exio($1, 0); }
X	| null
X		{ exnull(); }
X	| ESCAPE
X		{
X		exnull();
X		putsii(ICCOMMENT, $1);
X		cfree($1);
X		exnull();
X		}
X	;
X
Xnull:
X		{ TEST fprintf(diagfile, "exec:empty\n"); }
X	|  CONTINUE
X		{ TEST fprintf(diagfile, "exec: continue\n"); }
X	;
X
Xbeginblock:
X		{
X		thisexec->copylab = 1;
X		++blklevel;
X		dclsect = 1;
X		ndecl[blklevel] = 0;
X		nhid [blklevel] = 0;
X		}
X	;
X
Xendblock:
X		{
X		if(ndecl[blklevel]) unhide();
X		--blklevel;
X		dclsect = 0;
X		}
X	;
X
Xlabels:	  NAME COLON contnu
X		{ mklabel($1,YES); }
X	| CONST contnu
X		{ mklabel(mkilab($1),YES); }
X	| CONST contnu COLON contnu
X		{ mklabel(mkilab($1),YES); }
X	| DEFAULT COLON contnu
X		{ brkcase(); mkcase(PNULL,1); }
X	| CASE { brkcase(); }  caselist COLON contnu
X	;
X
Xcaselist:     expr
X		{ mkcase($1,1); }
X	| caselist COMMA expr
X		{ mkcase($3,1); }
X	;
X
Xcontrol:  ifclause contnu exec EOS ELSE elsecode contnu exec
X		{ TEST fprintf(diagfile, "if-then-else\n");
X		  i = $3->brnchend & $8->brnchend;
X		  addexec();
X		  $$ = addexec();
X		  thisexec->brnchend = i;
X		  TEST fprintf(diagfile, "exec: if(expr) exec else exec\n"); }
X	| ifclause contnu exec EOS
X		{ TEST fprintf(diagfile, "if-then\n");
X		  pushlex = 1;
X		  yyclearin;
X		  $$ = ifthen();
X		  TEST fprintf(diagfile, "exec: if(expr) exec\n"); }
X	| repeat contnu exec until
X		{ TEST fprintf(diagfile, "repeat done\n"); }
X	| leftcont contnu exec
X		{ TEST fprintf(diagfile, "exec: control exec\n"); $$ = addexec(); }
X	;
X
Xifclause:	  IF LPAR expr RPAR
X		{ pushctl(STIF,$3); }
X	;
X
Xelsecode:
X		{
X		if(thisctl->breaklab == 0)
X			thisctl->breaklab = nextlab();
X		/* if(thisexec->prevexec->brnchend == 0) */
X			exgoto(thisctl->breaklab);
X		exlab( indifs[thisctl->indifn] = nextlab() );
X		}
X	;
X
Xrepeat:	  REPEAT
X		{ pushctl(STREPEAT, PNULL); }
X	;
X
Xuntil:	  EOS
X		{ pushlex = 1;
X		  yyclearin;
X		  $$ = addexec();
X		  exgoto(thisctl->xlab);
X		  TEST fprintf(diagfile, " no until\n"); }
X	| EOS UNTIL LPAR expr RPAR
X		{ $$ = addexec();
X		  exnull();
X		  exlab( indifs[thisctl->indifn] = nextlab() );
X		  exifgo(mknode(TNOTOP,OPNOT,$4,PNULL), thisctl->xlab);
X		  TEST fprintf(diagfile, "until\n");
X		}
X	;
X
Xbranch:	  RETURN
X		{ exretn(PNULL); }
X	| RETURN expr
X		{ exretn($2); }
X	| break
X	| GOTO label
X		{ exgoto($2); }
X	| GO NAME label
X		{ if( !equals($2->namep, "to") )
X			execerr("go %s ??\n", $2->namep);
X		  else	 exgoto($3);
X		}
X	| GOTO parlablist compgotoindex
X		{ excompgoto($2, $3); }
X	| GO NAME parlablist compgotoindex
X		{ if(!equals($2->namep, "to") )
X			execerr("go %s ??\n", $2->namep);
X		  else excompgoto($3, $4);
X		}
X	;
X
Xparlablist:   LPAR lablist RPAR
X		{ $$ = $2; }
X	;
X
X
Xlablist:   label
X		{ $$ = mkchain($1,CHNULL); }
X	| lablist COMMA label
X		{ $$ = hookup($1, mkchain($3,CHNULL) ); }
X	;
X
Xcompgotoindex:  expr
X	| COMMA expr
X		{ $$ = $2; }
X	;
X
X
Xlabel:	  NAME
X		{ $$ = mklabel($1,NO); }
X	| CONST
X		{ $$ = mklabel(mkilab($1),NO); }
X	| CASE expr
X		{ $$ = mkcase($2,0); }
X	| DEFAULT
X		{ $$ = mkcase(PNULL,0); }
X	;
X
Xbreak:	  brk
X		{ exbrk($1, PNULL, 0); }
X	| brk CONST
X		{ exbrk($1, $2, 0); }
X	| brk blocktype
X		{ exbrk($1, PNULL, $2); }
X	| brk CONST blocktype
X		{ exbrk($1,$2,$3); }
X	| brk blocktype CONST
X		{ exbrk($1,$3,$2); }
X	;
X
Xbrk:	  NEXT		{ $$ = 1; }
X	| BREAK		{ $$ = 0; }
X	| EXIT		{ $$ = 0; }
X	;
X
Xblocktype: WHILE	{ $$ = STWHILE; }
X	| FOR		{ $$ = STFOR; }
X	| DO		{ $$ = STDO; }
X	| REPEAT	{ $$ = STREPEAT; }
X	| SWITCH	{ $$ = STSWITCH; }
X	| PROCEDURE	{ $$ = STPROC; }
X	;
X
Xleftcont:   WHILE LPAR exprnull RPAR
X		{ pushctl(STWHILE, $3);
X		    TEST fprintf(diagfile, "while(expr)\n"); }
X	| for forinit fortest forincr
X		{ exlab(thisctl->xlab);
X		  if($3)
X			exifgo(mknode(TNOTOP,OPNOT,$3,PNULL),
X				thisctl->breaklab = nextlab() );
X		  else exnull();
X		  TEST fprintf(diagfile, "for (forlist)\n"); }
X	| SWITCH LPAR expr RPAR
X		{ pushctl(STSWITCH,  simple(LVAL,$3));
X		  TEST fprintf(diagfile, "switch (expr)\n"); }
X	| do
X		{ pushctl(STDO, $1);
X		  TEST fprintf(diagfile, "do loop\n"); }
X	;
X
Xdo:	  DO expr EOS contnu
X		{ $$ = doloop($2, PNULL, PNULL); }
X	| DO expr contnu
X		{ $$ = doloop($2, PNULL, PNULL); }
X	| DO expr COMMA expr EOS contnu
X		{ $$ = doloop($2, $4, PNULL); }
X	| DO expr COMMA expr contnu
X		{ $$ = doloop($2, $4, PNULL); }
X	| DO expr COMMA expr COMMA expr EOS contnu
X		{ $$ = doloop($2,$4,$6); }
X	| DO expr COMMA expr COMMA expr contnu
X		{ $$ = doloop($2,$4,$6); }
X	;
X
Xfor:	  FOR LPAR
X		{ pushctl(STFOR, PNULL); }
X	;
X
Xforinit:  exec COMMA
X		{ exgoto(thisctl->xlab);
X		  exlab(thisctl->nextlab);
X		  addexec();
X		  }
X	| exec EOS contnu COMMA
X		{ exgoto(thisctl->xlab);
X		  exlab(thisctl->nextlab);
X		  addexec();
X		  }
X	;
X
Xfortest:  exprnull COMMA
X	;
X
Xforincr:  exec RPAR
X		{ addexec(); }
X	| exec EOS contnu RPAR
X		{ addexec(); }
X	;
X
Xexprnull:	{ $$ = 0; }
X	| expr
X	;
X
Xdebug:	  DEBUG contnu
X		{ if(dbgopt) ++dbglevel; }
X	;
X
Xenddebug:
X		{ if(dbgopt) --dbglevel; }
X	;
X
Xiostat:	  iokwd LPAR iounit COMMA iolist RPAR
X		{ $$ = mkiost($1, $3, $5); }
X	;
X
Xiokwd:	  READBIN		{ $$ = 0; }
X	| WRITEBIN		{ $$ = 1; }
X	| READ	{ $$ = 2; }
X	| WRITE	{ $$ = 3; }
X	;
X
Xiounit:	  expr
X	|	{ $$ = NULL; }
X	;
X
Xiolist:	  ioitem		{ $$ = mkchain($1,CHNULL); }
X	| iolist COMMA ioitem	{ hookup($1, mkchain($3,CHNULL)); }
X	;
X
Xioitem:	  expr	{ $$ = mkioitem($1,CNULL); }
X	| expr COLON format	{ $$ = mkioitem($1,$3); }
X	| COLON format		{ $$ = mkioitem(PNULL,$2); }
X	| iobrace	{ $$ = mkiogroup($1, CNULL, PNULL); }
X	| do iobrace	{ $$ = mkiogroup($2, CNULL, $1); }
X	| do iobrace COLON format	{ $$ = mkiogroup($2,$4,$1); }
X	| iobrace COLON format	{ $$ = mkiogroup($1,$3,PNULL); }
X	;
X
Xiobrace:   LBRACK  { ++iobrlevel; }   iolist RBRACK
X		{ --iobrlevel;  $$ = $3; }
X	;
X
Xformat:	  letter
X		{ $$ = mkformat($1, PNULL, PNULL); }
X	| letter LPAR expr RPAR
X		{ $$ = mkformat($1, $3, PNULL); }
X	| letter LPAR expr COMMA expr RPAR
X		{ $$ = mkformat($1,$3,$5); }
X	| letton CONST lettoff
X		{ $$ = $2->leftp; frexpblock($2); }
X	;
X
Xletter:   letton   LETTER  lettoff  { $$ = $2; }
X	;
X
Xletton:			{ lettneed = YES;}
X	;
X
Xlettoff:			{ lettneed = NO; }
X	;
X
X%%
X
Xsetyydeb()
X{
X#ifdef YYDEBUG
X	extern int yydebug;
X	yydebug = 1;
X#endif
X}

echo x - gram.expr
sed -e 's/^X//' > gram.expr << ''
Xexpr:	  lhs
X		{ if($1->tag == TCALL)
X			$1 = funcinv($1);
X		  if($1->vtype==TYUNDEFINED && $1->vext==0)
X			impldecl($1);
X		  else if($1->tag==TNAME && $1->vdcldone==0
X			  && $1->vext==0 && !inbound)
X				dclit($1);
X		  if($1->vtype==TYFIELD)
X			$$ = extrfield($1);
X		}
X	| CONST
X	| logcon
X		{ $$ = mkconst(TYLOG, ($1 == TRUE ? ".true." : ".false.") ); }
X	| specs parexprs
X		{ $$ = typexpr($1,$2); }
X	| sizeof
X	| lengthof
X	| parexprs
X		{ if( !ininit && $1->tag== TLIST)
X			$$ = compconst($1); 
X		  else $1->needpar = 1; }
X	| expr ADDOP expr
X		{ $$ = mknode(TAROP,$2,$1,$3); }
X	| expr MULTOP expr
X		{ $$ = mknode(TAROP,$2,$1,$3); }
X	| expr POWER expr
X		{ $$ = mknode(TAROP,$2,$1,$3); }
X	| ADDOP expr  %prec MULTOP
X		{ if($1==OPMINUS)
X			$$ = mknode(TNEGOP,OPMINUS, $2, PNULL);
X		  else	$$ = $2;  }
X	| DOUBLEADDOP lhs  %prec MULTOP
X		{ $$ =  mknode(TASGNOP,$1,$2,mkint(1)); }
X	| expr RELOP expr
X		{ $$ = mknode(TRELOP,$2,$1,$3); }
X	| expr OR expr
X		{ $$ = mknode(TLOGOP,$2,$1,$3); }
X	| expr AND expr
X		{ $$ = mknode(TLOGOP,$2,$1,$3); }
X	| NOT expr
X		{ $$ = mknode(TNOTOP,$1,$2,PNULL); }
X	| lhs ASGNOP expr
X		{ if($1->tag == TCALL)
X			{
X			exprerr("may not assign to a function", CNULL);
X			$$ = errnode();
X			}
X		  else
X			$$ = mknode(TASGNOP,$2,$1,$3);
X		}
X	| expr REPOP expr
X		{ $$ = mknode(TREPOP,0,$1,$3); }
X	| iostat
X	| error
X		{ $$ = errnode(); }
X	;
X
Xlhs:	lhs1
X		{ if($1->tag==TNAME && $1->vdcldone==0 &&
X			$1->vsubs==0 && $1->vext==0 && !inbound)
X				dclit($1);
X		}
X	;
X
Xlhs1:	  lhsname
X	| lhsname parexprs
X		{
X		if($2->tag!=TLIST)
X			$2 = mknode(TLIST,0, mkchain($2,CHNULL), PNULL);
X		if($1->vdim)
X			{
X			if($1->vdcldone==0 && $1->vext==0)
X				dclit($1);
X			$$ = subscript($1,$2);
X			}
X		else	$$ = mkcall($1,$2);
X		}
X	| lhs QUALOP NAME
X		{ $$ = strucelt($1,$3); }
X	| lhs QUALOP NAME parexprs
X		{ if($4->tag != TLIST)
X			$4 = mknode(TLIST,0, mkchain($4,CHNULL), PNULL);
X		  $$ = subscript(strucelt($1,$3), $4);
X		}
X	| lhs ARROW STRUCTNAME
X		{ $$ = mkarrow($1,$3); }
X	;
X
Xlhsname:  NAME
X		{ if($1->varp == 0) mkvar($1);
X		  if(inbound)
X			  $1->varp->vadjdim = 1;
X		  $$ = cpexpr($1->varp); }
X	;
X
Xparexprs: LPAR RPAR
X		{ $$ = mknode(TLIST, 0, PNULL, PNULL); }
X	| LPAR expr RPAR
X		{ $$ = $2; }
X	| LPAR exprlist RPAR
X		{ $$ = mknode(TLIST,0,$2,PNULL); }
X	;
X
Xexprlist: expr COMMA expr
X		{ $$ = mkchain($1, mkchain($3, CHNULL) ); }
X	| exprlist COMMA expr
X		{ hookup($1, mkchain($3,CHNULL) ); }
X	;
X
Xsizeof:	  SIZEOF LPAR expr RPAR
X		{ $$ = esizeof($3->vtype, $3->vtypep, $3->vdim);
X		  frexpr($3); }
X	| SIZEOF LPAR specs RPAR
X		{ if($3->attype==TYREAL && $3->atprec)
X			$3->attype = TYLREAL;
X		  $$ = esizeof($3->attype, $3->attypep, $3->atdim);
X		  cfree($3);
X		}
X	| SIZEOF LPAR CHARACTER RPAR
X		{ $$ = mkint(tailor.ftnsize[FTNINT]/tailor.ftnchwd); }
X	;
X
Xlengthof:	  LENGTHOF LPAR expr RPAR
X		{ $$ = elenof($3->vtype, $3->vtypep, $3->vdim);
X		  frexpr($3); }
X	| LENGTHOF LPAR specs RPAR
X		{ $$ = elenof($3->attype, $3->attypep, $3->atdim);
X		  cfree($3);
X		}
X	| LENGTHOF LPAR CHARACTER RPAR
X		{ $$ = mkint(1); }
X	;
X
Xlogcon:   logval
X	| QUALOP logval QUALOP
X		{ $$ = $2; }
X	;
X
Xlogval:   TRUE
X	| FALSE
X	;

echo x - gram.head
sed -e 's/^X//' > gram.head << ''
X%{
X#include "defs"
Xptr bgnexec(), addexec(), bgnproc(), mkvar(), mkcomm(), mkstruct(), mkarrow();
Xptr mkiost(), mkioitem(), mkiogroup(), mkformat();
Xptr funcinv(), extrfield(), typexpr(), strucelt(), mkfield();
Xptr esizeof(), elenof(), mkilab();
Xptr ifthen(), doloop();
Xstruct varblock *subscript();
X%}
X
X%start graal
X%union { int ival; ptr pval; char *cval; }
X
X%left COLON
X%left COMMA
X%right ASGNOP	/* = +- -= ...  */
X%right REPOP	/*  $  */
X%left OR	/*  |  ||  */
X%left AND	/*  &  &&  */
X%left NOT
X%nonassoc RELOP	/*  LT GT LE GE EQ NE  */
X%left ADDOP	/* +  -  */
X%left MULTOP	/* *  /  */
X%right POWER	/*   **  ^  */
X%left ARROW QUALOP	/*  ->  .  */
X
X%type <pval> dcl stat exec stats proc args arg varname comname structname
X%type <pval> dcl1 dcls1 dcl dcls specs equivlist attrs attr comclass
X%type <pval> dim dimbound bounds bound ubound vars varlist var
X%type <pval> specarray spec deftype struct
X%type <pval> expr lhs parexprs iostat sizeof lengthof lhs1 lhsname exprlist
X%type <pval> beginexec control until lablist parlablist compgotoindex
X%type <pval> do exprnull fortest iostat iounit iolist ioitem iobrace
X%type <pval> format
X%type <ival> stype sclass prec logcon logval brk blocktype letter iokwd label
X%token <pval> CONST OPTNAME COMNAME STRUCTNAME NAME ESCAPE
X%token <ival> RELOP ASGNOP OR AND NOT ADDOP MULTOP POWER DOUBLEADDOP
X%token <ival> LETTER TRUE FALSE
X
X%{
Xextern int prevv;
Xextern YYSTYPE prevl;
Xptr p;
Xptr procattrs;
Xint i,n;
Xstatic int imptype;
Xstatic int ininit =NO;
X
X%}
X
X%%
X
X
Xgraal:
X		{ graal = PARSEOF; }
X	| option endchunk
X		{ graal = PARSOPT; }
X	| dcl endchunk
X		{ graal = PARSDCL; doinits($1);  frchain( & $1); }
X	| procst EOS stats end
X		{ endproc(); graal = PARSPROC; }
X	| define endchunk
X		{ graal = PARSDEF; }
X	| exec endchunk
X		{ graal = PARSERR; }
X	| error
X		{ graal = PARSERR;
X		  errmess("Syntax error", "", "");
X		}
X	;
X
Xendchunk:  EOS	{ eofneed = 1; }
X
Xstat:	  dcl EOS
X		{ if(!dclsect)
X			warn("declaration amid executables");
X		    $$ = bgnexec();
X		   TEST fprintf(diagfile,"stat: dcl\n");
X		  doinits($1); frchain( & $1); }
X	| exec EOS 
X		{ if(dclsect && $1->tag!=TSTFUNCT)
X			dclsect = 0;
X		    TEST fprintf(diagfile, "stat: exec\n"); }
X	| define EOS
X		{ $$ = bgnexec(); }
X	| error EOS
X		{ yyerrok;
X		  errmess("Syntax error", "", "");
X		  $$ = bgnexec();
X		}
X	;
X
Xstats:
X		{ $$ = bgnexec(); }
X	| stats   { thisexec->copylab = 1; }   stat
X		{ $$ = addexec(); thisexec->copylab = 0; }
X	;
X
Xprocst:	  oproc
X		{ procname = 0; thisargs = 0;
X		  if(procclass == 0) procclass = PRMAIN;
X		  goto proctype;
X		}
X	| oproc procname
X		{ thisargs = 0; goto proctype; }
X	| oproc procname LPAR RPAR
X		{ thisargs = 0; goto proctype; }
X	| oproc procname LPAR args RPAR
X		{ thisargs = $4;
X	proctype:
X		if(procattrs)
X			if(procname == 0)
X				dclerr("attributes on unnamed procedure", "");
X			else	{
X				attvars(procattrs, mkchain(procname,CHNULL));
X				procclass = PRFUNCT;
X				}
X		fprintf(diagfile, "Procedure %s:\n", procnm() );
X		if(verbose)
X			fprintf(diagfile, "    Pass 1\n");
X		}
X	;
X
Xprocname:  NAME
X		{ procname = mkvar($1);
X		  extname(procname);
X		}
X	;
X
Xoproc:	  proc
X		{ procattrs = 0; }
X	| attrs proc
X		{ procattrs = $1;
X		  if(procclass == 0) procclass = PRFUNCT;
X		}
X	;
X
Xproc:	  PROCEDURE
X		{ $$ = bgnproc(); procclass = 0; }
X	| BLOCKDATA
X		{ $$ = bgnproc(); procclass = PRBLOCK; }
X	;
X
Xargs:	  arg
X		{ $$ = mkchain($1,CHNULL); }
X	| args COMMA arg
X		{ hookup($1, mkchain($3,CHNULL) ); }
X	;
X
Xarg:	  varname
X		{ if($1->vclass == CLUNDEFINED)
X			$1->vclass = CLARG;
X		  else dclerr("argument already used", $1->sthead->namep);
X		}
X	;
X
Xoption:	  optson optionnames   { optneed = 0; }
X	;
X
Xoptson:	  OPTION
X		{ if(blklevel > 0)
X			{
X			execerr("Option statement inside procedure", "");
X			execerr("procedure %s terminated prematurely", procnm());
X			endproc();
X			}
X		  optneed = 1;
X		  }
X	;
X
Xoptionnames:
X	| optionnames optelt
X	| optionnames optelt COMMA
X	;
X
Xoptelt:	  OPTNAME
X		{ setopt($1,CNULL); cfree($1); }
X	| OPTNAME ASGNOP OPTNAME
X		{ setopt($1,$3); cfree($1); cfree($3); }
X	| OPTNAME ASGNOP CONST
X		{ setopt($1,$3->leftp); cfree($1); cfree($3); }
X	;
X
X
Xdefine:	  DEFINE   { defneed = 1; }
X	;
X
Xend:	  END
X		{ if(thisctl->subtype != STPROC)
X			execerr("control stack not empty upon END", "");
X		  exnull();
X		  popctl();
X		}
X	;
X
Xcontnu:
X		{ igeol=1; /* continue past newlines  */ }
X	;

echo x - icfile.c
sed -e 's/^X//' > icfile.c << ''
X#include "defs"
X
Xstruct { char chars[ 10 ]; };
X
X
Xcrii()	/* create names for intermediate files */
X{
X
X#ifdef unix
Xsprintf(icfile->filename, "eflc.%d", getpid());
Xsprintf(idfile->filename, "efld.%d", getpid());
Xsprintf(iefile->filename, "efle.%d", getpid());
X#endif
X
X#ifdef gcos
Xsprintf(icfile->filename, "code.efl");
Xsprintf(idfile->filename, "data.efl");
Xsprintf(iefile->filename, "equv.efl");
X#endif
X}
X
X
X
Xrmiis()
X{
Xrmii(icfile);
Xrmii(idfile);
Xrmii(iefile);
X}
X
X
X
X
Xrmii(p)		/* discard the intermediate file */
Xstruct fileblock *p;
X{
X#ifdef unix
Xif(p)
X	{
X	fclose(p->fileptr);
X	unlink(p->filename);
X	}
X#endif
X
X#ifdef gcos
Xif(p)
X	fclose(p->fileptr, "d");
X#endif
X}
X
X
Xopiis()
X{
Xopii(icfile);
Xopii(idfile);
Xopii(iefile);
X}
X
X
X
X
Xopii(p)	/* open the intermediate file for writing */
Xstruct fileblock *p;
X{
X
X#ifdef unix
Xif( (p->fileptr = fopen(p->filename, "w")) == NULL)
X	fatal("cannot open intermediate file");
X#endif
X
X#ifdef gcos
Xif( (p->fileptr = fopen(p->filename, "wi")) == NULL)
X	fatal("cannot open intermediate file");
X#endif
X
X}
X
X
X
Xswii(p)
Xstruct fileblock *p;
X{
Xiifilep = p;
X}
X
X
X
Xputii(w,n)
Xint *w, n;
X{
Xif( fwrite(w,sizeof(int),n, iifilep->fileptr) != n)
X	fatal("write error");
X}
X
X
X
Xgetii(w, n)
Xint *w, n;
X{
Xif( fread(w,sizeof(int), n, iifilep->fileptr) != n)
X	fatal("read error");
X}
X
X
X
X
Xcliis()
X{
Xclii(icfile);
Xclii(idfile);
Xclii(iefile);
X}
X
X
X
X
Xclii(p)	/* close the intermediate file */
Xstruct fileblock *p;
X{
X#ifdef unix
Xfclose(p->fileptr);
X#endif
X
X#ifdef gcos
Xfclose(p->fileptr, "rl");
X#endif
X}
X
X
X
Xrewii(p)	/* close and rewind the intermediate file for reading */
Xstruct fileblock *p;
X{
Xswii(p);
Xputic(ICEOF,0);
Xclii(p);
X
X#ifdef unix
Xif( (p->fileptr = fopen(p->filename, "r")) == NULL)
X	fatal("cannot open intermediate file");
X#endif
X
X#ifdef gcos
Xif( (p->fileptr = fopen(p->filename, "ri")) == NULL)
X	fatal("cannot open intermediate file");
X#endif
X}
X
X
X
Xputic(c,p)
Xint c;
Xint p;
X{
Xint w[2];
Xprevbg = (c==ICINDENT);
Xw[0] = c;
Xw[1] = p;
Xputii(w,2);
X}
X
X
Xgetic(p)
Xint *p;
X{
Xint w[2];
X
Xgetii(w,2);
X*p = w[1];
Xreturn( w[0] );
X}
X
X
X
Xputsii(l, p)
Xint l;
Xchar *p;
X{
Xint word;
Xregister int i, m, n;
X
Xn = strlen(p);
Xputic(l, n);
Xm = (n/sizeof(int)) ;
Xwhile(m-- > 0)
X	{
X	for(i=0 ; i<sizeof(int); ++i)
X		word.chars[i] = *p++;
X	putii(&word, 1);
X	}
Xn -= (n/sizeof(int))*sizeof(int);
Xif(n > 0)
X	{
X	for(i=0 ; i<n ; ++i)
X		word.chars[i] = *p++;
X	putii(&word,1);
X	}
X}
X
X
X
X
Xptr getsii(n)
Xint n;
X{
Xstatic int incomm[100];
Xint m;
Xregister int *q, *qm;
Xchar *p;
X
Xm = (n + sizeof(int)-1 ) / sizeof(int);
Xq = incomm;
Xqm = q + m;
X
Xwhile(q < qm)
X	getii(q++, 1);
Xp = incomm;
Xp[n] = '\0';
X
Xreturn(incomm);
X}

echo x - init.c
sed -e 's/^X//' > init.c << ''
X#include "defs"
X#include "tokdefs"
X
Xkwinit()
X{
Xstruct key { char *keyn; int keyval; } *p;
Xstatic struct key keys[] = {
X	"common", COMMON,
X	"internal", INTERNAL,
X	"external", EXTERNAL,
X	"automatic", AUTOMATIC,
X	"static", STATIC,
X	"value", VALUE,
X	"procedure", PROCEDURE,
X	"blockdata", BLOCKDATA,
X	"subroutine", PROCEDURE	/* NB */,
X	"function", PROCEDURE		/* NB */,
X	"option", OPTION,
X	"include", INCLUDE,
X	"define", DEFINE,
X	"end", END,
X	"integer", INTEGER,
X	"real", REAL,
X	"complex", COMPLEX,
X	"logical", LOGICAL,
X	"character", CHARACTER,
X	"struct", STRUCT,
X	"field", FIELD,
X	"array", ARRAY,
X	"dimension", DIMENSION,
X	"long", LONG,
X	"short", SHORT,
X	"initial", INITIAL,
X	"equivalence", EQUIVALENCE,
X	"implicit", IMPLICIT,
X	"debug", DEBUG,
X	"if", IF,
X	"else", ELSE,
X	"while", WHILE,
X	"until", UNTIL,
X	"repeat", REPEAT,
X	"do", DO,
X	"for", FOR,
X	"switch", SWITCH,
X	"select", SWITCH,
X	"case", CASE,
X	"default", DEFAULT,
X	"go", GO,
X	"goto", GOTO,
X	"break", BREAK,
X	"exit", EXIT,
X	"next", NEXT,
X	"return", RETURN,
X	"continue", CONTINUE,
X	"call", CALL,
X	"double", DOUBLE,
X	"precision", PRECISION,
X	"doubleprecision", DOUBLEPRECISION,
X	"sizeof", SIZEOF,
X	"lengthof", LENGTHOF,
X	"read", READ,
X	"write", WRITE,
X	"readbin", READBIN,
X	"writebin", WRITEBIN,
X	"true", TRUE,
X	"false", FALSE,
X	0, 0 } ;
X
Xfor(p = keys ; p->keyn ; ++p)
X	mkkeywd(p->keyn, p->keyval);
X}
X
X
X
Xgeninit()
X{
Xstruct gen { char *genn; int restype; char *specn; int argtype; } *p;
Xstatic struct gen gens[] = {
X	"abs", TYINT, "iabs", TYINT,
X	"abs", TYREAL, "abs", TYREAL,
X	"abs", TYLREAL, "dabs", TYLREAL,
X	"abs", TYCOMPLEX, "cabs", TYREAL,
X
X	"sin", TYREAL, "sin", TYREAL,
X	"sin", TYLREAL, "dsin", TYLREAL,
X	"sin", TYCOMPLEX, "csin", TYCOMPLEX,
X
X	"cos", TYREAL, "cos", TYREAL,
X	"cos", TYLREAL, "dcos", TYLREAL,
X	"cos", TYCOMPLEX, "ccos", TYCOMPLEX,
X
X	"atan", TYREAL, "atan", TYREAL,
X	"atan", TYLREAL, "datan", TYLREAL,
X
X	"atan2", TYREAL, "atan2", TYREAL,
X	"atan2", TYLREAL, "datan2", TYLREAL,
X
X	"sqrt", TYREAL, "sqrt", TYREAL,
X	"sqrt", TYLREAL, "dsqrt", TYLREAL,
X	"sqrt", TYCOMPLEX, "csqrt", TYCOMPLEX,
X
X	"log", TYREAL, "alog", TYREAL,
X	"log", TYLREAL, "dlog", TYLREAL,
X	"log", TYCOMPLEX, "clog", TYCOMPLEX,
X
X	"log10", TYREAL, "alog10", TYREAL,
X	"log10", TYLREAL, "dlog10", TYLREAL,
X
X	"exp", TYREAL, "exp", TYREAL,
X	"exp", TYLREAL, "dexp", TYLREAL,
X	"exp", TYCOMPLEX, "cexp", TYCOMPLEX,
X
X	"int", TYREAL, "int", TYINT,
X	"int", TYLREAL, "idint", TYINT,
X
X	"mod", TYINT, "mod", TYINT,
X	"mod", TYREAL, "amod", TYREAL,
X	"mod", TYLREAL, "dmod", TYLREAL,
X
X	"min", TYINT, "min0", TYINT,
X	"min", TYREAL, "amin1", TYREAL,
X	"min", TYLREAL, "dmin1", TYLREAL,
X
X	"max", TYINT, "max0", TYINT,
X	"max", TYREAL, "amax1", TYREAL,
X	"max", TYLREAL, "dmax1", TYLREAL,
X
X	"sign", TYREAL, "sign", TYREAL,
X	"sign", TYINT, "isign", TYINT,
X	"sign", TYLREAL, "dsign", TYLREAL,
X	0, 0, 0, 0 } ;
X
Xfor(p = gens ; p->genn ; ++p)
X	mkgeneric(p->genn, p->restype, p->specn, p->argtype);
X}
X
Xknowninit()
X{
Xstruct known { char *knownn; int knowntype; } *p;
Xstatic struct known knowns[ ] = {
X	"abs", TYREAL,
X	"iabs", TYINT,
X	"dabs", TYLREAL,
X	"aint", TYREAL,
X	"int", TYINT,
X	"idint", TYINT,
X	"amod", TYREAL,
X	"mod", TYINT,
X	"amax0", TYREAL,
X	"amax1", TYREAL,
X	"max0", TYINT,
X	"max1", TYINT,
X	"dmax1", TYLREAL,
X	"amin0", TYREAL,
X	"amin1", TYREAL,
X	"min0", TYINT,
X	"min1", TYINT,
X	"dmin1", TYLREAL,
X	"float", TYREAL,
X	"ifix", TYINT,
X	"sign", TYREAL,
X	"isign", TYINT,
X	"dsign", TYLREAL,
X	"dim", TYREAL,
X	"idim", TYINT,
X	"sngl", TYREAL,
X	"real", TYREAL,
X	"aimag", TYREAL,
X	"dble", TYLREAL,
X	"cmplx", TYCOMPLEX,
X	"conjg", TYCOMPLEX,
X	"exp", TYREAL,
X	"dexp", TYLREAL,
X	"cexp", TYCOMPLEX,
X	"alog", TYREAL,
X	"dlog", TYLREAL,
X	"clog", TYCOMPLEX,
X	"alog10", TYREAL,
X	"dlog10", TYLREAL,
X	"sin", TYREAL,
X	"dsin", TYLREAL,
X	"csin", TYCOMPLEX,
X	"cos", TYREAL,
X	"dcos", TYLREAL,
X	"ccos", TYCOMPLEX,
X	"tanh", TYREAL,
X	"sqrt", TYREAL,
X	"dsqrt", TYLREAL,
X	"csqrt", TYCOMPLEX,
X	"atan", TYREAL,
X	"datan", TYLREAL,
X	"atan2", TYREAL,
X	"datan2", TYLREAL,
X	"dmod", TYLREAL,
X	"cabs", TYREAL,
X	0, 0 };
X
Xfor(p = knowns ; p->knownn ; ++p)
X	mkknown(p->knownn, p->knowntype);
X}

echo x - io.c
sed -e 's/^X//' > io.c << ''
X#include <ctype.h>
X
X#include "defs"
X
Xstatic int lastfmtchar;
Xstatic int writeop;
Xstatic int needcomma;
X
X
Xptr mkiost(kwd,unit,list)
Xint kwd;
Xptr unit;
Xptr list;
X{
Xregister ptr p;
X
Xif(unit!=NULL && unit->vtype!=TYINT)
X	{
X	execerr("I/O unit must be an integer", "");
X	return(NULL);
X	}
Xp = allexpblock();
Xp->tag = TIOSTAT;
Xp->vtype = TYINT;
Xp->iokwd = kwd;
Xp->iounit = unit;
Xp->iolist = list;
X
Xreturn(p);
X}
X
X
X
X
Xstruct iogroup *mkiogroup(list, format, dop)
Xptr list;
Xchar *format;
Xptr dop;
X{
Xregister struct iogroup *p;
X
Xp = ALLOC(iogroup);
Xp->tag = TIOGROUP;
Xp->doptr = dop;
Xp->iofmt = format;
Xp->ioitems = list;
Xreturn(p);
X}
X
Xptr exio(iostp, errhandle)
Xstruct iostblock *iostp;
Xint errhandle;
X{
Xptr unit, list;
Xint fmtlabel, errlabel, endlabel, jumplabel;
Xptr errval;
Xint fmtio;
X
Xif(iostp == NULL)
X	return( errnode() );
Xunit = iostp->iounit;
Xlist = iostp->iolist;
X
X/* kwd=	0  binary input 	2  formatted input
X	1  binary output	3  formatted output
X*/
X
Xwriteop = iostp->iokwd & 01;
Xif( fmtio = (iostp->iokwd & 02) )
X	fmtlabel = nextlab() ;
Xfrexpblock(iostp);
X
Xerrval = 0;
Xendlabel = 0;
Xif(errhandle)
X	{
X	switch(tailor.errmode)
X		{
X		default:
X			execerr("no error handling ", "");
X			return( errnode() );
X
X		case IOERRIBM:	/* ibm: err=, end= */
X			jumplabel = nextlab();
X			break;
X
X		case IOERRFORT77:	/* New Fortran Standard: iostat= */
X			break;
X
X		}
X	errval = gent(TYINT, PNULL);
X	}
Xif(unit)
X	unit = simple(RVAL, unit);
Xelse	unit = mkint(writeop ? tailor.ftnout : tailor.ftnin);
X
Xif(unit->tag!=TCONST && (unit->tag!=TNAME || unit->vsubs!=0))
X	unit = simple(LVAL, mknode(TASGNOP,OPASGN,gent(TYINT,PNULL),unit));
X
Xsimlist(list);
X
Xexlab(0);
Xputic(ICKEYWORD, (writeop ? FWRITE : FREAD) );
Xputic(ICOP, OPLPAR);
Xprexpr(unit);
Xfrexpr(unit);
X
Xif( fmtio )
X	{
X	putic(ICOP, OPCOMMA);
X	putic(ICLABEL, fmtlabel);
X	}
X
Xif(errhandle) switch(tailor.errmode)
X	{
X	case IOERRIBM:
X		putic(ICOP,OPCOMMA);
X		putsii(ICCONST, "err =");
X		putic(ICLABEL, errlabel = nextlab() );
X		if(!writeop)
X			{
X			putic(ICOP,OPCOMMA);
X			putsii(ICCONST, "end =");
X			putic(ICLABEL, endlabel = nextlab() );
X			}
X		break;
X
X	case IOERRFORT77:
X		putic(ICOP,OPCOMMA);
X		putsii(ICCONST, "iostat =");
X		putname(errval);
X		break;
X	}
X
Xputic(ICOP,OPRPAR);
Xputic(ICBLANK, 1);
X
Xneedcomma = NO;
Xdoiolist(list);
Xif(fmtio)
X	{
X	exlab(fmtlabel);
X	putic(ICKEYWORD, FFORMAT);
X	putic(ICOP, OPLPAR);
X	lastfmtchar = '(';
X	doformat(1, list);
X	putic(ICOP, OPRPAR);
X	}
Xfriolist(list);
X
Xif(errhandle && tailor.errmode==IOERRIBM)
X	{
X	exasgn(cpexpr(errval), OPASGN, mkint(0) );
X	exgoto(jumplabel);
X	exlab(errlabel);
X	exasgn(cpexpr(errval), OPASGN, mkint(1) );
X	if(endlabel)
X		{
X		exgoto(jumplabel);
X		exlab(endlabel);
X		exasgn(cpexpr(errval), OPASGN,
X			mknode(TNEGOP,OPMINUS,mkint(1),PNULL) );
X		}
X	exlab(jumplabel);
X	}
X
Xreturn( errval );
X}
X
Xdoiolist(list)
Xptr list;
X{
Xregister ptr p, q;
Xregister struct doblock *dop;
Xfor(p = list ; p ; p = p->nextp)
X	{
X	switch( (q = p->datap) ->tag)
X		{
X		case TIOGROUP:
X			if(dop = q->doptr)
X				{
X				if(needcomma)
X					putic(ICOP, OPCOMMA);
X				putic(ICOP, OPLPAR);
X				needcomma = NO;
X				}
X			doiolist(q->ioitems);
X			if(dop)
X				{
X				putic(ICOP,OPCOMMA);
X				prexpr(dop->dovar);
X				putic(ICOP, OPEQUALS);
X				prexpr(dop->dopar[0]);
X				putic(ICOP, OPCOMMA);
X				prexpr(dop->dopar[1]);
X				if(dop->dopar[2])
X					{
X					putic(ICOP, OPCOMMA);
X					prexpr(dop->dopar[2]);
X					}
X				putic(ICOP, OPRPAR);
X				needcomma = YES;
X				}
X			break;
X
X		case TIOITEM:
X			if(q->ioexpr)
X				{
X				if(needcomma)
X					putic(ICOP, OPCOMMA);
X				prexpr(q->ioexpr);
X				needcomma = YES;
X				}
X			break;
X
X		default:
X			badtag("doiolist", q->tag);
X		}
X	}
X}
X
Xdoformat(nrep, list)
Xint nrep;
Xptr list;
X{
Xregister ptr p, q;
Xint k;
Xptr arrsize();
X
Xif(nrep > 1)
X	{
X	fmtnum(nrep);
X	fmtop(OPLPAR);
X	}
X
Xfor(p = list ; p ; p = p->nextp)
X	switch( (q = p->datap) ->tag)
X		{
X		case TIOGROUP:
X			if(q->iofmt)
X				prfmt(q->nrep, q->iofmt);
X			else	{
X				doformat(q->nrep>0 ? q->nrep :
X					(q->doptr ? repfac(q->doptr) : 1),
X					q->ioitems);
X				}
X			break;
X
X		case TIOITEM:
X			if(q->iofmt == NULL)
X				break;
X
X			if(q->nrep==0 && q->ioexpr && q->ioexpr->vdim)
X				{
X				if( ! isicon(arrsize(q->ioexpr), &k) )
X					execerr("io of adjustable array", "");
X				else
X					prfmt(k, q->iofmt);
X				}
X			else
X				prfmt(q->nrep, q->iofmt);
X		}
Xif(nrep > 1)
X	fmtop(OPRPAR);
X}
X
Xfmtop(op)
Xregister int op;
X{
Xregister c;
X
Xc = (op==OPLPAR ? '(' : (op==OPRPAR ? ')' : 'x') );
Xfmtcom(c);
Xputic(ICOP, op);
Xlastfmtchar = c;
X}
X
X
X
X
Xfmtnum(k)
Xint k;
X{
Xfmtcom('1');
Xprexpr( mkint(k) );
Xlastfmtchar = ',';	/* prevent further comma after factor*/
X}
X
X
X
X
X
X
X
X
X/* separate formats with comma unless already a slash*/
Xfmtcom(c)
Xint c;
X{
Xif( c!='/' && c!=')' && lastfmtchar!='/' && lastfmtchar!='(' && lastfmtchar!=',' )
X	{
X	putic(ICOP, OPCOMMA);
X	lastfmtchar = ',';
X	}
X}
X
Xprfmt(nrep, str)
Xint nrep;
Xchar *str;
X{
Xchar fmt[20];
Xregister int k, k0, k1, k2;
Xregister char *t;
X
Xfmtcom(nrep>1 ? '1' : str[0]);
X
Xif(nrep > 1)
X	{
X	fmtnum(nrep);
X	fmtop(OPLPAR);
X	}
X
Xswitch(str[0])
X	{
X	case 'd':
X	case 'e':
X	case 'g':
X		if(writeop)
X			{
X			putsii(ICCONST, "1p");
X			break;
X			}
X	
X	case 'f':
X		putsii(ICCONST, "0p");
X		break;
X		
X	case 'c':
X		k = convci(str+1);
X		k0 = tailor.ftnchwd;
X		k1 = k / k0;
X		k2 = k % k0;
X		if(k1>0 && k2>0)
X			sprintf(fmt, "(%da%d,a%d)",k1,k0,k2);
X		else if(k1>1)
X			sprintf(fmt, "(%da%d)", k1, k0);
X		else	sprintf(fmt, "a%d", k);
X		putsii(ICCONST, fmt);
X		lastfmtchar = 'f';	/* last char isnt operator */
X		goto close;
X
X	default:
X		break;
X	}
Xputsii(ICCONST,str);
X/* if the format is an nH, act as if it ended with a non-operator character */
Xif( isdigit(str[0]) )
X	{
X	for(t = str+1 ; isdigit(*t) ; ++t);
X		;
X	if(*t=='h' || *t=='H')
X		{
X		lastfmtchar = 'f';
X		goto close;
X		}
X	}
Xlastfmtchar = str[ strlen(str)-1 ];
X
Xclose:
X	if(nrep > 1)
X		fmtop(OPRPAR);
X}
X
Xfriolist(list)
Xptr list;
X{
Xregister ptr p, q;
Xregister struct doblock *dop;
X
Xfor(p = list; p; p = p->nextp)
X	{
X	switch ( (q = p->datap) ->tag)
X		{
X		case TIOGROUP:
X			if(dop = q->doptr)
X				{
X				frexpr(dop->dovar);
X				frexpr(dop->dopar[0]);
X				frexpr(dop->dopar[1]);
X				if(dop->dopar[2])
X					frexpr(dop->dopar[2]);
X				cfree(dop);
X				}
X			friolist(q->ioitems);
X			break;
X
X		case TIOITEM:
X			if(q->ioexpr)
X				frexpr(q->ioexpr);
X			break;
X
X		default:
X			badtag("friolist", q->tag);
X		}
X	if(q->iofmt)
X		cfree(q->iofmt);
X	cfree(q);
X	}
Xfrchain( &list );
X}
X
Xsimlist(p)
Xregister ptr p;
X{
Xregister ptr q, ep;
Xstruct iogroup *enloop();
X
Xfor( ; p ; p = p->nextp)
X	switch( (q = p->datap) ->tag )
X		{
X		case TIOGROUP:
X			simlist(q->ioitems);
X			break;
X
X		case TIOITEM:
X			if(ep = q->ioexpr)
X				{
X				/* if element is a subaggregate, need
X				   an implied do loop */
X				if( (ep->voffset || ep->vsubs) &&
X				    (ep->vdim || ep->vtypep) )
X					p->datap = enloop(q);
X				else
X					q->ioexpr = simple(LVAL,ep);
X				}
X			break;
X
X		default:
X			badtag("ioblock", q->tag);
X		}
X}
X
X
X
X
X/* replace an aggregate by an implied do loop of elements */
X
Xstruct iogroup *enloop(p)
Xstruct ioitem *p;
X{
Xregister struct doblock *dop;
Xstruct iogroup *gp;
Xptr np, q, v, arrsize(), mkioitem();
Xint nrep, k, nwd;
X
Xq = p->ioexpr;
Xnp = arrsize(q);
Xif( ! isicon(np, &nrep) )
X	nrep = 0;
X
Xif(q->vtype == TYCHAR)
X	{
X	nwd = ceil(conval(q->vtypep), tailor.ftnchwd);
X	if(nwd != 1)
X		np = simple(LVAL, mknode(TAROP,OPSTAR,np,mkint(nwd)));
X	}
Xelse
X	nwd = 0;
X
Xif( isicon(np, &k) && k==1)
X	return(p);
X
Xdop = ALLOC(doblock);
Xdop->tag = TDOBLOCK;
X
Xdop->dovar = v = gent(TYINT, PNULL);
Xdop->dopar[0] = mkint(1);
Xdop->dopar[1] = simple(SUBVAL, np);
Xdop->dopar[2] = NULL;
X
Xq = simple(LVAL, q);
Xif(q->vsubs == NULL)
X	q->vsubs = mknode(TLIST,0, mkchain(cpexpr(v),CHNULL), PNULL);
Xelse
X	q->vsubs->leftp->datap = simple(SUBVAL, mknode(TAROP,OPPLUS, cpexpr(v),
X		     mknode(TAROP,OPMINUS,q->vsubs->leftp->datap,mkint(1))));
Xq->vdim = NULL;
Xgp = mkiogroup( mkchain(mkioitem(q,CNULL), CHNULL), p->iofmt, dop);
Xgp->nrep = nrep;
Xcfree(p);
Xreturn(gp);
X}
X
Xptr mkformat(letter, n1, n2)
Xchar letter;
Xregister ptr n1, n2;
X{
Xchar f[20], *fp, *s;
Xint k;
X
Xif(letter == 's')
X	{
X	if(n1)
X		{
X		k = conval(n1);
X		frexpr(n1);
X		}
X	else	k = 1;
X
X	for(fp = f; k-->0 ; )
X		*fp++ = '/';
X	*fp = '\0';
X	return( copys(f) );
X	}
X
Xf[0] = letter;
Xfp = f+1;
X
Xif(n1)	{
X	n1 = simple(RVAL,n1);
X	if(n1->tag==TCONST && n1->vtype==TYINT)
X		{
X		for(s = n1->leftp ; *s; )
X			*fp++ = *s++;
X		}
X	else	execerr("bad format component %s", n1->leftp);
X	frexpr(n1);
X	}
X
Xif(n2)	{
X	if(n2->tag==TCONST && n2->vtype==TYINT)
X		{
X		*fp++ = '.';
X		for(s = n2->leftp ; *s; )
X			*fp++ = *s++;
X		}
X	else	execerr("bad format component %s", n2->leftp);
X	frexpr(n2);
X	}
X
Xif( letter == 'x' )
X	{
X	if(n1 == 0)
X		*fp++ = '1';
X	fp[0] = 'x';
X	fp[1] = '\0';
X	return( copys(f+1) );
X	}
Xelse	{
X	*fp = '\0';
X	return( copys(f) );
X	}
X}
X
Xptr mkioitem(e,f)
Xregister ptr e;
Xchar *f;
X{
Xregister ptr p;
Xchar fmt[10];
Xptr gentemp();
X
Xp = ALLOC(ioitem);
Xp->tag = TIOITEM;
Xif(e!=NULL && e->tag==TCONST)
X	if(e->vtype==TYCHAR && (f==0 || (f[0]=='c' && f[1]=='\0') ))
X		{
X		p->ioexpr = 0;
X		sprintf(msg, "%dh%s", strlen(e->leftp), e->leftp);
X		p->iofmt = copys(msg);
X		frexpr(e);
X		return(p);
X		}
X	else	e = mknode(TASGNOP,OPASGN,gentemp(e),e);
X
Xif(e && e->vtype==TYCHAR && f && f[0]=='c' && f[1]=='\0')
X	f = NULL;
Xif(f == NULL)
X	{
X	switch(e->vtype)
X		{
X		case TYINT:
X		case TYREAL:
X		case TYLREAL:
X		case TYCOMPLEX:
X		case TYLOG:
X			f = copys( tailor.dfltfmt[e->vtype] );
X			break;
X
X		case TYCHAR:
X			if(e->vtypep->tag != TCONST)
X				{
X				execerr("no adjustable character formats", "");
X				f = 0;
X				}
X			else	{
X				sprintf(fmt, "c%s", e->vtypep->leftp);
X				f = copys(fmt);
X				}
X			break;
X
X		default:
X			execerr("cannot do I/O on structures", "");
X			f = 0;
X			break;
X		}
X	}
X
Xp->ioexpr = e;
Xp->iofmt = f;
Xreturn(p);
X}
X
X
X
Xptr arrsize(p)
Xptr p;
X{
Xregister ptr b;
Xptr f, q;
X
Xq = mkint(1);
X
Xif(b = p->vdim)
X    for(b = b->datap ; b ; b = b->nextp)
X	{
X	if(b->upperb == 0) continue;
X	f = cpexpr(b->upperb);
X	if(b->lowerb)
X		f = mknode(TAROP,OPPLUS,f,
X			mknode(TAROP,OPMINUS,mkint(1),cpexpr(b->lowerb)));
X	q = simple(RVAL, mknode(TAROP,OPSTAR,q,f));
X	}
Xreturn(q);
X}
X
X
X
X
Xrepfac(dop)
Xregister struct doblock *dop;
X{
Xint m1, m2, m3;
X
Xm3 = 1;
Xif( isicon(dop->dopar[0],&m1) &&  isicon(dop->dopar[1],&m2) &&
X  (dop->dopar[2]==NULL || isicon(dop->dopar[2],&m3)) )
X	{
X	if(m3 > 0)
X		return(1 + (m2-m1)/m3);
X	}
Xelse	execerr("nonconstant implied do", "");
Xreturn(1);
X}
X
X
X
Xioop(s)
Xchar *s;
X{
Xif( equals(s, "backspace") )
X	return(FBACKSPACE);
Xif( equals(s, "rewind") )
X	return(FREWIND);
Xif( equals(s, "endfile") )
X	return(FENDFILE);
Xreturn(0);
X}
X
X
X
X
Xptr exioop(p, errcheck)
Xregister struct exprblock *p;
Xint errcheck;
X{
Xregister ptr q, t;
X
Xif( (q = p->rightp)==NULL || (q = q->leftp)==NULL  )
X	{
X	execerr("bad I/O operation", "");
X	return(NULL);
X	}
Xq = simple(LVAL, cpexpr(q->datap) );
X
Xexlab(0);
Xputic(ICKEYWORD, ioop(p->leftp->sthead->namep));
X
Xif(errcheck)
X	{
X	if(tailor.errmode != IOERRFORT77)
X		{
X		execerr("cannot test value of IOOP without ftn77", "");
X		return( errnode() );
X		}
X	putic(ICOP, OPLPAR);
X	prexpr(q);
X	putic(ICOP, OPCOMMA);
X	putsii(ICCONST, "iostat =");
X	prexpr(cpexpr( t = gent(TYINT,PNULL)));
X	putic(ICOP, OPRPAR);
X	return( t );
X	}
Xelse	{
X	putic(ICBLANK, 1);
X	prexpr(q);
X	}
X}

echo x - lex.c
sed -e 's/^X//' > lex.c << ''
X# include "stdio.h"
X# define U(x) x
X# define NLSTATE yyprevious=YYNEWLINE
X# define BEGIN yybgin = yysvec + 1 +
X# define INITIAL 0
X# define YYLERR yysvec
X# define YYSTATE (yyestate-yysvec-1)
X# define YYOPTIM 1
X# define YYLMAX 200
X# define output(c) putc(c,yyout)
X# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):efgetc)==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
X# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
X# define yymore() (yymorfg=1)
X# define ECHO fprintf(yyout, "%s",yytext)
X# define REJECT { nstr = yyreject(); goto yyfussy;}
Xint yyleng; extern char yytext[];
Xint yymorfg;
Xextern char *yysptr, yysbuf[];
Xint yytchar;
XFILE *yyin ={stdin}, *yyout ={stdout};
Xextern int yylineno;
Xstruct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
Xstruct yysvf *yyestate;
Xextern struct yysvf yysvec[], *yybgin;
X# define DOTSON 2
X#include <ctype.h>
X#include "defs"
X#include "tokdefs"
X
Xtypedef union { int ival; ptr pval; } YYSTYPE;
Xextern YYSTYPE yylval;
XYYSTYPE prevl;
Xint prevv;
Xchar *copys();
Xstatic ptr p;
Xstatic ptr q;
Xstatic FILE *fd;
Xstatic int quoted, k;
Xstatic int rket	= 0;
XFILE *opincl();
Xptr mkdef(), mkcomm(), mkname(), mkimcon();
X
X#define RET(x)	{ RETI(x,x);  }
X
X#define RETL(yv,yl) {yylval=prevl=yl;igeol=comneed=0;return(prevv=yv); }
X#define RETP(yv,yl) {yylval.pval=prevl.pval=yl;igeol=comneed=0;return(prevv=yv); }
X#define RETI(yv,yl) {yylval.ival=prevl.ival=yl;igeol=comneed=0;return(prevv=yv); }
X#define REL(n)  {  RETI(RELOP, OPREL+n);}
X#define AS(n)  {  RETI(ASGNOP, OPASGN+n); }
X#define RETC(x) { RETP(CONST, mkconst(x,yytext) );  }
X#define RETZ(x) { yytext[yyleng-1] = '\0'; RETP(CONST, mkimcon(x,yytext) ); }
X
X# define YYNEWLINE 10
Xyylex(){
Xint nstr; extern int yyprevious;
Xif(pushlex)
X	if(pushlex==1)
X		{
X		pushlex = 2;
X		yylval.ival = 0;
X		return(EOS);
X		}
X	else	{
X		pushlex = 0;
X		if(rket == 2)
X			rket = 1;
X		else	RETL(prevv,prevl);
X		}
Xif(rket > 0)
X	{
X	if(rket==1)
X		{
X		rket = 2;
X		RET(RBRACK);
X		}
X	else	{
X		rket = 0;
X		RET(EOS);
X		}
X	}
Xif(eofneed) return(0);
Xif(forcerr) return(-1);
Xwhile((nstr = yylook()) >= 0)
Xyyfussy: switch(nstr){
Xcase 0:
Xif(yywrap()) return(0); break;
Xcase 1:
X{
X		   lower(yytext);
X		   if(lettneed && yyleng==1)
X			{ RETI(LETTER, yytext[0]); }
X		   else if(defneed)
X			{
X			register char *q1, *q2;
X			for(q2=q1=yytext+yyleng+1 ; (*q1 = efgetc)!='\n' ; ++q1)
X				;
X			*q1 = '\0';
X			p = mkdef(yytext, q2);
X			defneed = 0;
X			++yylineno;
X			unput('\n');
X			}
X		   else if(optneed)
X			{ RETP(OPTNAME, copys(yytext)); }
X		   else if(comneed && ( (q=name(yytext,1))==NULL || q->tag!=TDEFINE) )
X			{ RETP(COMNAME, mkcomm(yytext) ); }
X		   else if(q = name(yytext,1)) switch(q->tag)
X			{
X			case TDEFINE:
X				filelines[filedepth] = yylineno;
X				filemacs[filedepth] = efmacp;
X				pushchars[filedepth] = (yysptr>yysbuf?
X						*--yysptr : -1);
X				if(++filedepth >= MAXINCLUDEDEPTH)
X					fatal("macro or include too deep");
X				filelines[filedepth] = yylineno = 1;
X				efmacp = q->varp->valp;
X				filenames[filedepth] = NULL;
X				break;	/*now process new input */
X
X			case TSTRUCT:
X				RETP(STRUCTNAME, q);
X
X			case TNAME:
X				RETP(NAME, q);
X
X			case TKEYWORD:
X				if(q->subtype == END)
X					{
X					register int c;
X					eofneed = YES;
X					while((c=input())!=';'&&c!='\n'&&c!=EOF)
X						;
X					NLSTATE;
X					}
X				RET(q->subtype);
X
X			default:
X				fatal1("lex: impossible type code %d", q->tag);
X			}
X		   else  RETP(NAME, mkname(yytext) );
X		}
Xbreak;
Xcase 2:
XRET(COMMA);
Xbreak;
Xcase 3:
XRET(EOS);
Xbreak;
Xcase 4:
XRET(LPAR);
Xbreak;
Xcase 5:
XRET(RPAR);
Xbreak;
Xcase 6:
Xcase 7:
XRET(LBRACK);
Xbreak;
Xcase 8:
Xcase 9:
X{ if(iobrlevel>0) RET(RBRACK); rket = 1;  RET(EOS); }
Xbreak;
Xcase 10:
XRET(COMMA);
Xbreak;
Xcase 11:
XRET(COLON);
Xbreak;
Xcase 12:
XRET(REPOP);
Xbreak;
Xcase 13:
Xcase 14:
XRETI(OR,OPOR);
Xbreak;
Xcase 15:
Xcase 16:
XRETI(OR,OP2OR);
Xbreak;
Xcase 17:
Xcase 18:
XRETI(AND,OPAND);
Xbreak;
Xcase 19:
Xcase 20:
XRETI(AND,OP2AND);
Xbreak;
Xcase 21:
Xcase 22:
XRETI(NOT,OPNOT);
Xbreak;
Xcase 23:
XRETI(NOT,OPNOT);
Xbreak;
Xcase 24:
Xcase 25:
XREL(OPLT);
Xbreak;
Xcase 26:
Xcase 27:
XREL(OPLE);
Xbreak;
Xcase 28:
Xcase 29:
XREL(OPGT);
Xbreak;
Xcase 30:
Xcase 31:
XREL(OPGE);
Xbreak;
Xcase 32:
Xcase 33:
XREL(OPEQ);
Xbreak;
Xcase 34:
Xcase 35:
Xcase 36:
XREL(OPNE);
Xbreak;
Xcase 37:
XRET(ARROW);
Xbreak;
Xcase 38:
XRET(QUALOP);
Xbreak;
Xcase 39:
XRETI(ADDOP, OPPLUS);
Xbreak;
Xcase 40:
XRETI(ADDOP, OPMINUS);
Xbreak;
Xcase 41:
XRETI(MULTOP, OPSTAR);
Xbreak;
Xcase 42:
XRETI(MULTOP, OPSLASH);
Xbreak;
Xcase 43:
Xcase 44:
XRETI(POWER, OPPOWER);
Xbreak;
Xcase 45:
XRETI(DOUBLEADDOP, OPPLUS);
Xbreak;
Xcase 46:
XRETI(DOUBLEADDOP, OPMINUS);
Xbreak;
Xcase 47:
XAS(OPASGN);
Xbreak;
Xcase 48:
XAS(OPPLUS);
Xbreak;
Xcase 49:
XAS(OPMINUS);
Xbreak;
Xcase 50:
XAS(OPSTAR);
Xbreak;
Xcase 51:
XAS(OPSLASH);
Xbreak;
Xcase 52:
Xcase 53:
XAS(OPPOWER);
Xbreak;
Xcase 54:
XAS(OPAND);
Xbreak;
Xcase 55:
XAS(OP2AND);
Xbreak;
Xcase 56:
XAS(OPOR);
Xbreak;
Xcase 57:
XAS(OP2OR);
Xbreak;
Xcase 58:
Xcase 59:
X{ yytext[yyleng-1] = '\0'; p = mkconst(TYCHAR,yytext+1);
X		  RETP(CONST,p); }
Xbreak;
Xcase 60:
X{ /* nh construct */
X		int i, n;  char c;
X		yytext[yyleng-1] = '\0';  n = convci(yytext);
X		for(i = 0; i<n ; ++i)
X			if( (c=yytext[i]=input()) == '\n' || c=='\0') break;
X		yytext[i] = '\0';
X		p = mkconst(TYCHAR,yytext);
X		p->vtypep = mkint(i);
X		RETP(CONST, p);
X		}
Xbreak;
Xcase 61:
X	RETC(TYINT);
Xbreak;
Xcase 62:
Xcase 63:
XRETC(TYREAL);
Xbreak;
Xcase 64:
Xcase 65:
XRETC(TYREAL);
Xbreak;
Xcase 66:
Xcase 67:
XRETC(TYLREAL);
Xbreak;
Xcase 68:
X	{ yytext[yyleng-1] = '.';
X		  RETP(CONST,mkimcon(TYCOMPLEX,yytext)); }
Xbreak;
Xcase 69:
Xcase 70:
XRETZ(TYCOMPLEX);
Xbreak;
Xcase 71:
Xcase 72:
XRETZ(TYCOMPLEX);
Xbreak;
Xcase 73:
Xcase 74:
XRETZ(TYLCOMPLEX);
Xbreak;
Xcase 75:
X{ if(! nocommentflag) goto litline; }
Xbreak;
Xcase 76:
X{ if(thisexec) thisexec->nftnst += 2;
X	  if(inproc)
X		{
X		unput('\n');
X		RETP(ESCAPE, copys(yytext));
X		}
X
X	litline:	p = mkchain( copys(yytext), CHNULL);
X			if(inproc==0 && yytext[0]=='%')
X				prevcomments = hookup(prevcomments, p);
X			else
X				comments =  hookup(comments,p);
X	}
Xbreak;
Xcase 77:
X;
Xbreak;
Xcase 78:
X;
Xbreak;
Xcase 79:
X;
Xbreak;
Xcase 80:
X;
Xbreak;
Xcase 81:
X{ if(igeol) { igeol=0; prevv = NEWLINE; }
X	  else if(prevv>=NAME || prevv==RPAR || prevv==RBRACK
X			|| prevv== -1 || prevv==QUALOP)
X		RET(EOS); }
Xbreak;
Xcase 82:
X{ char * linerr();
X	  fprintf(diagfile, "Bad input character %c %s\n", yytext[0], linerr());
X	  ++nerrs;
X	}
Xbreak;
Xcase 83:
X{ /* Include statement */
X	char *q1;
X	register char *q2;
X	for(q1=yytext ; *q1==' ' || *q1=='\t' ; ++q1) ;
X	quoted = NO;
X	for(q1 += 7 ; *q1==' ' || *q1=='\t' ||
X		*q1=='\'' || *q1=='"' || *q1=='(' ; ++q1 )
X			if(*q1=='"' || *q1=='\'')
X				quoted = YES;
X	for(q2=q1 ; *q2!='\0' &&  *q2!=' ' && *q2!='\n' &&
X		*q2!='\'' && *q2!='"' && *q2!=')' ; ++q2 )
X			;
X	*q2 = '\0';
X	if( ! quoted)
X		for(k=0; (q = name(q1,1)) && q->tag==TDEFINE ; ++k)
X			{
X			if(k > MAXINCLUDEDEPTH)
X				fatal1("Macros too deep for %s", yytext);
X			q1 = q->varp->valp;
X			}
X	if( (fd = opincl(&q1)) == NULL)
X		{
X		fprintf(diagfile, "Cannot open file %s.  Stop.\n", q1);
X		exit(2);
X		}
X	filelines[filedepth] = yylineno;
X	pushchars[filedepth] = '\n';
X	if(++filedepth >= MAXINCLUDEDEPTH)
X		fatal("macro or include too deep");
X	fileptrs[filedepth] = yyin = fd;
X	filenames[filedepth] = copys(q1);
X	filelines[filedepth] = yylineno = 1;
X	filemacs[filedepth] = NULL;
X	}
Xbreak;
Xcase -1:
Xbreak;
Xdefault:
Xfprintf(yyout,"bad switch yylook %d",nstr);
X} return(0); }
X/* end of yylex */
X
Xyywrap()
X{
Xif(filedepth == 0)
X	{
X	ateof = 1;
X	return(1);
X	}
X
Xif(efmacp == 0)
X	{
X	fclose(yyin);
X	cfree(filenames[filedepth]);
X	}
X
X--filedepth;
Xif( filemacs[filedepth] )
X	efmacp = filemacs[filedepth];
Xelse	{
X	yyin = fileptrs[filedepth];
X	efmacp = 0;
X	}
Xyylineno = filelines[filedepth];
Xif(pushchars[filedepth] != -1)
X	unput( pushchars[filedepth] );
Xreturn(0);
X}
X
X
X
Xlower(s)	/* replace upper with lower case letters */
Xregister char *s;
X{
Xregister char *t;
Xfor(t=s ; *t ; ++t)
X	if( isupper(*t) )
X		*s++ = tolower(*t);
X	else if(*t != '_')
X		*s++ = *t;
X}
X
X
X
X
Xsetdot(k)
Xint k;
X{
Xif(k)
X	BEGIN DOTSON;
Xelse	BEGIN 0;
X}
X
X
X
X
XFILE *opincl(namep)
Xchar **namep;
X{
X#ifndef unix
X	return( fopen(*namep, "r") );
X#else
X
X	/* On Unix, follow the C include conventions */
X	
X	register char *s, *lastslash;
X	char *dir, *name, temp[100];
X	int i;
X	FILE *fp;
X	
X	name = *namep;
X	if(name[0] == '/')
X		return( fopen(name, "r") );
X	
X	dir = basefile;
X	for(i = filedepth ; i>=0 ; --i)
X		if( filemacs[i] == NULL)
X			{
X			dir = filenames[i];
X			break;
X			}
X
X	lastslash = NULL;
X	for(s = dir ; *s ; ++s)
X		if(*s == '/')
X			lastslash = s;
X	if(lastslash)
X		{
X		*lastslash = '\0';
X		sprintf(temp, "%s/%s", dir, name);
X		*lastslash = '/';
X		if( fp = fopen(temp, "r") )
X			*namep = temp;
X		}
X	else
X		fp = fopen(name, "r");
X	
X	if(fp == NULL)
X		{
X		sprintf(temp, "/usr/include/%s", name);
X		fp = fopen(temp, "r");
X		*namep = temp;
X		}
X	return(fp);
X
X#endif
X}
X
Xint yyvstop[] ={
X0,
X
X82,
X0,
X
X78,
X82,
X0,
X
X81,
X0,
X
X79,
X82,
X0,
X
X77,
X82,
X0,
X
X23,
X82,
X0,
X
X82,
X0,
X
X75,
X82,
X0,
X
X12,
X82,
X0,
X
X18,
X82,
X0,
X
X82,
X0,
X
X4,
X82,
X0,
X
X5,
X82,
X0,
X
X41,
X82,
X0,
X
X39,
X82,
X0,
X
X2,
X10,
X82,
X0,
X
X40,
X82,
X0,
X
X38,
X82,
X0,
X
X42,
X82,
X0,
X
X61,
X82,
X0,
X
X11,
X82,
X0,
X
X3,
X82,
X0,
X
X25,
X82,
X0,
X
X47,
X82,
X0,
X
X29,
X82,
X0,
X
X1,
X82,
X0,
X
X6,
X82,
X0,
X
X8,
X82,
X0,
X
X44,
X82,
X0,
X
X82,
X0,
X
X7,
X82,
X0,
X
X14,
X82,
X0,
X
X9,
X82,
X0,
X
X22,
X82,
X0,
X
X78,
X82,
X0,
X
X77,
X82,
X0,
X
X76,
X82,
X0,
X
X1,
X82,
X0,
X
X38,
X82,
X0,
X
X36,
X0,
X
X59,
X0,
X
X75,
X0,
X
X20,
X0,
X
X54,
X0,
X
X58,
X0,
X
X43,
X0,
X
X50,
X0,
X
X45,
X0,
X
X48,
X0,
X
X46,
X0,
X
X49,
X0,
X
X37,
X0,
X
X63,
X0,
X
X51,
X0,
X
X62,
X0,
X
X61,
X0,
X
X60,
X0,
X
X68,
X0,
X
X27,
X0,
X
X33,
X0,
X
X31,
X0,
X
X1,
X0,
X
X53,
X0,
X
X80,
X0,
X
X56,
X0,
X
X16,
X0,
X
X35,
X0,
X
X76,
X0,
X
X1,
X0,
X
X55,
X0,
X
X52,
X0,
X
X70,
X0,
X
X62,
X63,
X0,
X
X69,
X0,
X
X66,
X0,
X
X64,
X0,
X
X57,
X0,
X
X1,
X0,
X
X67,
X0,
X
X65,
X0,
X
X69,
X70,
X0,
X
X73,
X0,
X
X71,
X0,
X
X1,
X0,
X
X32,
X0,
X
X30,
X0,
X
X28,
X0,
X
X26,
X0,
X
X24,
X0,
X
X34,
X0,
X
X13,
X0,
X
X74,
X0,
X
X72,
X0,
X
X66,
X67,
X0,
X
X64,
X65,
X0,
X
X1,
X0,
X
X17,
X0,
X
X15,
X0,
X
X21,
X0,
X
X73,
X74,
X0,
X
X71,
X72,
X0,
X
X1,
X0,
X
X19,
X0,
X
X1,
X0,
X
X83,
X0,
X0};
X# define YYTYPE int
Xstruct yywork { YYTYPE verify, advance; } yycrank[] ={
X0,0,	0,0,	1,5,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	1,6,	1,7,	
X45,0,	1,8,	47,0,	34,72,	
X34,73,	50,0,	79,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	1,9,	1,10,	1,11,	
X1,12,	1,13,	34,72,	1,14,	
X1,15,	1,16,	1,17,	1,18,	
X1,19,	1,20,	1,21,	1,22,	
X1,23,	1,24,	0,0,	0,0,	
X14,48,	19,54,	0,0,	0,0,	
X0,0,	18,52,	105,127,	1,25,	
X1,26,	1,27,	1,28,	1,29,	
X10,44,	23,60,	1,30,	1,30,	
X1,30,	1,30,	1,30,	19,55,	
X1,30,	1,30,	1,30,	14,49,	
X18,53,	1,30,	27,67,	1,30,	
X1,30,	2,39,	1,30,	1,30,	
X2,8,	1,30,	1,30,	28,68,	
X29,69,	33,71,	38,76,	36,74,	
X1,31,	48,88,	1,32,	1,33,	
X1,34,	42,80,	39,77,	52,89,	
X75,99,	106,128,	107,129,	78,100,	
X2,40,	2,10,	80,101,	2,12,	
X2,13,	2,41,	2,14,	108,130,	
X2,16,	2,17,	2,18,	109,131,	
X2,20,	2,21,	2,22,	2,23,	
X21,56,	39,77,	110,132,	3,8,	
X1,35,	1,36,	1,37,	1,38,	
X81,102,	42,80,	2,25,	2,26,	
X2,27,	2,28,	2,29,	78,100,	
X21,57,	21,58,	80,101,	112,134,	
X124,143,	126,145,	133,146,	3,9,	
X3,10,	2,42,	3,12,	3,13,	
X144,151,	3,14,	0,0,	3,16,	
X3,17,	3,18,	36,75,	3,20,	
X3,21,	3,43,	3,23,	83,105,	
X81,102,	87,112,	39,78,	2,31,	
X0,0,	2,32,	2,33,	96,120,	
X0,0,	3,25,	3,26,	3,27,	
X3,28,	3,29,	22,59,	22,59,	
X22,59,	22,59,	22,59,	22,59,	
X22,59,	22,59,	22,59,	22,59,	
X0,0,	0,0,	0,0,	98,121,	
X0,0,	4,39,	0,0,	83,105,	
X4,8,	87,112,	39,78,	2,35,	
X2,36,	2,37,	2,38,	96,120,	
X82,103,	0,0,	3,31,	0,0,	
X3,32,	3,33,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X4,40,	4,10,	82,104,	4,12,	
X4,13,	4,41,	4,14,	98,121,	
X4,16,	4,17,	4,18,	0,0,	
X4,20,	4,21,	4,43,	4,23,	
X59,90,	59,91,	84,106,	0,0,	
X82,103,	59,92,	3,35,	3,36,	
X3,37,	3,38,	4,25,	4,26,	
X4,27,	4,28,	4,29,	11,45,	
X0,0,	84,107,	82,104,	86,110,	
X85,108,	0,0,	100,122,	11,45,	
X11,0,	4,42,	93,117,	93,118,	
X101,123,	86,111,	0,0,	93,119,	
X59,90,	59,91,	84,106,	85,109,	
X102,124,	59,92,	103,125,	104,126,	
X0,0,	0,0,	111,133,	4,31,	
X0,0,	4,32,	4,33,	0,0,	
X11,46,	84,107,	0,0,	86,110,	
X85,108,	11,45,	100,122,	0,0,	
X114,135,	11,45,	93,117,	93,118,	
X101,123,	86,111,	11,45,	93,119,	
X12,47,	0,0,	0,0,	85,109,	
X102,124,	116,136,	103,125,	104,126,	
X12,47,	12,0,	111,133,	4,35,	
X4,36,	4,37,	4,38,	11,45,	
X11,45,	11,45,	11,45,	11,45,	
X122,141,	11,45,	11,45,	11,45,	
X114,135,	0,0,	11,45,	123,142,	
X11,45,	11,45,	125,144,	11,45,	
X11,45,	12,47,	11,45,	11,45,	
X0,0,	116,136,	12,47,	0,0,	
X0,0,	138,147,	12,47,	0,0,	
X140,148,	11,45,	0,0,	12,47,	
X0,0,	15,50,	0,0,	0,0,	
X122,141,	141,149,	142,150,	0,0,	
X149,152,	15,50,	15,0,	123,142,	
X150,153,	0,0,	125,144,	0,0,	
X12,47,	12,47,	12,47,	12,47,	
X12,47,	0,0,	12,47,	12,47,	
X12,47,	138,147,	0,0,	12,47,	
X140,148,	12,47,	12,47,	152,154,	
X12,47,	12,47,	15,50,	12,47,	
X12,47,	141,149,	142,150,	15,51,	
X149,152,	0,0,	0,0,	15,50,	
X150,153,	63,95,	12,47,	63,95,	
X15,50,	0,0,	63,96,	63,96,	
X63,96,	63,96,	63,96,	63,96,	
X63,96,	63,96,	63,96,	63,96,	
X0,0,	0,0,	0,0,	152,154,	
X0,0,	15,50,	15,50,	15,50,	
X15,50,	15,50,	0,0,	15,50,	
X15,50,	15,50,	0,0,	0,0,	
X15,50,	0,0,	15,50,	15,50,	
X0,0,	15,50,	15,50,	0,0,	
X15,50,	15,50,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	24,61,	15,50,	
X24,62,	24,62,	24,62,	24,62,	
X24,62,	24,62,	24,62,	24,62,	
X24,62,	24,62,	95,96,	95,96,	
X95,96,	95,96,	95,96,	95,96,	
X95,96,	95,96,	95,96,	95,96,	
X24,63,	24,64,	0,0,	0,0,	
X24,65,	24,66,	64,97,	0,0,	
X64,97,	0,0,	0,0,	64,98,	
X64,98,	64,98,	64,98,	64,98,	
X64,98,	64,98,	64,98,	64,98,	
X64,98,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	0,0,	
X24,63,	24,64,	0,0,	0,0,	
X24,65,	24,66,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X0,0,	0,0,	0,0,	0,0,	
X30,70,	0,0,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X30,70,	30,70,	30,70,	30,70,	
X41,79,	0,0,	0,0,	0,0,	
X0,0,	90,113,	0,0,	90,113,	
X41,79,	41,0,	90,114,	90,114,	
X90,114,	90,114,	90,114,	90,114,	
X90,114,	90,114,	90,114,	90,114,	
X97,98,	97,98,	97,98,	97,98,	
X97,98,	97,98,	97,98,	97,98,	
X97,98,	97,98,	0,0,	0,0,	
X0,0,	41,79,	0,0,	0,0,	
X0,0,	0,0,	41,79,	0,0,	
X0,0,	0,0,	41,79,	91,115,	
X0,0,	91,115,	0,0,	41,79,	
X91,116,	91,116,	91,116,	91,116,	
X91,116,	91,116,	91,116,	91,116,	
X91,116,	91,116,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X41,79,	41,79,	41,79,	41,79,	
X41,79,	0,0,	41,79,	41,79,	
X41,79,	0,0,	0,0,	41,79,	
X0,0,	41,79,	41,79,	0,0,	
X41,79,	41,79,	0,0,	41,79,	
X41,79,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	41,79,	43,59,	
X43,59,	43,59,	43,59,	43,59,	
X43,59,	43,59,	43,59,	43,59,	
X43,59,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X43,81,	0,0,	43,82,	0,0,	
X43,83,	0,0,	43,84,	0,0,	
X0,0,	0,0,	0,0,	43,85,	
X0,0,	43,86,	43,87,	0,0,	
X0,0,	0,0,	0,0,	61,93,	
X61,93,	61,93,	61,93,	61,93,	
X61,93,	61,93,	61,93,	61,93,	
X61,93,	0,0,	0,0,	0,0,	
X43,81,	0,0,	43,82,	0,0,	
X43,83,	0,0,	43,84,	61,63,	
X61,64,	0,0,	0,0,	43,85,	
X61,94,	43,86,	43,87,	113,114,	
X113,114,	113,114,	113,114,	113,114,	
X113,114,	113,114,	113,114,	113,114,	
X113,114,	115,116,	115,116,	115,116,	
X115,116,	115,116,	115,116,	115,116,	
X115,116,	115,116,	115,116,	0,0,	
X0,0,	0,0,	0,0,	61,63,	
X61,64,	117,137,	0,0,	117,137,	
X61,94,	0,0,	117,138,	117,138,	
X117,138,	117,138,	117,138,	117,138,	
X117,138,	117,138,	117,138,	117,138,	
X118,139,	0,0,	118,139,	0,0,	
X0,0,	118,140,	118,140,	118,140,	
X118,140,	118,140,	118,140,	118,140,	
X118,140,	118,140,	118,140,	137,138,	
X137,138,	137,138,	137,138,	137,138,	
X137,138,	137,138,	137,138,	137,138,	
X137,138,	139,140,	139,140,	139,140,	
X139,140,	139,140,	139,140,	139,140,	
X139,140,	139,140,	139,140,	153,154,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	153,154,	
X153,155,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X153,154,	0,0,	0,0,	0,0,	
X0,0,	153,154,	0,0,	0,0,	
X0,0,	153,154,	0,0,	0,0,	
X0,0,	0,0,	153,153,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	153,153,	
X153,153,	153,153,	153,153,	153,153,	
X0,0,	153,153,	153,153,	153,153,	
X0,0,	0,0,	153,153,	0,0,	
X153,153,	153,153,	154,154,	153,153,	
X153,153,	0,0,	153,153,	153,153,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	153,153,	0,0,	154,154,	
X154,154,	154,154,	154,154,	154,154,	
X0,0,	154,154,	154,154,	154,154,	
X0,0,	0,0,	154,154,	0,0,	
X154,154,	154,154,	0,0,	154,154,	
X154,154,	0,0,	154,154,	154,154,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	154,154,	0,0,	0,0,	
X0,0};
Xstruct yysvf yysvec[] ={
X0,	0,	0,
Xyycrank+-1,	0,		0,	
Xyycrank+-72,	yysvec+1,	0,	
Xyycrank+-111,	yysvec+1,	0,	
Xyycrank+-180,	yysvec+1,	0,	
Xyycrank+0,	0,		yyvstop+1,
Xyycrank+0,	0,		yyvstop+3,
Xyycrank+0,	0,		yyvstop+6,
Xyycrank+0,	0,		yyvstop+8,
Xyycrank+0,	0,		yyvstop+11,
Xyycrank+3,	0,		yyvstop+14,
Xyycrank+-242,	0,		yyvstop+17,
Xyycrank+-291,	0,		yyvstop+19,
Xyycrank+0,	0,		yyvstop+22,
Xyycrank+14,	0,		yyvstop+25,
Xyycrank+-340,	0,		yyvstop+28,
Xyycrank+0,	0,		yyvstop+30,
Xyycrank+0,	0,		yyvstop+33,
Xyycrank+15,	0,		yyvstop+36,
Xyycrank+10,	0,		yyvstop+39,
Xyycrank+0,	0,		yyvstop+42,
Xyycrank+75,	0,		yyvstop+46,
Xyycrank+126,	0,		yyvstop+49,
Xyycrank+4,	0,		yyvstop+52,
Xyycrank+388,	0,		yyvstop+55,
Xyycrank+0,	0,		yyvstop+58,
Xyycrank+0,	0,		yyvstop+61,
Xyycrank+17,	0,		yyvstop+64,
Xyycrank+26,	0,		yyvstop+67,
Xyycrank+27,	0,		yyvstop+70,
Xyycrank+429,	0,		yyvstop+73,
Xyycrank+0,	0,		yyvstop+76,
Xyycrank+0,	0,		yyvstop+79,
Xyycrank+28,	0,		yyvstop+82,
Xyycrank+6,	0,		yyvstop+85,
Xyycrank+0,	0,		yyvstop+87,
Xyycrank+30,	0,		yyvstop+90,
Xyycrank+0,	0,		yyvstop+93,
Xyycrank+29,	0,		yyvstop+96,
Xyycrank+89,	0,		yyvstop+99,
Xyycrank+0,	yysvec+39,	yyvstop+102,
Xyycrank+-551,	0,		yyvstop+105,
Xyycrank+19,	yysvec+30,	yyvstop+108,
Xyycrank+599,	0,		yyvstop+111,
Xyycrank+0,	0,		yyvstop+114,
Xyycrank+-2,	yysvec+11,	0,	
Xyycrank+0,	0,		yyvstop+116,
Xyycrank+-4,	yysvec+12,	yyvstop+118,
Xyycrank+32,	0,		yyvstop+120,
Xyycrank+0,	0,		yyvstop+122,
Xyycrank+-7,	yysvec+15,	0,	
Xyycrank+0,	0,		yyvstop+124,
Xyycrank+38,	0,		yyvstop+126,
Xyycrank+0,	0,		yyvstop+128,
Xyycrank+0,	0,		yyvstop+130,
Xyycrank+0,	0,		yyvstop+132,
Xyycrank+0,	0,		yyvstop+134,
Xyycrank+0,	0,		yyvstop+136,
Xyycrank+0,	0,		yyvstop+138,
Xyycrank+160,	yysvec+22,	yyvstop+140,
Xyycrank+0,	0,		yyvstop+142,
Xyycrank+635,	0,		yyvstop+144,
Xyycrank+0,	yysvec+24,	yyvstop+146,
Xyycrank+342,	0,		0,	
Xyycrank+419,	0,		0,	
Xyycrank+0,	0,		yyvstop+148,
Xyycrank+0,	0,		yyvstop+150,
Xyycrank+0,	0,		yyvstop+152,
Xyycrank+0,	0,		yyvstop+154,
Xyycrank+0,	0,		yyvstop+156,
Xyycrank+0,	yysvec+30,	yyvstop+158,
Xyycrank+0,	0,		yyvstop+160,
Xyycrank+0,	yysvec+34,	0,	
Xyycrank+0,	0,		yyvstop+162,
Xyycrank+0,	0,		yyvstop+164,
Xyycrank+39,	0,		yyvstop+166,
Xyycrank+0,	0,		yyvstop+168,
Xyycrank+0,	yysvec+39,	0,	
Xyycrank+25,	0,		0,	
Xyycrank+-8,	yysvec+41,	yyvstop+170,
Xyycrank+39,	yysvec+30,	yyvstop+172,
Xyycrank+50,	0,		0,	
Xyycrank+135,	0,		0,	
Xyycrank+78,	0,		0,	
Xyycrank+161,	0,		0,	
Xyycrank+179,	0,		0,	
Xyycrank+178,	0,		0,	
Xyycrank+79,	0,		0,	
Xyycrank+0,	0,		yyvstop+174,
Xyycrank+0,	0,		yyvstop+176,
Xyycrank+514,	0,		0,	
Xyycrank+552,	0,		0,	
Xyycrank+0,	0,		yyvstop+178,
Xyycrank+186,	yysvec+61,	yyvstop+180,
Xyycrank+0,	0,		yyvstop+183,
Xyycrank+398,	0,		0,	
Xyycrank+94,	yysvec+95,	yyvstop+185,
Xyycrank+524,	0,		0,	
Xyycrank+114,	yysvec+97,	yyvstop+187,
Xyycrank+0,	0,		yyvstop+189,
Xyycrank+183,	0,		0,	
Xyycrank+180,	yysvec+30,	yyvstop+191,
Xyycrank+196,	0,		0,	
Xyycrank+188,	0,		0,	
Xyycrank+185,	0,		0,	
Xyycrank+12,	0,		0,	
Xyycrank+55,	0,		0,	
Xyycrank+56,	0,		0,	
Xyycrank+65,	0,		0,	
Xyycrank+69,	0,		0,	
Xyycrank+76,	0,		0,	
Xyycrank+186,	0,		0,	
Xyycrank+93,	0,		0,	
Xyycrank+663,	0,		0,	
Xyycrank+211,	yysvec+113,	yyvstop+193,
Xyycrank+673,	0,		0,	
Xyycrank+224,	yysvec+115,	yyvstop+195,
Xyycrank+694,	0,		0,	
Xyycrank+709,	0,		0,	
Xyycrank+0,	0,		yyvstop+197,
Xyycrank+0,	0,		yyvstop+200,
Xyycrank+0,	0,		yyvstop+202,
Xyycrank+236,	0,		0,	
Xyycrank+234,	yysvec+30,	yyvstop+204,
Xyycrank+94,	0,		0,	
Xyycrank+254,	0,		0,	
Xyycrank+95,	0,		0,	
Xyycrank+0,	0,		yyvstop+206,
Xyycrank+0,	0,		yyvstop+208,
Xyycrank+0,	0,		yyvstop+210,
Xyycrank+0,	0,		yyvstop+212,
Xyycrank+0,	0,		yyvstop+214,
Xyycrank+0,	0,		yyvstop+216,
Xyycrank+96,	0,		0,	
Xyycrank+0,	0,		yyvstop+218,
Xyycrank+0,	0,		yyvstop+220,
Xyycrank+0,	0,		yyvstop+222,
Xyycrank+719,	0,		0,	
Xyycrank+260,	yysvec+137,	yyvstop+224,
Xyycrank+729,	0,		0,	
Xyycrank+263,	yysvec+139,	yyvstop+227,
Xyycrank+260,	0,		0,	
Xyycrank+278,	yysvec+30,	yyvstop+230,
Xyycrank+0,	0,		yyvstop+232,
Xyycrank+102,	0,		0,	
Xyycrank+0,	0,		yyvstop+234,
Xyycrank+0,	0,		yyvstop+236,
Xyycrank+0,	0,		yyvstop+238,
Xyycrank+0,	0,		yyvstop+241,
Xyycrank+280,	0,		0,	
Xyycrank+283,	yysvec+30,	yyvstop+244,
Xyycrank+0,	0,		yyvstop+246,
Xyycrank+302,	0,		0,	
Xyycrank+-786,	0,		yyvstop+248,
Xyycrank+-818,	yysvec+153,	0,	
Xyycrank+0,	0,		yyvstop+250,
X0,	0,	0};
Xstruct yywork *yytop = yycrank+913;
Xstruct yysvf *yybgin = yysvec+1;
Xchar yymatch[] ={
X00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,011 ,012 ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X011 ,01  ,'"' ,01  ,01  ,01  ,01  ,047 ,
X01  ,01  ,01  ,'+' ,01  ,'+' ,01  ,01  ,
X'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,
X'0' ,'0' ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,'A' ,'B' ,'C' ,'D' ,'E' ,'B' ,'G' ,
X'H' ,'I' ,'B' ,'B' ,'L' ,'B' ,'N' ,'O' ,
X'B' ,'Q' ,'R' ,'B' ,'T' ,'U' ,'B' ,'B' ,
X'B' ,'B' ,'B' ,01  ,01  ,01  ,01  ,'_' ,
X01  ,'A' ,'B' ,'C' ,'D' ,'E' ,'B' ,'G' ,
X'H' ,'I' ,'B' ,'B' ,'L' ,'B' ,'N' ,'O' ,
X'B' ,'Q' ,'R' ,'B' ,'T' ,'U' ,'B' ,'B' ,
X'B' ,'B' ,'B' ,01  ,01  ,01  ,01  ,01  ,
X0};
Xchar yyextra[] ={
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0};
X/*	ncform	4.1	83/08/11	*/
X
Xint yylineno =1;
X# define YYU(x) x
X# define NLSTATE yyprevious=YYNEWLINE
Xchar yytext[YYLMAX];
Xstruct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
Xchar yysbuf[YYLMAX];
Xchar *yysptr = yysbuf;
Xint *yyfnd;
Xextern struct yysvf *yyestate;
Xint yyprevious = YYNEWLINE;
Xyylook(){
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych;
X	struct yywork *yyr;
X# ifdef LEXDEBUG
X	int debug;
X# endif
X	char *yylastch;
X	/* start off machines */
X# ifdef LEXDEBUG
X	debug = 0;
X# endif
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
X# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
X# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank){		/* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
X			*yylastch++ = yych = input();
X		tryagain:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
X# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
X# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
X# endif
X				goto tryagain;
X				}
X# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			;
X			}
X# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
X# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
X# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
X		yylastch=yytext;
X# ifdef LEXDEBUG
X		if(debug)putchar('\n');
X# endif
X		}
X	}
Xyyback(p, m)
X	int *p;
X{
Xif (p==0) return(0);
Xwhile (*p)
X	{
X	if (*p++ == m)
X		return(1);
X	}
Xreturn(0);
X}
X	/* the following are only used in the lex library */
Xyyinput(){
X	return(input());
X	}
Xyyoutput(c)
X  int c; {
X	output(c);
X	}
Xyyunput(c)
X   int c; {
X	unput(c);
X	}

echo x - lex.l
sed -e 's/^X//' > lex.l << ''
X%Start DOTSON
X%{
X#include <ctype.h>
X#include "defs"
X#include "tokdefs"
X
Xtypedef union { int ival; ptr pval; } YYSTYPE;
Xextern YYSTYPE yylval;
XYYSTYPE prevl;
Xint prevv;
Xchar *copys();
Xstatic ptr p;
Xstatic ptr q;
Xstatic FILE *fd;
Xstatic int quoted, k;
Xstatic int rket	= 0;
XFILE *opincl();
Xptr mkdef(), mkcomm(), mkname(), mkimcon();
X
X#define RET(x)	{ RETI(x,x);  }
X
X#define RETL(yv,yl) {yylval=prevl=yl;igeol=comneed=0;return(prevv=yv); }
X#define RETP(yv,yl) {yylval.pval=prevl.pval=yl;igeol=comneed=0;return(prevv=yv); }
X#define RETI(yv,yl) {yylval.ival=prevl.ival=yl;igeol=comneed=0;return(prevv=yv); }
X#define REL(n)  {  RETI(RELOP, OPREL+n);}
X#define AS(n)  {  RETI(ASGNOP, OPASGN+n); }
X#define RETC(x) { RETP(CONST, mkconst(x,yytext) );  }
X#define RETZ(x) { yytext[yyleng-1] = '\0'; RETP(CONST, mkimcon(x,yytext) ); }
X
X%}
X
XD	[0-9]
Xd	[dD][+-]?[0-9]+
Xe	[eE][+-]?[0-9]+
Xi	[iI]
X
X%%
X
X[a-zA-Z][a-zA-Z0-9_]*	{
X		   lower(yytext);
X		   if(lettneed && yyleng==1)
X			{ RETI(LETTER, yytext[0]); }
X		   else if(defneed)
X			{
X			register char *q1, *q2;
X			for(q2=q1=yytext+yyleng+1 ; (*q1 = efgetc)!='\n' ; ++q1)
X				;
X			*q1 = '\0';
X			p = mkdef(yytext, q2);
X			defneed = 0;
X			++yylineno;
X			unput('\n');
X			}
X		   else if(optneed)
X			{ RETP(OPTNAME, copys(yytext)); }
X		   else if(comneed && ( (q=name(yytext,1))==NULL || q->tag!=TDEFINE) )
X			{ RETP(COMNAME, mkcomm(yytext) ); }
X		   else if(q = name(yytext,1)) switch(q->tag)
X			{
X			case TDEFINE:
X				filelines[filedepth] = yylineno;
X				filemacs[filedepth] = efmacp;
X				pushchars[filedepth] = (yysptr>yysbuf?
X						*--yysptr : -1);
X				if(++filedepth >= MAXINCLUDEDEPTH)
X					fatal("macro or include too deep");
X				filelines[filedepth] = yylineno = 1;
X				efmacp = q->varp->valp;
X				filenames[filedepth] = NULL;
X				break;	/*now process new input */
X
X			case TSTRUCT:
X				RETP(STRUCTNAME, q);
X
X			case TNAME:
X				RETP(NAME, q);
X
X			case TKEYWORD:
X				if(q->subtype == END)
X					{
X					register int c;
X					eofneed = YES;
X					while((c=input())!=';'&&c!='\n'&&c!=EOF)
X						;
X					NLSTATE;
X					}
X				RET(q->subtype);
X
X			default:
X				fatal1("lex: impossible type code %d", q->tag);
X			}
X		   else  RETP(NAME, mkname(yytext) );
X		}
X
X","	RET(COMMA);
X";"	RET(EOS);
X
X"("	RET(LPAR);
X")"	RET(RPAR);
X
X
X"["	|
X"{"	RET(LBRACK);
X
X"]"	|
X"}"	{ if(iobrlevel>0) RET(RBRACK); rket = 1;  RET(EOS); }
X
X","	RET(COMMA);
X":"	RET(COLON);
X
X"$"	RET(REPOP);
X
X<DOTSON>"."[oO][rR]"."	|
X"|"	RETI(OR,OPOR);
X<DOTSON>"."[cC][oO][rR]"."	|
X"||"	RETI(OR,OP2OR);
X<DOTSON>"."[aA][nN][dD]"."	|
X"&"	RETI(AND,OPAND);
X<DOTSON>"."[cC][aA][nN][dD]"."	|
X"&&"	RETI(AND,OP2AND);
X<DOTSON>"."[nN][oO][tT]"."	|
X"~"	RETI(NOT,OPNOT);
X"!"	RETI(NOT,OPNOT);
X
X<DOTSON>"."[lL][tT]"."	|
X"<"	REL(OPLT);
X<DOTSON>"."[lL][eE]"."	|
X"<="	REL(OPLE);
X<DOTSON>"."[gG][tT]"."	|
X">"	REL(OPGT);
X<DOTSON>"."[gG][eE]"."	|
X">="	REL(OPGE);
X<DOTSON>"."[eE][qQ]"."	|
X"=="	REL(OPEQ);
X<DOTSON>"."[nN][eE]"."	|
X"~="	|
X"!="	REL(OPNE);
X
X"->"	RET(ARROW);
X"."	RET(QUALOP);
X
X"+"	RETI(ADDOP, OPPLUS);
X"-"	RETI(ADDOP, OPMINUS);
X"*"	RETI(MULTOP, OPSTAR);
X"/"	RETI(MULTOP, OPSLASH);
X
X"**"	|
X"^"	RETI(POWER, OPPOWER);
X
X"++"	RETI(DOUBLEADDOP, OPPLUS);
X"--"	RETI(DOUBLEADDOP, OPMINUS);
X
X"="	AS(OPASGN);
X"+="	AS(OPPLUS);
X"-="	AS(OPMINUS);
X"*="	AS(OPSTAR);
X"/="	AS(OPSLASH);
X"**="	|
X"^="	AS(OPPOWER);
X
X"&="	AS(OPAND);
X"&&="	AS(OP2AND);
X"|="	AS(OPOR);
X"||="	AS(OP2OR);
X
X\'[^\n']*\'	|
X\"[^\n"]*\"	{ yytext[yyleng-1] = '\0'; p = mkconst(TYCHAR,yytext+1);
X		  RETP(CONST,p); }
X
X{D}+[hH]	{ /* nh construct */
X		int i, n;  char c;
X		yytext[yyleng-1] = '\0';  n = convci(yytext);
X		for(i = 0; i<n ; ++i)
X			if( (c=yytext[i]=input()) == '\n' || c=='\0') break;
X		yytext[i] = '\0';
X		p = mkconst(TYCHAR,yytext);
X		p->vtypep = mkint(i);
X		RETP(CONST, p);
X		}
X
X{D}+		RETC(TYINT);
X
X{D}+"."{D}*	|
X{D}*"."{D}+	RETC(TYREAL);
X
X{D}+"."?{D}*{e}	|
X{D}*"."{D}+{e}	RETC(TYREAL);
X
X{D}+"."?{D}*{d}	|
X{D}*"."{D}+{d}	RETC(TYLREAL);
X
X{D}+{i}		{ yytext[yyleng-1] = '.';
X		  RETP(CONST,mkimcon(TYCOMPLEX,yytext)); }
X
X{D}+"."{D}*{i}	|
X{D}*"."{D}+{i}	RETZ(TYCOMPLEX);
X
X{D}+"."?{D}*{e}{i}	|
X{D}*"."{D}+{e}{i}	RETZ(TYCOMPLEX);
X
X{D}+"."?{D}*{d}{i}	|
X{D}*"."{D}+{d}{i}	RETZ(TYLCOMPLEX);
X
X"#".*	{ if(! nocommentflag) goto litline; }
X
X^"%".*	{ if(thisexec) thisexec->nftnst += 2;
X	  if(inproc)
X		{
X		unput('\n');
X		RETP(ESCAPE, copys(yytext));
X		}
X
X	litline:	p = mkchain( copys(yytext), CHNULL);
X			if(inproc==0 && yytext[0]=='%')
X				prevcomments = hookup(prevcomments, p);
X			else
X				comments =  hookup(comments,p);
X	}
X
X" "	;
X\t	;
X\f	;
X
X"_"[ \t]*\n	;
X
X\n	{ if(igeol) { igeol=0; prevv = NEWLINE; }
X	  else if(prevv>=NAME || prevv==RPAR || prevv==RBRACK
X			|| prevv== -1 || prevv==QUALOP)
X		RET(EOS); }
X
X.	{ char * linerr();
X	  fprintf(diagfile, "Bad input character %c %s\n", yytext[0], linerr());
X	  ++nerrs;
X	}
X
X^[ \t]*[iI][nN][cC][lL][uU][dD][eE].*\n	{ /* Include statement */
X	char *q1;
X	register char *q2;
X	for(q1=yytext ; *q1==' ' || *q1=='\t' ; ++q1) ;
X	quoted = NO;
X	for(q1 += 7 ; *q1==' ' || *q1=='\t' ||
X		*q1=='\'' || *q1=='"' || *q1=='(' ; ++q1 )
X			if(*q1=='"' || *q1=='\'')
X				quoted = YES;
X	for(q2=q1 ; *q2!='\0' &&  *q2!=' ' && *q2!='\n' &&
X		*q2!='\'' && *q2!='"' && *q2!=')' ; ++q2 )
X			;
X	*q2 = '\0';
X	if( ! quoted)
X		for(k=0; (q = name(q1,1)) && q->tag==TDEFINE ; ++k)
X			{
X			if(k > MAXINCLUDEDEPTH)
X				fatal1("Macros too deep for %s", yytext);
X			q1 = q->varp->valp;
X			}
X	if( (fd = opincl(&q1)) == NULL)
X		{
X		fprintf(diagfile, "Cannot open file %s.  Stop.\n", q1);
X		exit(2);
X		}
X	filelines[filedepth] = yylineno;
X	pushchars[filedepth] = '\n';
X	if(++filedepth >= MAXINCLUDEDEPTH)
X		fatal("macro or include too deep");
X	fileptrs[filedepth] = yyin = fd;
X	filenames[filedepth] = copys(q1);
X	filelines[filedepth] = yylineno = 1;
X	filemacs[filedepth] = NULL;
X	}
X
X%%
X
Xyywrap()
X{
Xif(filedepth == 0)
X	{
X	ateof = 1;
X	return(1);
X	}
X
Xif(efmacp == 0)
X	{
X	fclose(yyin);
X	cfree(filenames[filedepth]);
X	}
X
X--filedepth;
Xif( filemacs[filedepth] )
X	efmacp = filemacs[filedepth];
Xelse	{
X	yyin = fileptrs[filedepth];
X	efmacp = 0;
X	}
Xyylineno = filelines[filedepth];
Xif(pushchars[filedepth] != -1)
X	unput( pushchars[filedepth] );
Xreturn(0);
X}
X
X
X
Xlower(s)	/* replace upper with lower case letters */
Xregister char *s;
X{
Xregister char *t;
Xfor(t=s ; *t ; ++t)
X	if( isupper(*t) )
X		*s++ = tolower(*t);
X	else if(*t != '_')
X		*s++ = *t;
X}
X
X
X
X
Xsetdot(k)
Xint k;
X{
Xif(k)
X	BEGIN DOTSON;
Xelse	BEGIN 0;
X}
X
X
X
X
XFILE *opincl(namep)
Xchar **namep;
X{
X#ifndef unix
X	return( fopen(*namep, "r") );
X#else
X
X	/* On Unix, follow the C include conventions */
X	
X	register char *s, *lastslash;
X	char *dir, *name, temp[100];
X	int i;
X	FILE *fp;
X	
X	name = *namep;
X	if(name[0] == '/')
X		return( fopen(name, "r") );
X	
X	dir = basefile;
X	for(i = filedepth ; i>=0 ; --i)
X		if( filemacs[i] == NULL)
X			{
X			dir = filenames[i];
X			break;
X			}
X
X	lastslash = NULL;
X	for(s = dir ; *s ; ++s)
X		if(*s == '/')
X			lastslash = s;
X	if(lastslash)
X		{
X		*lastslash = '\0';
X		sprintf(temp, "%s/%s", dir, name);
X		*lastslash = '/';
X		if( fp = fopen(temp, "r") )
X			*namep = temp;
X		}
X	else
X		fp = fopen(name, "r");
X	
X	if(fp == NULL)
X		{
X		sprintf(temp, "/usr/include/%s", name);
X		fp = fopen(temp, "r");
X		*namep = temp;
X		}
X	return(fp);
X
X#endif
X}
X

echo x - main.c
sed -e 's/^X//' > main.c << ''
Xstatic char xxxvers[ ] = "\n@(#)EFL VERSION 1.14,  19 AUGUST 1980";
X
X/* Compiler for the EFL Programming Language.  Written by:
X		Stuart I. Feldman
X		Bell Laboratories
X		Murray Hill, New Jersey
X*/
X
X
X/* Flags:
X	-d	EFL debugging output
X	-v	verbose (print out Pass numbers and memory limits)
X	-w	supress warning messages
X	-f	put Fortran output on appropriate .f files
X	-F	put Fortran code for input file x onto x.F
X	-e	divert diagnostic output to next argument
X	-#	do not pass comments through to output
X*/
X
X
X#include "defs"
X
Xint sysflag;
X
Xint nerrs	= 0;
Xint nbad	= 0;
Xint nwarns	= 0;
Xint stnos[MAXSTNO];
Xint nxtstno	= 0;
Xint constno	= 0;
Xint labno	= 0;
X
Xint dumpic	= NO;
Xint memdump	= NO;
Xint dbgflag	= NO;
Xint nowarnflag	= NO;
Xint nocommentflag	= NO;
Xint verbose	= NO;
Xint dumpcore	= NO;
Xchar msg[200];
X
Xstruct fileblock fcb[4];
Xstruct fileblock *iifilep;
Xstruct fileblock *ibfile	= &fcb[0];
Xstruct fileblock *icfile	= &fcb[1];
Xstruct fileblock *idfile	= &fcb[2];
Xstruct fileblock *iefile	= &fcb[3];
X
XFILE *diagfile	= {stderr};
XFILE *codefile	= {stdout};
XFILE *fileptrs[MAXINCLUDEDEPTH];
Xchar *filenames[MAXINCLUDEDEPTH];
Xchar *basefile;
Xint filelines[MAXINCLUDEDEPTH];
Xint filedepth	= 0;
Xchar *efmacp	= NULL;
Xchar *filemacs[MAXINCLUDEDEPTH];
Xint pushchars[MAXINCLUDEDEPTH];
Xint ateof	= NO;
X
Xint igeol	= NO;
Xint pushlex	= NO;
Xint eofneed	= NO;
Xint forcerr	 = NO;
Xint defneed	 = NO;
Xint prevbg	 = NO;
Xint comneed	 = NO;
Xint optneed	 = NO;
Xint lettneed	= NO;
Xint iobrlevel	= 0;
X
Xptr comments	= NULL;
Xptr prevcomments	= NULL;
Xptr genequivs	= NULL;
Xptr arrays	= NULL;
Xptr generlist	= NULL;
Xptr knownlist	= NULL;
X
Xptr thisexec;
Xptr thisctl;
Xchainp tempvarlist	= CHNULL;
Xchainp temptypelist	= CHNULL;
Xchainp hidlist	= CHNULL;
Xchainp commonlist	= CHNULL;
Xchainp gonelist	= CHNULL;
Xint blklevel	= 0;
Xint ctllevel	= 0;
Xint dclsect	= 0;
Xint instruct	= 0;
Xint inbound	= 0;
Xint inproc	= 0;
Xint ncases	= 0;
X
Xint graal	= 0;
Xptr procname	= NULL;
Xint procclass	= 0;
Xptr thisargs	= NULL;
X
Xint nhid[MAXBLOCKDEPTH];
Xint ndecl[MAXBLOCKDEPTH];
X
Xchar ftnames[MAXFTNAMES][7];
X
X
Xint neflnames	= 0;
X
Xint nftnames;
Xint nftnm0;
Xint impltype[26];
X
Xint ftnefl[NFTNTYPES]	= { TYINT, TYREAL, TYLOG, TYCOMPLEX, TYLREAL,
X				TYCHAR, TYLCOMPLEX };
Xint eflftn[NEFLTYPES];
Xint ftnmask[NFTNTYPES] 	= { 1, 2, 4, 8, 16, 32, 64 };
Xstruct tailoring tailor;
Xstruct system systab[] =
X	{
X		{ "portable", 0,	1, 10, 7, 15},
X		{ "unix", UNIX,	4, 10, 7, 15 },
X		{ "gcos", GCOS,	4, 10, 7, 15 },
X		{ "gcosbcd", GCOSBCD,	6, 10, 7, 15},
X		{ "cray", CRAY,	8, 10, 7, 15},
X		{ "ibm", IBM,	4, 10, 7, 15 },
X		{ NULL }
X	};
X
Xdouble fieldmax	= FIELDMAX;
X
Xint langopt	= 2;
Xint dotsopt	= 0;
Xint dbgopt	= 0;
Xint dbglevel	= 0;
X
Xint nftnch;
Xint nftncont;
Xint indifs[MAXINDIFS];
Xint nxtindif;
Xint afterif	= 0;
X
X#ifdef	gcos
X#	define BIT(n)	(1 << (36 - 1 - n) )
X#	define FORTRAN	BIT(1)
X#	define FDS	BIT(4)
X#	define EXEC	BIT(5)
X#	define FORM	BIT(14)
X#	define LNO	BIT(15)
X#	define BCD	BIT(16)
X#	define OPTZ	BIT(17)
X	int	compile	= FORTRAN | FDS;
X#endif
X
X
Xmain(argc,argv)
Xregister int argc;
Xregister char **argv;
X{
XFILE *fd;
Xregister char *p;
Xint neflnm0;
X
X#ifdef unix
X	int intrupt();
X	sysflag = UNIX;
X
X/*
X	meter();
X*/
X	if( (signal(2,1) & 01) == 0)
X		signal(2, intrupt);
X#endif
X
X#ifdef gcos
X/*
X	meter();
X*/
X	sysflag = (intss() ? GCOS : GCOSBCD);
X#endif
X
X
Xcrii();
X--argc;
X++argv;
Xtailinit(systab + sysflag);
X
Xwhile(argc>0 && ( (argv[0][0]=='-' && argv[0][1]!='\0') || eqlstrng(argv[0]) ))
X	{
X	if(argv[0][0] == '-')
X	    for(p = argv[0]+1 ; *p ; ++p) switch(*p)
X		{
X		case ' ':
X			break;
X
X		case 'd':
X		case 'D':
X			switch( *++p)
X				{
X				case '1':
X					dbgflag = YES;
X					break;
X				case '2':
X					setyydeb();
X					break;
X				case '3':
X					dumpcore = YES;
X					break;
X				case '4':
X					dumpic = YES;
X					break;
X				case 'm':
X				case 'M':
X					memdump = YES;
X					break;
X
X				default:
X					dbgflag = YES;
X					--p;
X					break;
X				}
X			break;
X
X		case 'w':
X		case 'W':
X			nowarnflag = YES;
X			break;
X
X		case 'v':
X		case 'V':
X			verbose = YES;
X			break;
X
X		case '#':
X			nocommentflag = YES;
X			break;
X
X		case 'C':
X		case 'c':
X			nocommentflag = NO;
X			break;
X
X#ifdef gcos
X		case 'O':
X		case 'o':
X			compile |= OPTZ;
X			break;
X
X		case 'E':
X		case 'e':
X			compile = 0;
X			break;
X#endif
X
X		default:
X			fprintf(diagfile, "Illegal EFL flag %c\n", *p);
X			exit(1);
X		}
X	--argc;
X	++argv;
X	}
X
Xkwinit();
Xgeninit();
Xknowninit();
Xinit();
Ximplinit();
Xneflnm0 = neflnames;
X
X#ifdef gcos
X	if( intss() )
X		compile = 0;
X	else
X		gcoutf();
X#endif
X
X/*	fprintf(diagfile, "EFL 1.10\n");	*/
X
Xif(argc==0)
X	{
X	filenames[0] = "-";
X	dofile(stdin);
X	}
Xelse
X	while(argc>0)
X		{
X		if( eqlstrng(argv[0]) )
X			{
X			--argc;
X			++argv;
X			continue;
X			}
X		if(argv[0][0]=='-' && argv[0][1]=='\0')
X			{
X			basefile = "";
X			fd = stdin;
X			}
X		else	{
X			basefile = argv[0];
X			fd = fopen(argv[0], "r");
X			}
X		if(fd == NULL)
X			{
X			sprintf(msg, "Cannot open file %s", argv[0]);
X			fprintf(diagfile, "%s.  Stop\n", msg);
X			done(2);
X			}
X		filenames[0] = argv[0];
X		filedepth = 0;
X
X		nftnames = 0;
X		nftnm0 = 0;
X		neflnames = neflnm0;
X
X		dofile(fd);
X		if(fd != stdin)
X			fclose(fd);
X		--argc;
X		++argv;
X		}
Xp2flush();
Xif(verbose)
X	fprintf(diagfile, "End of compilation\n");
X/*
Xprhisto();
X/* */
Xrmiis();
X
X#ifdef gcos
X	gccomp();
X#endif
X
Xdone(nbad);
X}
X
X
Xdofile(fd)
XFILE *fd;
X{
Xint k;
X
Xfprintf(diagfile, "File %s:\n", filenames[0]);
X
X#ifdef gcos
X	if( fd==stdin && intss() && inquire(stdin, _TTY) )
X		freopen("*src", "rt", stdin);
X#endif
X
Xyyin = fileptrs[0] = fd;
Xyylineno = filelines[0] = 1;
Xfiledepth = 0;
Xateof = 0;
X
Xdo	{
X	nerrs = 0;
X	nwarns = 0;
X	eofneed = 0;
X	forcerr = 0;
X	comneed = 0;
X	optneed = 0;
X	defneed = 0;
X	lettneed = 0;
X	iobrlevel = 0;
X	prevbg = 0;
X
X	constno = 0;
X	labno = 0;
X	nxtstno = 0;
X	afterif = 0;
X	thisexec = 0;
X	thisctl = 0;
X	nxtindif = 0;
X	inproc = 0;
X	blklevel = 0;
X
X	implinit();
X
X	opiis();
X	swii(icfile);
X
X	if(k = yyparse())
X		fprintf(diagfile, "Error in source file.\n");
X	else  switch(graal)
X		{
X		case PARSERR:
X			/*
X			fprintf(diagfile, "error\n");
X			*/
X			break;
X
X		case PARSEOF:
X			break;
X
X		case PARSOPT:
X			propts();
X			break;
X
X		case PARSDCL:
X			fprintf(diagfile, "external declaration\n");
X			break;
X
X		case PARSPROC:
X			/* work already done in endproc */
X			break;
X
X		case PARSDEF:
X			break;
X		}
X
X	cliis();
X	if(nerrs) ++nbad;
X
X	} while(graal!=PARSEOF && !ateof);
X}
X
Xptr bgnproc()
X{
Xptr bgnexec();
X
Xif(blklevel > 0)
X	{
X	execerr("procedure %s terminated prematurely", procnm() );
X	endproc();
X	}
Xctllevel = 0;
Xprocname = 0;
Xprocclass = 0;
Xthisargs = 0;
Xdclsect = 0;
Xblklevel = 1;
Xnftnm0 = nftnames;
Xdclsect = 1;
Xndecl[1] = 0;
Xnhid[1] = 0;
X
Xthisctl = allexcblock();
Xthisctl->tag = TCONTROL;
Xthisctl->subtype = STPROC;
Xinproc = 1;
Xreturn( bgnexec() );
X}
X
X
Xendproc()
X{
Xchar comline[50], *concat();
Xptr p;
X
Xinproc = 0;
X
Xif(nerrs == 0)
X	{
X	pass2();
X	unhide();
X	cleanst();
X	if(dumpic)
X		system( concat("od ", icfile->filename, comline) );
X	if(memdump)
X		prmem();
X	}
Xelse	{
X	fprintf(diagfile, "**Procedure %s not generated\n", procnm());
X	for( ; blklevel > 0 ; --blklevel)
X		unhide();
X	cleanst();
X	}
X
Xif(nerrs==0 && nwarns>0)
X	if(nwarns == 1)
X		fprintf(diagfile,"*1 warning\n");
X	else	fprintf(diagfile, "*%d warnings\n", nwarns);
X
Xblklevel = 0;
Xthisargs = 0;
Xprocname = 0;
Xprocclass = 0;
Xwhile(thisctl)
X	{
X	p = thisctl;
X	thisctl = thisctl->prevctl;
X	frexcblock(p);
X	}
X
Xwhile(thisexec)
X	{
X	p = thisexec;
X	thisexec = thisexec->prevexec;
X	frexcblock(p);
X	}
X
Xnftnames = nftnm0;
Xif(verbose)
X	{
X	fprintf(diagfile, "Highwater mark %d words. ", nmemused);
X	fprintf(diagfile, "%ld words left over\n", totalloc-totfreed);
X	}
X}
X
X
X
X
Ximplinit()
X{
Xsetimpl(TYREAL, 'a', 'z');
Xsetimpl(TYINT,  'i', 'n');
X}
X
X
X
Xinit()
X{
Xeflftn[TYINT] = FTNINT;
Xeflftn[TYREAL] = FTNREAL;
Xeflftn[TYLREAL] = FTNDOUBLE;
Xeflftn[TYLOG] = FTNLOG;
Xeflftn[TYCOMPLEX] = FTNCOMPLEX;
Xeflftn[TYCHAR] = FTNINT;
Xeflftn[TYFIELD] = FTNINT;
Xeflftn[TYLCOMPLEX] = FTNDOUBLE;
X}
X
X
X
X
X#ifdef gcos
Xmeter()
X{
XFILE *mout;
Xchar *cuserid(), *datime(), *s;
Xif(equals(s = cuserid(), "efl")) return;
Xmout = fopen("efl/eflmeter", "a");
Xif(mout == NULL)
X	fprintf(diagfile,"cannot open meter file");
X
Xelse	{
X	fprintf(mout, "%s user %s at %s\n",
X		( rutss()? "tss  " : "batch"), s, datime() );
X	fclose(mout);
X	}
X}
X#endif
X
X
X
X#ifdef unix
Xmeter()	/* temporary metering of non-SIF usage */
X{
XFILE *mout;
Xint tvec[2];
Xint uid;
Xchar *ctime(), *p;
X
Xuid = getuid() & 0377;
Xif(uid == 91) return;	/* ignore sif uses */
Xmout = fopen("/usr/sif/efl/Meter", "a");
Xif(mout == NULL)
X	fprintf(diagfile, "cannot open meter file");
Xelse	{
X	time(tvec);
X	p = ctime(tvec);
X	p[16] = '\0';
X	fprintf(mout,"User %d, %s\n",  uid, p+4);
X	fclose(mout);
X	}
X}
X
Xintrupt()
X{
Xdone(0);
X}
X#endif
X
X
Xdone(k)
Xint k;
X{
Xrmiis();
Xexit(k);
X}
X
X
X
X
X
X/* if string has an embedded equal sign, set option with it*/
Xeqlstrng(s)
Xchar *s;
X{
Xregister char *t;
X
Xfor(t = s; *t; ++t)
X	if(*t == '=')
X		{
X		*t = '\0';
X		while( *++t == ' ' )
X			;
X		setopt(s, t);
X		return(YES);
X		}
X
Xreturn(NO);
X}
X
X#ifdef gcos
X
X/* redirect output unit */
X
Xgcoutf()
X{
Xif (!intss())
X	{
X	fputs("\t\t    Version 2.10 : read INFO/EFL (03/27/80)\n", stderr);
X	if (compile)
X		{
X		static char name[80] = "s*", opts[20] = "yw";
X		char *opt = (char *)inquire(stdout, _OPTIONS);
X		if (!strchr(opt, 't'))
X			{ /* if stdout is diverted */
X			sprintf(name, "%s\"s*\"",
X				(char *)inquire(stdout, _FILENAME));
X			strcpy(&opts[1], opt);
X			}
X		if (freopen(name, opts, stdout) == NULL)
X			cant(name);
X		}
X	}
X}
X
X
X
X/* call in fortran compiler if necessary */
X
Xgccomp()
X{
Xif (compile)
X	{
X	if (nbad > 0)	/* abort */
X		cretsw(EXEC);
X
X	else	{ /* good: call forty */
X		FILE *dstar; /* to intercept "gosys" action */
X
X		if ((dstar = fopen("d*", "wv")) == NULL)
X			cant("d*");
X		fputs("$\tforty\tascii", dstar);
X		if (fopen("*1", "o") == NULL)
X			cant("*1");
X		fclose(stdout, "rl");
X		cretsw(FORM | LNO | BCD);
X		if (! tailor.ftncontnu)
X			compile |= FORM;
X		csetsw(compile);
X		gosys("forty");
X		}
X	}
X}
X
X
Xcant(s)
Xchar *s;
X{
Xffiler(s);
Xdone(1);
X}
X#endif

echo x - misc.c
sed -e 's/^X//' > misc.c << ''
X#include <ctype.h>
X#include "defs"
X
Xchar * copys(s)
Xregister char *s;
X{
Xregister char *t;
Xchar *k;
Xptr calloc();
X
Xfor(t=s; *t++ ; );
Xif( (k = calloc( t-s , sizeof(char))) == NULL)
X	fatal("Cannot allocate memory");
X
Xfor(t=k ; *t++ = *s++ ; );
Xreturn(k);
X}
X
X
X
Xequals(a,b)
Xregister char *a,*b;
X{
Xif(a==b) return(YES);
X
Xwhile(*a == *b)
X	if(*a == '\0') return(YES);
X	else {++a; ++b;}
X
Xreturn(NO);
X}
X
X
Xchar *concat(a,b,c)   /* c = concatenation of a and b */
Xregister char *a,*b;
Xchar *c;
X{
Xregister char *t;
Xt = c;
X
Xwhile(*t = *a++) t++;
Xwhile(*t++ = *b++);
Xreturn(c);
X}
X
X
X
X
X
Xptr conrep(a,b)
Xchar *a, *b;
X{
Xchar *s;
X
Xs = intalloc( strlen(a)+strlen(b)+1 );
Xconcat(a,b,s);
Xcfree(a);
Xreturn(s);
X}
X
X
Xeqcon(p,q)
Xregister ptr p, q;
X{
Xint pt, qt;
X
Xif(p==q) return(YES);
Xif(p==NULL || q==NULL) return(NO);
Xpt = p->tag;
Xqt = q->tag;
Xif(pt==TNEGOP && qt==TNEGOP)
X	return( eqcon(p->leftp, q->leftp) );
Xif(pt==TCONST && qt==TNEGOP)
X	return(NO);
Xif(pt==TNEGOP && qt==TCONST)
X	return(NO);
Xif(p->tag==TCONST && q->tag==TCONST)
X	return( equals(p->leftp,q->leftp) );
X
Xfatal("eqcon: nonconstant argument");
X/* NOTREACHED */
X}
X
X
X
Xchar *convic(n)
Xregister int n;
X{
Xstatic char s[20];
Xregister char *t;
X
Xs[19] = '\0';
Xt = s+19;
X
Xdo	{
X	*--t = '0' + n%10;
X	n /= 10;
X	} while(n > 0);
X
Xreturn(t);
X}
X
X
X
Xconval(p)
Xregister ptr p;
X{
Xint val;
Xif(isicon(p, &val))
X	return(val);
Xfatal("bad conval");
X}
X
X
X
Xisicon(p, valp)
Xptr p;
Xint *valp;
X{
Xint val1;
X
Xif(p)
X    switch(p->tag)
X	{
X	case TNEGOP:
X		if(isicon(p->leftp, &val1))
X			{
X			*valp = - val1;
X			return(1);
X			}
X		break;
X
X	case TCONST:
X		if(p->vtype == TYINT)
X			{
X			*valp = convci(p->leftp);
X			return(YES);
X			}
X	default:
X		break;
X	}
Xreturn(NO);
X}
X
X
X
Xisconst(p)
Xptr p;
X{
Xreturn(p->tag==TCONST  ||  (p->tag==TNEGOP && isconst(p->leftp)) );
X}
X
X
X
Xiszero(s)
Xregister char *s;
X{
Xif(s == NULL)
X	return(YES);
Xwhile( *s=='+' || *s=='-' || *s==' ' )
X	++s;
Xwhile( *s=='0' || *s=='.' )
X	++s;
Xswitch( *s )
X	{
X	case 'd':
X	case 'e':
X	case 'D':
X	case 'E':
X	case ' ':
X	case '\0':
X		return(YES);
X	default:
X		return(NO);
X	}
X}
X
X
X
X
Xconvci(p)
Xregister char *p;
X{
Xregister int n;
Xregister int sgn;
X
Xn = 0;
Xsgn = 1;
Xfor( ; *p ; ++p)
X	if(*p == '-')
X		sgn = -1;
X	else if( isdigit(*p) )
X		n = 10*n + (*p - '0');
X
Xreturn(sgn * n);
X}
X
X
X
Xchainp hookup(x,y)
Xregister chainp x, y;
X{
Xregister chainp p;
X
Xif(x == NULL)
X	return(y);
Xfor(p=x ; p->nextp ; p = p->nextp)
X	;
X
Xp->nextp = y;
Xreturn(x);
X}
X
X
Xptr cpexpr(p)
Xregister ptr p;
X{
Xregister ptr e;
Xptr q, q1;
X
Xif(p == NULL)
X	return(NULL);
X
Xe = allexpblock();
Xcpblock(p, e, sizeof(struct exprblock));
X
Xswitch(p->tag)
X	{
X	case TAROP:
X	case TRELOP:
X	case TLOGOP:
X	case TASGNOP:
X	case TCALL:
X		e->rightp = cpexpr(p->rightp);
X
X	case TNOTOP:
X	case TNEGOP:
X		e->leftp = cpexpr(p->leftp);
X		break;
X
X	case TCONST:
X		e->leftp = copys(p->leftp);
X		if(p->rightp)
X			e->rightp = copys(p->rightp);
X		if(p->vtype == TYCHAR)
X			e->vtypep = cpexpr(p->vtypep);
X		break;
X
X	case TLIST:
X		q1 = &(e->leftp);
X		for(q = p->leftp ; q ; q = q->nextp)
X			q1 = q1->nextp = mkchain( cpexpr(q->datap), CHNULL);
X		break;
X
X	case TTEMP:
X	case TNAME:
X	case TFTNBLOCK:
X		if(p->vsubs)
X			e->vsubs = cpexpr(p->vsubs);
X		if(p->voffset)
X			e->voffset = cpexpr(p->voffset);
X		break;
X
X	case TERROR:
X		break;
X
X	default:
X		badtag("cpexpr", p->tag);
X	}
Xreturn(e);
X}
X
X
Xmvexpr(p,q)
Xchar *p, *q;
X{
Xcpblock(p,q, sizeof(struct exprblock) );
Xfrexpblock(p);
X}
X
X
Xcpblock(p,q,n)
Xregister char *p, *q;
Xint n;
X{
Xregister int i;
X
Xfor(i=0; i<n; ++i)
X	*q++ = *p++;
X}
X
X
X
Xstrlen(s)
Xregister char *s;
X{
Xregister char *t;
Xfor(t=s ; *t ; t++ ) ;
Xreturn(t-s);
X}
X
X
Xchar *procnm()	/* name of the current procedure */
X{
Xreturn( procname ? procname->sthead->namep : "" );
X}
X
X
X
X
X
Xptr arg1(a)		/* make an argument list of one value */
Xptr a;
X{
Xreturn( mknode(TLIST,0, mkchain(a,CHNULL), PNULL) );
X}
X
X
X
Xptr arg2(a,b)	/* make an argumentlist (a,b) */
Xptr a,b;
X{
Xregister ptr p;
X
Xp = mkchain(a, mkchain(b,CHNULL) );
Xreturn( mknode(TLIST,0, p,0) );
X}
X
X
X
X
Xptr arg4(a,b)	/* make an argument list of  (a,len(a), b,len(b)) */
Xptr a,b;
X{
Xregister ptr p;
Xp = mkchain(b, mkchain(cpexpr(b->vtypep), CHNULL));
Xp = mkchain(a, mkchain(cpexpr(a->vtypep), p));
Xreturn( mknode(TLIST,0,p,PNULL));
X}
X
X
X
Xptr builtin(type,s)
Xint type;
Xchar *s;
X{
Xregister ptr p, q;
Xptr mkvar(), mkname();
X
Xif(p = name(s,1))
X	{
X	if(p->blklevel>1 || (p->tag!=TNAME && p->tag!=TKEYWORD) 
X	    || (q=p->varp)==0 || q->vext
X	    || (q->vtype!=type && q->vtype!=TYUNDEFINED) )
X		{
X		exprerr("error involving builtin %s", s);
X		return(errnode());
X		}
X	if(q->vtype!= TYUNDEFINED)
X		return( cpexpr(q) );
X	}
Xelse	{
X	q = mkvar( mkname(s) );
X	if(blklevel > 1)
X		{
X		q->blklevel = 1;
X		q->sthead->blklevel = 1;
X		--ndecl[blklevel];
X		++ndecl[1];
X		}
X	}
X
Xq->vtype = type;
Xq->vdclstart = 1;
Xmkftnp(q);
Xreturn( cpexpr(q) );
X}
X
X
X
Xptr errnode()
X{
Xregister struct exprblock * p;
X
Xp = allexpblock();
Xp->tag = TERROR;
Xp->vtype = TYINT;
Xreturn(p);
X}
X
X
X
Xmin(a,b)
Xint a,b;
X{
Xreturn( a<b ? a : b);
X}
X
X
X
Xsetvproc(p, v)
Xregister ptr p;
Xregister int v;
X{
Xptr q;
Xregister int k;
X
Xq = p->sthead->varp;
Xk = q->vproc;
X/*debug printf("setvproc(%s ,%d)\n", q->sthead->namep, v); */
Xif(p != q)
X	p->vproc = k;
Xif(k == v)
X	return;
X
Xif(k==PROCUNKNOWN || (k==PROCYES && v==PROCINTRINSIC) )
X	p->vproc = q->vproc = v;
Xelse if( !(k==PROCINTRINSIC && v==PROCYES)  && p->sthead->varp!=procname)
X	execerr("attempt to use %s as variable and procedure",
X		p->sthead->namep);
X}

echo x - mk.c
sed -e 's/^X//' > mk.c << ''
X#include "defs"
X
X
Xptr mkcomm(s)
Xregister char *s;
X{
Xregister ptr p;
Xregister char *t;
X
Xfor(p = commonlist ; p ; p = p->nextp)
X	if(equals(s, p->datap->comname))
X		return(p->datap);
X
Xp = ALLOC(comentry);
Xfor(t = p->comname ; *t++ = *s++ ; ) ;
Xp->tag = TCOMMON;
Xp->blklevel = (blklevel>0? 1 : 0);
Xcommonlist = mkchain(p, commonlist);
Xreturn(commonlist->datap);
X}
X
X
X
X
Xptr mkname(s)
Xchar *s;
X{
Xchar *copys();
Xregister ptr p;
X
Xif( (p = name(s,1)) == 0)
X	{
X	p = name(s,0);
X	p->tag = TNAME;
X	p->blklevel = blklevel;
X	}
Xreturn(p);
X}
X
Xptr mknode(t, o, l, r)
Xint t,o;
Xregister ptr l;
Xregister ptr r;
X{
Xregister struct exprblock *p;
Xptr q;
Xint lt, rt;
Xint ll, rl;
Xptr mksub1(), mkchcon();
X
Xp = allexpblock();
XTEST fprintf(diagfile, "mknode(%d,%d,%o,%o) = %o\n", t, o, l, r, p);
X
Xtop:
X	if(t!=TLIST && t!=TCONST && l!=0 && l->tag==TERROR)
X		{
X		frexpr(r);
X		frexpblock(p);
X		return(l);
X		}
X
X	if(r!=0 && r->tag==TERROR)
X		{
X		frexpr(l);
X		frexpblock(p);
X		return(r);
X		}
X	p->tag = t;
X	p->subtype = o;
X	p->leftp = l;
X	p->rightp = r;
X
Xswitch(t)
X	{
X	case TAROP:
X		ckdcl(l);
X		ckdcl(r);
X		switch(lt = l->vtype)
X			{
X			case TYCHAR:
X			case TYSTRUCT:
X			case TYLOG:
X				exprerr("non-arithmetic operand of arith op","");
X				goto err;
X			}
X
X		switch(rt = r->vtype)
X			{
X			case TYCHAR:
X			case TYSTRUCT:
X			case TYLOG:
X				exprerr("non-arithmetic operand of arith op","");
X				goto err;
X			}
X		if(lt==rt || (o==OPPOWER && rt==TYINT) )
X			p->vtype = lt;
X		else if( (lt==TYREAL && rt==TYLREAL) ||
X			(lt==TYLREAL && rt==TYREAL) )
X				p->vtype = TYLREAL;
X		else if(lt==TYINT)
X			{
X			l = coerce(rt,l);
X			goto top;
X			}
X		else if(rt==TYINT)
X			{
X			r = coerce(lt,r);
X			goto top;
X			}
X		else if( (lt==TYREAL && rt==TYCOMPLEX) ||
X			 (lt==TYCOMPLEX && rt==TYREAL) )
X			p->vtype = TYCOMPLEX;
X		else if( (lt==TYLREAL && rt==TYCOMPLEX) ||
X			 (lt==TYCOMPLEX && rt==TYLREAL) )
X			p->vtype = TYLCOMPLEX;
X		else	{
X			exprerr("mixed mode", CNULL);
X			goto err;
X			}
X
X		if( (o==OPPLUS||o==OPSTAR) && l->tag==TCONST && r->tag!=TCONST )
X			{
X			p->leftp = r;
X			p->rightp = l;
X			}
X
X		if(o==OPPLUS && l->tag==TNEGOP &&
X		  (r->tag!=TCONST || l->leftp->tag==TCONST) )
X			{
X			p->subtype = OPMINUS;
X			p->leftp = r;
X			p->rightp = l->leftp;
X			}
X
X		break;
X
X	case TRELOP:
X		ckdcl(l);
X		ckdcl(r);
X		p->vtype = TYLOG;
X		lt = l->vtype;
X		rt = r->vtype;
X		if(lt==TYCHAR || rt==TYCHAR)
X			{
X			if(l->vtype != r->vtype)
X				{
X				exprerr("comparison of character and noncharacter data",CNULL);
X				goto err;
X				}
X			ll = conval(l->vtypep);
X			rl = conval(r->vtypep);
X			if( (o==OPEQ || o==OPNE) &&
X				( (ll==1 && rl==1 && tailor.charcomp==1)
X				|| (ll<=tailor.ftnchwd && rl<=tailor.ftnchwd
X				&& tailor.charcomp==2) ))
X				{
X				if(l->tag == TCONST)
X					{
X					q = cpexpr( mkchcon(l->leftp) );
X					frexpr(l);
X					l = q;
X					}
X				if(r->tag == TCONST)
X					{
X					q = cpexpr( mkchcon(r->leftp) );
X					frexpr(r);
X					r = q;
X					}
X				if(l->vsubs == 0)
X					l->vsubs = mksub1();
X				if(r->vsubs == 0)
X					r->vsubs = mksub1();
X				p->leftp = l;
X				p->rightp = r;
X				}
X			else	{
X				p->leftp = mkcall(builtin(TYINT,"ef1cmc"), arg4(l,r));
X				p->rightp = mkint(0);
X				}
X			}
X
X		else if(lt==TYLOG || rt==TYLOG)
X			exprerr("relational involving logicals", CNULL);
X		else if( (lt==TYCOMPLEX || rt==TYCOMPLEX) &&
X			o!=OPEQ && o!=OPNE)
X				exprerr("order comparison of complex numbers", CNULL);
X		else if(lt != rt)
X			{
X			if(lt==TYINT)
X				p->leftp = coerce(rt, l);
X			else if(rt == TYINT)
X				p->rightp = coerce(lt, r);
X			}
X		break;
X
X	case TLOGOP:
X		ckdcl(l);
X		ckdcl(r);
X		if(r->vtype != TYLOG)
X			{
X			exprerr("non-logical operand of logical operator",CNULL);
X			goto err;
X			}
X	case TNOTOP:
X		ckdcl(l);
X		if(l->vtype != TYLOG)
X			{
X			exprerr("non-logical operand of logical operator",CNULL);
X			}
X		p->vtype = TYLOG;
X		break;
X
X	case TNEGOP:
X		ckdcl(l);
X		lt = l->vtype;
X		if(lt!=TYINT && lt!=TYREAL && lt!=TYLREAL && lt!=TYCOMPLEX)
X			{
X			exprerr("impossible unary + or - operation",CNULL);
X			goto err;
X			}
X		p->vtype = lt;
X		break;
X
X	case TCALL:
X		p->vtype = l->vtype;
X		p->vtypep = l->vtypep;
X		break;
X
X	case TASGNOP:
X		ckdcl(l);
X		ckdcl(r);
X		lt = l->vtype;
X		if(lt==TYFIELD)
X			lt = TYINT;
X		rt = r->vtype;
X		if(lt==TYCHAR || rt==TYCHAR || lt==TYLOG || rt==TYLOG)
X			{
X			if(lt != rt)
X				{
X				exprerr("illegal assignment",CNULL);
X				goto err;
X				}
X			}
X		else if(lt==TYSTRUCT || rt==TYSTRUCT)
X			{
X			if(lt!=rt || l->vtypep->strsize!=r->vtypep->strsize
X				|| l->vtypep->stralign!=r->vtypep->stralign)
X				{
X				exprerr("illegal structure assignment",CNULL);
X				goto err;
X				}
X			}
X		else if ( (lt==TYCOMPLEX || rt==TYCOMPLEX) && lt!=rt)
X/*			p->rightp = r = coerce(lt, r) */ ;
X
X		p->vtype = lt;
X		p->vtypep = l->vtypep;
X		break;
X
X	case TCONST:
X	case TLIST:
X	case TREPOP:
X		break;
X
X	default:
X		badtag("mknode", t);
X	}
X
Xreturn(p);
X
Xerr:	frexpr(p);
X	return( errnode() );
X}
X
X
X
Xckdcl(p)
Xptr p;
X{
Xif(p->vtype==TYUNDEFINED || (p->tag==TNAME&&p->vdcldone==0&&p->vadjdim==0))
X	{
X/*debug*/ printf("tag=%d, typed=%d\n", p->tag, p->vtype);
X	fatal("untyped subexpression");
X	}
Xif(p->tag==TNAME) setvproc(p,PROCNO);
X}
X
Xptr mkvar(p)
Xregister ptr p;
X{
Xregister ptr q;
X
XTEST fprintf(diagfile, "mkvar(%s), blk %d\n", p->namep, blklevel);
X
Xif(p->blklevel > blklevel)
X	p->blklevel = blklevel;
X
Xif(instruct || p->varp==0 || p->varp->blklevel<blklevel)
X	{
X	q = allexpblock();
X	q->tag = TNAME;
X	q->sthead = p;
X	q->blklevel = blklevel;
X	if(! instruct)
X		++ndecl[blklevel];
X	}
Xelse q = p->varp;
X
Xif(!instruct)
X	{
X	if(p->varp && p->varp->blklevel<blklevel)
X		hide(p);
X	if(p->varp == 0)
X		p->varp = q;
X	}
X
Xp->tag = TNAME;
Xreturn(q);
X}
X
X
Xptr mkstruct(v,s)
Xregister ptr v;
Xptr s;
X{
Xregister ptr p;
X
Xp = ALLOC(typeblock);
Xp->sthead = v;
Xp->tag = TSTRUCT;
Xp->blklevel = blklevel;
Xp->strdesc = s;
Xoffsets(p);
Xif(v)	{
X	v->blklevel = blklevel;
X	++ndecl[blklevel];
X	v->varp = p;
X	}
Xelse	temptypelist = mkchain(p, temptypelist);
Xreturn(p);
X}
X
X
Xptr mkcall(fn1, args)
Xptr fn1, args;
X{
Xint i, j, first;
Xregister ptr funct, p, q;
Xptr r;
X
Xif(fn1->tag == TERROR)
X	return( errnode() );
Xelse if(fn1->tag == TNAME)
X	{
X	funct = fn1->sthead->varp;
X	frexpblock(fn1);
X	}
Xelse
X	funct = fn1;
Xif(funct->vclass!=0 && funct->vclass!=CLARG)
X	{
X	exprerr("invalid invocation of %s",funct->sthead->namep);
X	frexpr(args);
X	return( errnode() );
X	}
Xelse	extname(funct);
X
Xif(args)  for(p = args->leftp; p ; p = p->nextp)
X	{
X	q = p->datap;
X	if( (q->tag==TCALL&&q->vtype==TYUNDEFINED) ||
X	    (q->tag==TNAME&&q->vdcldone==0) )
X		dclit(q);
X	if(q->tag==TNAME && q->vproc==PROCUNKNOWN)
X		setvproc(q, PROCNO);
X	if( q->vtype == TYSTRUCT)
X		{
X		first = 1;
X		for(i = 0; i<NFTNTYPES ; ++i)
X			if(q->vbase[i] != 0)
X				{
X				r = cpexpr(q);
X				if(first)
X					{
X					p->datap = r;
X					first = 0;
X					}
X				else	p = p->nextp = mkchain(r, p->nextp);
X				r->vtype = ftnefl[i];
X				for(j=0; j<NFTNTYPES; ++j)
X					if(i != j) r->vbase[j] = 0;
X				}
X		frexpblock(q);
X		}
X	}
X
Xreturn( mknode(TCALL,0,cpexpr(funct), args) );
X}
X
X
X
Xmkcase(p,here)
Xptr p;
Xint here;
X{
Xregister ptr q, s;
X
Xfor(s = thisctl ; s!=0 && s->subtype!=STSWITCH ; s = s->prevctl)
X	;
Xif(s==0 || (here && s!=thisctl) )
X	{
X	laberr("invalid case label location",CNULL);
X	return(0);
X	}
Xfor(q = s->loopctl ; q!=0 && !eqcon(p,q->casexpr) ; q = q->nextcase)
X	;
Xif(q == 0)
X	{
X	q = ALLOC(caseblock);
X	q->tag = TCASE;
X	q->casexpr = p;
X	q->labelno = ( here ? thislab() : nextlab() );
X	q->nextcase = s->loopctl;
X	s->loopctl = q;
X	}
Xelse if(here)
X	if(thisexec->labelno == 0)
X		thisexec->labelno = q->labelno;
X	else if(thisexec->labelno != q->labelno)
X		{
X		exnull();
X		thisexec->labelno = q->labelno;
X		thisexec->labused = 0;
X		}
Xif(here)
X	if(q->labdefined)
X		laberr("multiply defined case",CNULL);
X	else
X		q->labdefined = 1;
Xreturn(q->labelno);
X}
X
X
Xptr mkilab(p)
Xptr p;
X{
Xchar *s, l[30];
X
Xif(p->tag!=TCONST || p->vtype!=TYINT)
X	{
X	execerr("invalid label","");
X	s = "";
X	}
Xelse	s = p->leftp;
X
Xwhile(*s == '0')
X	++s;
Xsprintf(l,"#%s", s);
X
X
XTEST fprintf(diagfile,"numeric label = %s\n", l);
Xreturn( mkname(l) );
X}
X
X
X
X
Xmklabel(p,here)
Xptr p;
Xint here;
X{
Xregister ptr q;
X
Xif(q = p->varp)
X	{
X	if(q->tag != TLABEL)
X		laberr("%s is already a nonlabel\n", p->namep);
X	else if(q->labinacc)
X		warn1("label %s is inaccessible", p->namep);
X	else if(here)
X		if(q->labdefined)
X			laberr("%s is already defined\n", p->namep);
X		else if(blklevel > q->blklevel)
X			laberr("%s is illegally placed\n",p->namep);
X		else	{
X			q->labdefined = 1;
X			if(thisexec->labelno == 0)
X				thisexec->labelno = q->labelno;
X			else if(thisexec->labelno != q->labelno)
X				{
X				exnull();
X				thisexec->labelno = q->labelno;
X				thisexec->labused = 0;
X				}
X			}
X	}
Xelse	{
X	q = ALLOC(labelblock);
X	p->varp = q;
X	q->tag = TLABEL;
X	q->subtype = 0;
X	q->blklevel = blklevel;
X	++ndecl[blklevel];
X	q->labdefined = here;
X	q->labelno = ( here ? thislab() : nextlab() );
X	q->sthead = p;
X	}
X
Xreturn(q->labelno);
X}
X
X
Xthislab()
X{
Xif(thisexec->labelno == 0)
X	thisexec->labelno = nextlab();
Xreturn(thisexec->labelno);
X}
X
X
Xnextlab()
X{
Xstnos[++labno] = 0;
Xreturn( labno );
X}
X
X
Xnextindif()
X{
Xif(++nxtindif < MAXINDIFS)
X	return(nxtindif);
Xfatal("too many indifs");
X}
X
X
X
X
Xmkkeywd(s, n)
Xchar *s;
Xint n;
X{
Xregister ptr p;
Xregister ptr q;
X
Xp = name(s, 2);
Xq = ALLOC(keyblock);
Xp->tag = TKEYWORD;
Xq->tag = TKEYWORD;
Xp->subtype = n;
Xq->subtype = n;
Xp->blklevel = 0;
Xp->varp = q;
Xq->sthead = p;
X}
X
X
Xptr mkdef(s, v)
Xchar *s, *v;
X{
Xregister ptr p;
Xregister ptr q;
X
Xif(p = name(s,1))
X	if(p->blklevel == 0)
X		{
X		if(blklevel > 0)
X			hide(p);
X		else if(p->tag != TDEFINE)
X			dclerr("attempt to DEFINE a variable name", s);
X		else	{
X			if( strcmp(v, (q=p->varp) ->valp) )
X				{
X				warn("macro value replaced");
X				cfree(q->valp);
X				q->valp = copys(v);
X				}
X			return(p);
X			}
X		}
X	else	{
X		dclerr("type already defined", s);
X		return( errnode() );
X		}
Xelse   p = name(s,0);
X
Xq = ALLOC(defblock);
Xp->tag = TDEFINE;
Xq->tag = TDEFINE;
Xp->blklevel = q->blklevel = (blklevel==0 ? 0 : 1);
Xq->sthead = p;
Xp->varp = q;
Xp->varp->valp = copys(v);
Xreturn(p);
X}
X
X
X
Xmkknown(s,t)
Xchar *s;
Xint t;
X{
Xregister ptr p;
X
Xp = ALLOC(knownname);
Xp->nextfunct = knownlist;
Xp->tag = TKNOWNFUNCT;
Xknownlist = p;
Xp->funcname = s;
Xp->functype = t;
X}
X
X
X
X
X
X
X
Xptr mkint(k)
Xint k;
X{
Xreturn( mkconst(TYINT, convic(k) ) );
X}
X
X
Xptr mkconst(t,p)
Xint t;
Xptr p;
X{
Xptr q;
X
Xq = mknode(TCONST, 0, copys(p), PNULL);
Xq->vtype = t;
Xif(t == TYCHAR)
X	q->vtypep = mkint( strlen(p) );
Xreturn(q);
X}
X
X
X
Xptr mkimcon(t,p)
Xint t;
Xchar *p;
X{
Xptr q;
Xchar *zero, buff[100];
X
Xzero = (t==TYCOMPLEX ? "0." : "0d0");
Xsprintf(buff, "(%s,%s)", zero, p);
Xq = mknode(TCONST, 0, copys(buff), PNULL);
Xq->vtype = t;
Xreturn(q);
X}
X
X
X
Xptr mkarrow(p,t)
Xregister ptr p;
Xptr t;
X{
Xregister ptr q, s;
X
Xif(p->vsubs == 0)
X	if(p->vdim==0 && p->vtype!=TYCHAR && p->vtype!=TYSTRUCT)
X		{
X		exprerr("need an aggregate to the left of arrow",CNULL);
X		frexpr(p);
X		return( errnode() );
X		}
X	else	{
X		if(p->vdim)
X			{
X			s = 0;
X			for(q = p->vdim->datap ; q ; q = q->nextp)
X				s = mkchain( mkint(1), s);
X			subscript(p, mknode(TLIST,0,s,PNULL) );
X			}
X		}
X
Xp->vtype = TYSTRUCT;
Xp->vtypep = t->varp;
Xreturn(p);
X}
X
X
X
X
X
Xmkequiv(p)
Xptr p;
X{
Xptr q, t;
Xint first;
X
Xswii(iefile);
Xputic(ICBEGIN, 0);
Xputic(ICINDENT, 0);
Xputic(ICKEYWORD, FEQUIVALENCE);
Xputic(ICOP, OPLPAR);
Xfirst = 1;
X
Xfor(q = p ; q ; q = q->nextp)
X	{
X	if(first)  first = 0;
X	else putic(ICOP, OPCOMMA);
X	prexpr( t =  simple(LVAL,q->datap) );
X	frexpr(t);
X	}
X
Xputic(ICOP, OPRPAR);
Xswii(icfile);
Xfrchain( &p );
X}
X
X
X
X
Xmkgeneric(gname,atype,fname,ftype)
Xchar *gname, *fname;
Xint atype, ftype;
X{
Xregister ptr p;
Xptr generic();
X
Xif(p = generic(gname))
X	{
X	if(p->genfname[atype])
X		fatal1("generic name already defined", gname);
X	}
Xelse	{
X	p = ALLOC(genblock);
X	p->tag = TGENERIC;
X	p->nextgenf = generlist;
X	generlist = p;
X	p->genname = gname;
X	}
X
Xp->genfname[atype] = fname;
Xp->genftype[atype] = ftype;
X}
X
X
Xptr generic(s)
Xchar *s;
X{
Xregister ptr p;
X
Xfor(p= generlist; p ; p = p->nextgenf)
X	if(equals(s, p->genname))
X		return(p);
Xreturn(0);
X}
X
X
Xknownfunct(s)
Xchar *s;
X{
Xregister ptr p;
X
Xfor(p = knownlist ; p ; p = p->nextfunct)
X	if(equals(s, p->funcname))
X		return(p->functype);
Xreturn(0);
X}
X
X
X
X
X
Xptr funcinv(p)
Xregister ptr p;
X{
Xptr fp, fp1;
Xregister ptr g;
Xchar *s;
Xregister int t;
Xint vt;
X
Xif(g = generic(s = p->leftp->sthead->namep))
X	{
X	if(p->rightp->tag==TLIST && p->rightp->leftp
X		&& ( (vt = typearg(p->rightp->leftp)) >=0)
X		&& (t = g->genftype[vt]) )
X		{
X		p->leftp = builtin(t, g->genfname[vt]);
X		}
X	else	{
X		dclerr("improper use of generic function", s);
X		frexpr(p);
X		return( errnode() );
X		}
X	}
X
Xfp = p->leftp;
Xsetvproc(fp, PROCYES);
Xfp1 = fp->sthead->varp;
Xs = fp->sthead->namep;
X
Xif(p->vtype==TYUNDEFINED && fp->vclass!=CLARG)
X	if(t = knownfunct(s))
X		{
X		p->vtype = t;
X		setvproc(fp, PROCINTRINSIC);
X		setvproc(fp1, PROCINTRINSIC);
X		fp1->vtype = t;
X		builtin(t,fp1->sthead->namep);
X		cpblock(fp1, fp, sizeof(struct exprblock));
X		}
X
Xdclit(p);
Xreturn(p);
X}
X
X
X
X
Xtypearg(p0)
Xregister chainp p0;
X{
Xregister chainp p;
Xregister int vt, maxt;
X
Xif(p0 == NULL)
X	return(-1);
Xmaxt = p0->datap->vtype;
X
Xfor(p = p0->nextp ; p ; p = p->nextp)
X	if( (vt = p->datap->vtype) > maxt)
X		maxt = vt;
X
Xfor(p = p0 ; p ; p = p->nextp)
X	p->datap = coerce(maxt, p->datap);
X
Xreturn(maxt);
X}
X
X
X
X
Xptr typexpr(t,e)
Xregister ptr t, e;
X{
Xptr e1;
Xint etag;
X
Xif(t->atdim!=0 || (e->tag==TLIST && t->attype!=TYCOMPLEX) )
X	goto typerr;
X
Xswitch(t->attype)
X	{
X	case TYCOMPLEX:
X		if(e->tag==TLIST)
X			if(e->leftp==0 || e->leftp->nextp==0
X			    || e->leftp->nextp->nextp!=0)
X				{
X				exprerr("bad conversion to complex", "");
X				return( errnode() );
X				}
X			else	{
X				e->leftp->datap = simple(RVAL,
X						e->leftp->datap);
X				e->leftp->nextp->datap = simple(RVAL,
X						e->leftp->nextp->datap);
X				if(isconst(e->leftp->datap) &&
X				   isconst(e->leftp->nextp->datap) )
X					return( compconst(e) );
X				e1 = mkcall(builtin(TYCOMPLEX,"cmplx"),
X					arg2( coerce(TYREAL,e->leftp->datap),
X					coerce(TYREAL,e->leftp->nextp->datap)));
X				frchain( &(e->leftp) );
X				frexpblock(e);
X				return(e1);
X				}
X
X	case TYINT:
X	case TYREAL:
X	case TYLREAL:
X	case TYLOG:
X	case TYFIELD:
X		e = coerce(t->attype, simple(RVAL, e) );
X		etag = e->tag;
X		if(etag==TAROP || etag==TLOGOP || etag==TRELOP)
X			e->needpar = YES;
X		return(e);
X
X	case TYCHAR:
X	case TYSTRUCT:
X		goto typerr;
X	}
X
Xtyperr:
X	exprerr("typexpr not fully implemented", "");
X	frexpr(e);
X	return( errnode() );
X}
X
X
X
X
Xptr compconst(p)
Xregister ptr p;
X{
Xregister ptr a, b;
Xint as, bs;
Xint prec;
X
Xprec = TYREAL;
Xp = p->leftp;
Xif(p == 0)
X	goto err;
Xif(p->datap->vtype == TYLREAL)
X	prec = TYLREAL;
Xa = coerce(TYLREAL, p->datap);
Xp = p->nextp;
Xif(p->nextp)
X	goto err;
Xif(p->datap->vtype == TYLREAL)
X	a = coerce(prec = TYLREAL,a);
Xb = coerce(TYLREAL, p->datap);
X
Xif(a->tag==TNEGOP)
X	{
X	as = '-';
X	a = a->leftp;
X	}
Xelse	as = ' ';
X
Xif(b->tag==TNEGOP)
X	{
X	bs = '-';
X	b = b->leftp;
X	}
Xelse	bs = ' ';
X
Xif(a->tag!=TCONST || a->vtype!=prec ||
X   b->tag!=TCONST || b->vtype!=prec )
X		goto err;
X
Xif(prec==TYLREAL && tailor.lngcxtype==NULL)
X	{
X	ptr q, e1, e2;
X	struct dimblock *dp;
X	sprintf(msg, "_const%d", ++constno);
X	q = mkvar(mkname(msg));
X	q->vtype = TYLREAL;
X	dclit(q);
X	dp = ALLOC(dimblock);
X	dp->upperb = mkint(2);
X	q->vdim = mkchain(dp,CHNULL);
X	sprintf(msg, "%c%s", as, a->leftp);
X	e1 = mkconst(TYLREAL, msg);
X	sprintf(msg, "%c%s", bs, b->leftp);
X	e2 = mkconst(TYLREAL, msg);
X	mkinit(q, mknode(TLIST,0, mkchain(e1,mkchain(e2,CHNULL)),PNULL) );
X	cfree(q->vdim);
X	q->vtype = TYLCOMPLEX;
X	return(q);
X	}
Xelse
X	{
X	sprintf(msg, "(%c%s, %c%s)", as, a->leftp, bs, b->leftp);
X	return( mkconst(TYCOMPLEX, msg) );
X	}
X
Xerr:	exprerr("invalid complex constant", "");
X	return( errnode() );
X}
X
X
X
X
Xptr mkchcon(p)
Xchar *p;
X{
Xregister ptr q;
Xchar buf[10];
X
Xsprintf(buf, "_const%d", ++constno);
Xq = mkvar(mkname(buf));
Xq->vtype = TYCHAR;
Xq->vtypep = mkint(strlen(p));
Xmkinit(q, mkconst(TYCHAR, p));
Xreturn(q);
X}
X
X
X
Xptr mksub1()
X{
Xreturn( mknode(TLIST,0, mkchain(mkint(1),CHNULL), PNULL) );
X}

echo x - namgen.c
sed -e 's/^X//' > namgen.c << ''
X#include "defs"
X
Ximpldecl(p)
Xregister ptr p;
X{
Xextern char *types[];
Xregister ptr q;
Xint n;
X
Xif(p->vtype==TYSUBR) return;
Xif(p->tag == TCALL)
X	{
X	impldecl(p->leftp);
X	p->vtype = p->leftp->vtype;
X	p->vtypep = p->leftp->vtypep;
X	return;
X	}
X
Xif(inbound)
X	n = TYINT;
Xelse	{
X	n = impltype[p->sthead->namep[0] - 'a' ];
X	if(n==TYREAL && p->vprec!=0)
X		n = TYLREAL;
X	sprintf(msg,  "%s implicitly typed %s",p->sthead->namep, types[n]);
X	warn(msg);
X	}
Xq = p->sthead->varp;
Xp->vtype = q->vtype = n;
Xif(p->blklevel>1 && p->vdclstart==0)
X	{
X	p->blklevel = q->blklevel = p->sthead->blklevel = 1;
X	p->vdclstart = q->vdclstart = 1;
X	--ndecl[blklevel];
X	++ndecl[1];
X	}
X}
X
X
X
Xextname(p)
Xregister ptr p;
X{
Xregister int i;
Xregister char *q, *s;
X
X/*	if(p->vclass == CLARG) return;	*/
Xif(p->vextbase) return;
Xq = p->sthead->namep;
Xsetvproc(p, PROCYES);
X
X/* external names are automatically at block level 1 */
X
Xif( (i =p->blklevel) >1)
X	{
X	p->sthead->blklevel = 1;
X	p->blklevel = 1;
X	p->sthead->varp->blklevel = 1;
X	++ndecl[1];
X	--ndecl[i];
X	}
X
Xif(p->vclass!=CLUNDEFINED && p->vclass!=CLARG)
X	{
X	dclerr("illegal class for procedure", q);
X	return;
X	}
Xif(p->vclass!=CLARG && strlen(q)>XL)
X	{
X	if(! ioop(q) )
X		dclerr("procedure name too long", q);
X	return;
X	}
Xif(lookftn(q) > 0)
X	dclerr("procedure name already used", q);
Xelse	{
X	for(i=0 ; i<NFTNTYPES ; ++i)
X		if(p->vbase[i]) break;
X	if(i < NFTNTYPES)
X		p->vextbase = p->vbase[i];
X	else	p->vextbase = nxtftn();
X
X	if(p->vext==0 || p->vclass!=CLARG)
X		for(s = ftnames[ p->vextbase ]; *s++ = *q++ ; ) ; 
X	return;
X	}
X}
X
X
X
Xdclit(p)
Xregister ptr p;
X{
Xregister ptr q;
X
Xif(p->tag == TERROR)
X	return;
X
Xq = p->sthead->varp;
X
Xif(p->tag == TCALL)
X	{
X	dclit(p->leftp);
X	if( ioop(p->leftp->sthead->namep) )
X		p->leftp->vtype = TYLOG;
X	p->vtype = p->leftp->vtype;
X	p->vtypep = p->leftp->vtypep;
X	return;
X	}
X
Xif(q->vdcldone == 0)
X	mkftnp(q);
Xif(p != q)
X	cpblock(q,p, sizeof(struct exprblock));
X}
X
X
Xmkftnp(p)
Xregister ptr p;
X{
Xint i,k;
Xif(inbound || p->vdcldone) return;
Xif(p == 0)
X	fatal("mkftnp: zero argument");
Xif(p->tag!=TNAME && p->tag!=TTEMP)
X	badtag("mkftnp", p->tag);
X
Xif(p->vtype == TYUNDEFINED)
X	if(p->vextbase)
X		return;
X	else	impldecl(p);
Xp->vdcldone = 1;
X
Xswitch(p->vtype)
X	{
X	case TYCHAR:
X	case TYINT:
X	case TYREAL:
X	case TYLREAL:
X	case TYLOG:
X	case TYCOMPLEX:
X	case TYLCOMPLEX:
X		p->vbase[ eflftn[p->vtype] ] = nxtftn();
X		break;
X
X	case TYSTRUCT:
X		k = p->vtypep->basetypes;
X		for(i=0; i<NFTNTYPES ; ++i)
X			if(k & ftnmask[i])
X				p->vbase[i] = nxtftn();
X		break;
X
X	case TYSUBR:
X		break;
X
X	default:
X		fatal1("invalid type for %s", p->sthead->namep);
X		break;
X	}
X}
X
X
Xnamegen()
X{
Xregister ptr p;
Xregister struct stentry **hp;
Xregister int i;
X
Xfor(hp = hashtab ; hp<hashend ; ++hp)
X	if(*hp && (p = (*hp)->varp) )
X		if(p->tag == TNAME)
X			mkft(p);
X
Xfor(p = gonelist ; p ; p = p->nextp)
X	mkft(p->datap);
X
Xfor(p = hidlist ; p ; p = p->nextp)
X	if(p->datap->tag == TNAME)  mkft(p->datap);
X
Xfor(p = tempvarlist ; p ; p = p->nextp)
X	mkft(p->datap);
X
XTEST fprintf(diagfile, "Fortran names:\n");
XTEST for(i=1; i<=nftnames ; ++i)  fprintf(diagfile, "%s\n", ftnames[i]);
X}
X
X
Xmkft(p)
Xregister ptr p;
X{
Xint i;
Xregister char *s, *t;
X
Xif(p->vnamedone)
X	return;
X
Xif(p->vdcldone==0 && p!=procname)
X	{
X	if(p->vext && p->vtype==TYUNDEFINED)
X		p->vtype = TYSUBR;
X	else if(p->vextbase==0 && p->vadjdim==0 && p->vclass!=CLCOMMON)
X		warn1("%s never used", p->sthead->namep);
X	mkftnp(p);
X	}
X
Xif(p->vextbase)
X	mkftname(p->vextbase, p->sthead->namep);
X
Xfor(i=0; i<NFTNTYPES ; ++i)
X	if(p->vbase[i] != 0)
X	if(p!=procname && p->vextbase!=0)
X		{
X		s = ftnames[p->vextbase];
X		t = ftnames[p->vbase[i]];
X		while(*t++ = *s++ )
X			;
X		}
X	else if(p->sthead)
X		mkftname(p->vbase[i], p->sthead->namep);
X	else
X		mkftname(p->vbase[i], CHNULL);
Xp->vnamedone = 1;
X}
X
X
X
X
X
Xmkftname(n,s)
Xint n;
Xchar *s;
X{
Xint i, j;
Xregister int k;
Xchar fn[7];
Xregister char *c1, *c2;
X
Xif(ftnames[n][0] != '\0')  return;
X
Xif(s==0 || *s=='\0')
X	s = "temp";
Xelse if(*s == '_')
X	++s;
Xk = strlen(s);
X
Xfor(i=0; i<k && i<(XL/2) ; ++i)
X	fn[i] = s[i];
Xif(k > XL)
X	{
X	s += (k-XL);
X	k = XL;
X	}
X
Xfor( ; i<k ; ++i)
X	fn[i] = s[i];
Xfn[i] = '\0';
X
Xif( lookftn(fn) )
X	{
X	if(k < XL)
X		++k;
X	fn[k] = '\0';
X	c1 = fn + k-1;
X	for(*c1 = '1' ; *c1 <= '9' ; *c1 += 1)
X		if(lookftn(fn) == 0)
X			goto nameok;
X
X	if(k < XL)
X		++k;
X	fn[k] = '\0';
X	c1 = fn + k-2;
X	c2 = c1 + 1;
X
X	for(*c1 = '1' ; *c1 <= '9' ; *c1 += 1)
X		for(*c2 = '0' ; *c2 <= '9' ; *c2 += 1)
X			if(lookftn(fn) == 0)
X				goto nameok;
X	fatal1("mkftname: cannot generate fortran name for %s", s);
X	}
X
Xnameok:
Xfor(j=0; j<=k ; ++j)
X	ftnames[n][j] = fn[j];
X}
X
X
X
Xnxtftn()
X{
Xif( ++nftnames < MAXFTNAMES)
X	{
X	ftnames[nftnames][0] = '\0';
X	return(nftnames);
X	}
X
Xfatal("too many Fortran names generated");
X/* NOTREACHED */
X}
X
X
X
Xlookftn(s)
Xchar *s;
X{
Xregister int i;
X
Xfor(i=1 ; i<=nftnames ; ++i)
X	if(equals(ftnames[i],s))  return(i);
Xreturn(0);
X}
X
X
X
Xptr mkftnblock(type, name)
Xint type;
Xchar *name;
X{
Xregister struct varblock *p;
Xregister int k;
X
Xp = allexpblock();
Xp->tag = TFTNBLOCK;
Xp->vtype = type;
Xp->vdcldone = 1;
X
Xif( (k = lookftn(name)) == 0)
X	{
X	k = nxtftn();
X	strcpy(ftnames[k], name);
X	}
Xp->vbase[ eflftn[type] ] = k;
Xp->vextbase = k;
Xreturn(p);
X}

echo x - pass2.c
sed -e 's/^X//' > pass2.c << ''
X#include "defs"
X#include <ctype.h>
X
Xstatic int indent;
X
Xchar *verb[] = { " ", " ", "continue", "call ", "do ", "if ", "if ",
X	"goto ", "return", "read ", "write ", "format ", "stop ",
X	"data ", "equivalence ", "common ", "external ",
X	"rewind", "backspace", "endfile",
X	"subroutine ", "function ", "program", "blockdata", "end", CNULL };
X
Xextern char *ops[];
Xptr getsii();
X
X/* generate code */
X
Xpass2()
X{
Xexnull();
Xif(comments) putcomment();
Xif(verbose)
X	fprintf(diagfile, "    Pass 2\n");
X
Xdclsect = 0;
Xindent = 0;
X
Xnamegen();
Xdclgen();
Xbody(iefile);
Xdatas();
Xbody(icfile);
X
Xp2stmt(0);
Xp2key(FEND);
Xp2flush();
Xif(verbose)
X	fprintf(diagfile, "    Pass 2 done\n");
X}
X
Xdatas()
X{
Xregister int c, n;
Xint n1;
X
Xrewii(idfile);
Xswii(idfile);
X
Xfor( ; ; )
X	{
X	c = getic(&n1);
X	n = n1;
X	switch(c)
X		{
X		case ICEOF:
X			return;
X	
X		case ICMARK:
X			break;
X	
X		case ICBLANK:
X			putblank(n);
X			break;
X	
X		case ICNAME:
X			if(*ftnames[n] == '\0')
X				fatal1("no name for n=%d", n);
X			p2stmt(0);
X			p2key(FDATA);
X			p2str( ftnames[n] );
X			break;
X	
X		case ICOP:
X			p2str( ops[n] );
X			break;
X	
X		case ICCONST:
X			p2str( getsii(n) );
X			break;
X	
X		default:
X			fatal1("datas: invalid intermediate tag %d", c);
X		}
X	}
X}
X
Xbody(fileadd)
Xstruct fileblock **fileadd;
X{
Xint n1;
Xregister int n;
Xregister int c;
Xint prevc;
Xint ifn;
X
Xrewii(fileadd);
Xswii(fileadd);
X
Xprevc = 0;
Xifn = 0;
X
Xfor(;;)
X	{
X	c = getic(&n1);
X	n = n1;
X	switch(c)
X		{
X		case ICEOF:
X			return;
X
X		case ICBEGIN:
X			if(n != 0)
X				{
X				if(prevc)
X					p2key(FCONTINUE);
X				else	prevc = 1;
X				p2stmt( stnos[n] );
X				}
X			else if(!prevc)  p2stmt(0);
X			break;
X
X		case ICKEYWORD:
X			p2key(n);
X			if(n != FIF2)
X				break;
X			getic(&ifn);
X			if( indifs[ifn] )
X				skipuntil(ICMARK) ;
X			break;
X
X		case ICOP:
X			p2str( ops[n] );
X			break;
X
X		case ICNAME:
X			if(*ftnames[n]=='\0')
X				fatal1("no name for n=%d", n);
X			p2str( ftnames[n] );
X			break;
X
X		case ICCOMMENT:
X			if(prevc)
X				p2key(FCONTINUE);
X			p2com(n);
X			break;
X
X		case ICBLANK:
X			putblank(n);
X			break;
X
X		case ICCONST:
X			p2str( getsii(n) );
X			break;
X
X		case ICINDPTR:
X			n = indifs[n];
X
X		case ICLABEL:
X			p2str(" ");
X			p2int( stnos[n] );
X			break;
X
X		case ICMARK:
X			if( indifs[ifn] )
X				{
X				p2str(" ");
X				p2key(FGOTO);
X				p2int( stnos[ indifs[ifn] ] );
X				}
X			else
X				{
X				skipuntil(ICINDENT);
X				p2str(" ");
X				}
X			break;
X
X		case ICINDENT:
X			indent = n * INDENTSPACES;
X			p2indent(indent);
X			break;
X
X		default:
X			sprintf(msg, "Bad pass2 value %o,%o", c,n);
X			fatal(msg);
X			break;
X		}
X	if(c!=ICBEGIN && c!=ICINDENT)
X		prevc = 0;
X	}
X}
X
Xputname(p)
Xregister ptr p;
X{
Xregister int i;
X
Xif(p->vextbase)
X	{
X	putic(ICNAME, p->vextbase);
X	return;
X	}
X
Xfor(i=0 ; i<NFTNTYPES ; ++i)
X	if(p->vbase[i])
X		{
X		putic(ICNAME, p->vbase[i]);
X		return;
X		}
Xif(strlen(p->sthead->namep) <= XL)
X	fatal1("no fortran slot for name %s", p->sthead->namep);
X}
X
X
X
Xputconst(ty, p)
Xint ty;
Xchar *p;
X{
Xptr mkchcon();
X
Xif(ty != TYCHAR)
X	putsii(ICCONST,p);
Xelse	/* change character constant to a variable */
X	putname( mkchcon(p) );
X}
X
X
Xputzcon(p)
Xregister ptr p;
X{
Xchar buff[100];
Xsprintf(buff, "(%s,%s)", p->leftp, p->rightp);
Xputsii(ICCONST,buff);
X}
X
X
X
X
X
X
Xputcomment()
X{
Xregister ptr p;
X
Xfor(p = comments ; p ; p = p->nextp)
X	{
X	putsii(ICCOMMENT, p->datap);
X	cfree(p->datap);
X	}
Xfrchain(&comments);
X}
X
X
Xputblank(n)
Xint n;
X{
Xwhile(n-- > 0)
X	p2putc(' ');
X}
X
X
X
Xskipuntil(k)
Xint k;
X{
Xregister int i;
Xint n;
X
Xwhile( (i = getic(&n))!=k && i!=ICEOF)
X	if(i==ICCOMMENT || i==ICCONST)
X		getsii(n);
X}
X
X
Xp2int(n)	/* put an integer constant in the output */
Xint n;
X{
Xp2str( convic(n) );
X}
X
X
X
X
Xp2key(n)	/* print a keyword */
Xint n;
X{
Xp2str( verb[n] );
X}
X
X
X
Xp2str(s)	/* write a character string on the output */
Xchar *s;
X{
Xint n;
X
Xn = strlen(s);
Xif(nftnch==LINESPACES-1 && (n==1 || (n==2 && s[1]==' ')) )
X	p2putc(s[0]);
X
Xelse	{
X	if( n<=LINESPACES && nftnch+n>LINESPACES-1 )
X		p2line( min(LINESPACES-n , indent+INDENTSPACES) );
X
X	while(*s)
X		p2putc(*s++);
X	}
X}
X
X
X
Xp2stmt(n)	/* start a statement with label n */
Xint n;
X{
Xif(n > 0)
X	fprintf(codefile,"\n%4d  ", n);
Xelse	fprintf(codefile,"\n      ");
X
Xnftnch = 0;
Xnftncont = 0;
X}
X
X
Xp2com(n)		/* copy a comment */
Xint n;
X{
Xregister int k;
Xregister char *q;
X
Xq = getsii(n);
Xif(q[0] == '%')	/* a literal escape line */
X	{
X	putc('\n', codefile);
X	while(--n > 0)
X		putc(*++q, codefile);
X	}
Xelse	 /* actually a comment line */
X	{
X	++q;
X	--n;
X
X	do	{
X		k = (n>71 ? 71 : n);
X		fprintf(codefile, "\n");
X		putc( tailor.ftnsys==CRAY ? 'C' : 'c' , codefile);
X		while(k-- > 0)
X			putc(*q++, codefile);
X		n -= 71;
X		}
X		   while(n > 0);
X	}
X}
X
X
X
X
Xp2flush()
X{
Xif(nftnch > 0)
X	{
X	fprintf(codefile, "\n");
X	nftnch = 0;
X	}
X}
X
X
X
X
Xp2putc(c)
Xchar c;
X{
Xif(nftnch >= LINESPACES)	/* end of line */
X	p2line(0);
Xif(tailor.ftnsys == CRAY)
X	putc( islower(c) ? toupper(c) : c , codefile);
Xelse
X	putc(c, codefile);
X++nftnch;
X}
X
X
X
Xp2line(in)
Xint in;
X{
Xregister char contchar;
X
Xif(++nftncont > 19)
X	{
X	execerr("too many continuation lines", CNULL);
X	contchar = 'X';
X	}
Xif(tailor.ftncontnu == 1)
X	fprintf(codefile, "\n&");
Xelse	{	/* standard column-6 continuation */
X	if(nftncont < 20)
X		contchar = "0123456789ABCDEFGHIJ" [nftncont];
X	fprintf(codefile, "\n     %c", contchar);
X	}
X
Xnftnch = 0;
Xif(in > 0)
X	p2indent(in);
X}
X
X
X
Xp2indent(n)
Xregister int n;
X{
Xwhile(n-- > 0)
X	p2putc(' ');
X}

echo x - print.c
sed -e 's/^X//' > print.c << ''
X#include "defs"
X
Xchar *ops[ ] = 	{ "", "+", "-", "*", "/", "**",
X	".not. ", " .and. ", ".andand.", ".oror.", " .or. ",
X	" .eq. ", " .lt. ", " .gt. ", " .le. ", " .ge. ", " .ne. ",
X	"(", ")", " = ", ", " };
X
Xint opprecs[ ]	= { 0, 7, 7, 8, 8, 9, 5, 4, 4, 3, 3,
X		6, 6, 6, 6, 6, 6, 10, 10, 1, 0 };
X
Xchar *qualops[ ]	= { "", "->", ".", " of ", " sub " };
X
X
Xchar *classes[ ]	= { "", "arg ", "valarg ", "static ", "auto ",
X			"common ", "mos ", "external ", "statement function " };
X
Xchar *precs[ ]	= { "", "long " };
X
Xchar *types[ ]	= { "", "integer ", "real ", "double precision ", "logical ",
X			"complex ", "char ", "type " };
X
Xchar *ftntypes[]	= { "integer ", "real ", "logical ", "complex ",
X			"double precision ", 0, 0 };
X
X
Xchar *langs[]	= { "pfort", "ratfor", "efl"};
X
X
Xpropts()
X{
Xfprintf(diagfile, "Options: ");
Xfprintf(diagfile, "%s ", langs[langopt]);
Xfprintf(diagfile, "%s ", (dbgopt ? "debug" : "ndebug") );
Xfprintf(diagfile, "%s ", (dotsopt? "dotson" : "dotsoff") );
Xfprintf(diagfile, "\n");
X}
X
X
X
X
Xprexpr(e)
Xptr e;
X{
Xif(e)  prexp1(e, 0,0,0);
X}
X
X
X
X
X
Xprexp1(e, prec, subt, leftside)
Xregister ptr e;
Xint prec, subt, leftside;
X{
Xptr p, q;
Xint prec1, needpar;
X
Xneedpar = 0;
X
Xswitch(e->tag)
X	{
Xcase TERROR:
X	break;
X
Xcase TCONST:
X	TEST fprintf(diagfile, "%s", e->leftp);
X	if(e->rightp)
X		putzcon(e);
X	else
X		putconst(e->vtype, e->leftp);
X	break;
X
Xcase TFTNBLOCK:
X	putname(e);
X	break;
X
Xcase TNAME:
X	if(e->sthead == 0) fatal("name without entry");
X	TEST fprintf(diagfile, "%s", e->sthead->namep);
X	putname(e);
X	if(e->vsubs)
X		prexp1(e->vsubs, 0,0,0);
X	break;
X
Xcase TTEMP:
X	TEST fprintf(diagfile, "(fakename %o)", e);
X	putname(e);
X	break;
X
Xcase TLIST:
X	if(e->leftp == 0) break;
X	TEST fprintf(diagfile, "( ");
X	putic(ICOP, OPLPAR);
X	for(p=e->leftp ; p!=0 ; p = p->nextp)
X		{
X		prexp1(p->datap, 0,0,0);
X		if(p->nextp)
X			{
X			TEST fprintf(diagfile, " , ");
X			putic(ICOP, OPCOMMA);
X			}
X		}
X	TEST fprintf(diagfile, " )");
X	putic(ICOP, OPRPAR);
X	break;
X
Xcase TSTFUNCT:
X	fprintf(diagfile, "statement function ");
X	prexp1(e->leftp, 0,0,0);
X	TEST fprintf(diagfile, " = ");
X	putic(ICOP, OPEQUALS);
X	prexp1(e->rightp, 0,0,0);
X	break;
X
Xcase TAROP:
X	if(e->subtype==OPSTAR && e->leftp->tag!=TCONST && e->rightp->tag==TCONST)
X		{
X		q = e->leftp;
X		e->leftp = e->rightp;
X		e->rightp = q;
X		}
Xcase TLOGOP:
X	prec1 = opprecs[e->subtype];
X	goto print;
Xcase TNOTOP:
X	prec1 = 5;
X	if(prec > 1)	/* force parens */
X		needpar = 1;
X	goto print;
Xcase TNEGOP:
X	if(prec > 1)	/* force parens */
X		needpar = 1;
X	prec1 = 8;
X	goto print;
Xcase TASGNOP:
X	prec1 = 1;
X	goto print;
Xcase TRELOP:
X	prec1 = 6;
X	goto print;
Xcase TCALL:
X	prec1 = 10;
X	goto print;
Xcase TREPOP:
X	prec1 = 2;
X	goto print;
X
Xprint:
X	if(prec1 < prec )
X		needpar = 1;
X	else if(prec1 == prec)
X		if(e->needpar)
X			needpar = 1;
X		else if(subt == e->subtype)
X			needpar |= ! (e->tag==TLOGOP || leftside || subt==0
X					|| subt==OPPLUS || subt==OPSTAR);
X		else	needpar |=  ! (leftside || subt==OPPLUS || subt==OPSTAR);
X
X	if(needpar)
X		{
X		putic(ICOP,OPLPAR);
X		TEST fprintf(diagfile, "(");
X		}
X
X	if(e->rightp != 0)
X		{
X		prexp1(e->leftp, prec1, e->subtype, 1);
X		switch(e->tag) {
X		case TASGNOP:
X			TEST fprintf(diagfile, "=");
X			putic(ICOP, OPEQUALS);
X			if(e->subtype != 0)
X				prexp1(e->leftp, prec1, 0, 1);
X	
X		case TAROP:
X		case TNEGOP:
X		case TLOGOP:
X		case TNOTOP:
X		case TRELOP:
X			if(e->subtype)
X				{
X				TEST fprintf(diagfile, " %s ", ops[e->subtype]);
X				putic(ICOP, e->subtype);
X				}
X			break;
X	
X		case TCALL:
X			TEST fprintf(diagfile, " %s ", qualops[e->subtype]);
X			break;
X	
X		case TREPOP:
X			TEST fprintf(diagfile, "$");
X			break;
X			}
X
X		prexp1(e->rightp, prec1,e->subtype, 0);
X		}
X	else	{ /* e->rightp == 0 */
X		TEST fprintf(diagfile, " %s  ", ops[e->subtype]);
X		putic(ICOP, e->subtype);
X		prexp1(e->leftp, prec1,e->subtype, 0);
X		}
X	if(needpar)
X		{
X		putic(ICOP, OPRPAR);
X		TEST fprintf(diagfile, ")");
X		}
X	break;
X
Xdefault:
X	badtag("prexp1", e->tag);
X	break;
X	}
X}

echo x - simple.c
sed -e 's/^X//' > simple.c << ''
X#include <ctype.h>
X#include "defs"
X
X
X/* basic simplifying procedure */
X
Xptr simple(t,e)
Xint t;	/* take on the values LVAL, RVAL, and SUBVAL */
Xregister ptr e;	/* points to an expression */
X{
Xint tag, subtype;
Xptr lp, rp;
Xint ltag;
Xint lsubt;
Xptr p, e1;
Xptr exio(), exioop(), dblop(), setfield(), gentemp();
Xint a,b,c;
X
Xtop:
X
Xif(e == 0) return(0);
X
Xtag = e->tag;
Xsubtype = e->subtype;
Xif(lp = e->leftp)
X	{
X	ltag = lp->tag;
X	lsubt = lp->subtype;
X	}
Xrp = e->rightp;
X
XTEST fprintf(diagfile, "simple(%d; tag %d,%d)\n", t,tag,subtype);
X
Xswitch(tag){
X
Xcase TNOTOP:
X	switch(ltag) {
X
X	case TNOTOP:	/* not not = yes */
X		frexpblock(e);
X		e = lp->leftp;
X		frexpblock(lp);
X		goto top;
X
X	case TLOGOP:	/* de Morgan's Law */
X		lp->subtype = (OPOR+OPAND) - lp->subtype;
X		lp->leftp = mknode(TNOTOP,OPNOT,lp->leftp, PNULL);
X		lp->rightp=mknode(TNOTOP,OPNOT,lp->rightp, PNULL);
X		frexpblock(e);
X		e = lp;
X		goto top;
X
X	case TRELOP:	/* reverse the condition */
X		lp->subtype = (OPEQ+OPNE) - lp->subtype;
X		frexpblock(e);
X		e = lp;
X		goto top;
X
X	case TCALL:
X	case TASGNOP:
X		e->leftp = simple(RVAL,lp);
X
X	case TNAME:
X	case TFTNBLOCK:
X		lp = simple(RVAL,lp);
X
X	case TTEMP:
X		if(t == LVAL)
X			e = simple(LVAL,
X			      mknode(TASGNOP,0, gentemp(e->leftp), e));
X		break;
X
X	case TCONST:
X		if(equals(lp->leftp, ".false."))
X			e->leftp = copys(".true.");
X		else if(equals(lp->leftp, ".true."))
X			e->leftp = copys(".false.");
X		else goto typerr;
X
X		e->tag = TCONST;
X		e->subtype = 0;
X		cfree(lp->leftp);
X		frexpblock(lp);
X		break;
X
X	default:  goto typerr;
X		}
X	break;
X
X
X
X
Xcase TLOGOP: switch(subtype) {
X		case OPOR:
X		case OPAND:
X			goto binop;
X
X		case OP2OR:
X		case OP2AND:
X			lp = e->leftp = simple(RVAL, lp);
X			if(lp->tag != TTEMP)
X				lp = simple(RVAL,
X					mknode(TASGNOP,0, gent(TYLOG,0),lp));
X			return( simple(LVAL, mknode(TASGNOP,subtype,lp,rp)) );
X		default:
X			fatal("impossible logical operator");
X		}
X
Xcase TNEGOP:
X	lp = e->leftp = simple(RVAL,lp);
X	ltag = lp->tag;
X	lsubt = lp->subtype;
X
X	if(ltag==TNEGOP)
X		{
X		frexpblock(e);
X		e = lp->leftp;
X		frexpblock(lp);
X		goto top;
X		}
X	else	goto lvcheck;
X
Xcase TAROP:
Xcase TRELOP:
X
Xbinop:
X
X	e->leftp = simple(RVAL,lp);
X	lp = e->leftp;
X	ltag = lp->tag;
X	lsubt = lp->subtype;
X
X	e->rightp= simple(RVAL,rp);
X	rp = e->rightp;
X
X	if(tag==TAROP && isicon(rp,&b) )
X		{  /* simplify a*1, a/1 , a+0, a-0  */
X		if( ((subtype==OPSTAR||subtype==OPSLASH) && b==1) ||
X		    ((subtype==OPPLUS||subtype==OPMINUS) && b==0) )
X			{
X			frexpr(rp);
X			mvexpr(lp,e);
X			goto top;
X			}
X
X		if(isicon(lp, &a))	 /* try folding const op const */
X			{
X			e1 = fold(e);
X			if(e1!=e || e1->tag!=TAROP)
X				{
X				e = e1;
X				goto top;
X				}
X			}
X		if(ltag==TAROP && lp->needpar==0 && isicon(lp->rightp,&a) )
X			{ /* look for cases of (e op const ) op' const */
X
X			if( (subtype==OPPLUS||subtype==OPMINUS) &&
X			    (lsubt==OPPLUS||lsubt==OPMINUS) )
X				{ /*  (e +- const) +- const */
X				c = (subtype==OPPLUS ? 1 : -1) * b +
X				    (lsubt==OPPLUS? 1 : -1) * a;
X				if(c > 0)
X					subtype = OPPLUS;
X				else	{
X					subtype = OPMINUS;
X					c = -c;
X					}
X			fixexpr:
X				frexpr(rp);
X				frexpr(lp->rightp);
X				frexpblock(e);
X				e = lp;
X				e->subtype = subtype;
X				e->rightp = mkint(c);
X				goto top;
X				}
X
X			else if(lsubt==OPSTAR &&
X				( (subtype==OPSTAR) ||
X				    (subtype==OPSLASH && a%b==0)) )
X					{ /* (e * const ) (* or /) const */
X					c = (subtype==OPSTAR ? a*b : a/b );
X					subtype = OPSTAR;
X					goto fixexpr;
X					}
X			}
X		if(ltag==TAROP && (lsubt==OPPLUS || lsubt==OPMINUS) &&
X			subtype==OPSLASH && divides(lp,conval(rp)) )
X			{
X			e->leftp = mknode(TAROP,OPSLASH,lp->leftp, cpexpr(rp));
X			e->rightp = mknode(TAROP,OPSLASH,lp->rightp, rp);
X			e->subtype = lsubt;
X			goto top;
X			}
X		}
X
X	else if( tag==TRELOP && isicon(lp,&a) && isicon(rp,&b) )
X		{
X		e1 = fold(e);
X		if(e1!=e || e1->tag!=TRELOP)
X			{
X			e = e1;
X			goto top;
X			}
X		}
X
Xlvcheck:
X	if(t == LVAL)
X		e = simple(LVAL, mknode(TASGNOP,0, gentemp(e),e));
X	else if(t == SUBVAL)
X		{  /* test for legal Fortran c*v +-c  form */
X		if(tag==TAROP && (subtype==OPPLUS || subtype==OPMINUS))
X			if(rp->tag==TCONST && rp->vtype==TYINT)
X				{
X				if(!cvform(lp))
X					e->leftp = simple(SUBVAL, lp);
X				}
X			else goto makesub;
X		else if( !cvform(e) ) goto makesub;
X		}
X	break;
X
Xcase TCALL:
X	if( lp->tag!=TFTNBLOCK && ioop(lp->sthead->namep) )
X		{
X		e = exioop(e, YES);
X		exlab(0);
X		break;
X		}
X	e->rightp = simple(RVAL, rp);
X	if(t == SUBVAL)
X		goto makesub;
X	if(t == LVAL)
X		e = simple(RVAL, mknode(TASGNOP,0, gentemp(e),e));
X	break;
X
X
Xcase TNAME:
X	if(e->voffset)
X		fixsubs(e);
X	if(e->vsubs)
X		e->vsubs = simple(SUBVAL, e->vsubs);
X	if(t==SUBVAL && !vform(e))
X		goto makesub;
X
Xcase TTEMP:
Xcase TFTNBLOCK:
Xcase TCONST:
X	if(t==SUBVAL && e->vtype!=TYINT)
X		goto makesub;
X	break;
X
Xcase TASGNOP:
X	lp = e->leftp = simple(LVAL,lp);
X	if(subtype==OP2OR || subtype==OP2AND)
X		e = dblop(e);
X
X	else	{
X		rp = e->rightp = simple(RVAL,rp);
X		if(e->vtype == TYCHAR)
X			excall(mkcall(mkftnblock(TYSUBR,"ef1asc"), arg4(cpexpr(lp),rp)));
X		else if(e->vtype == TYSTRUCT)
X			{
X			if(lp->vtypep->strsize != rp->vtypep->strsize)
X				fatal("simple: attempt to assign incompatible structures");
X			e1 = mkchain(cpexpr(lp),mkchain(rp,
X				mkchain(mkint(lp->vtypep->strsize),CHNULL)));
X			excall(mkcall(mkftnblock(TYSUBR,"ef1ass"),
X				mknode(TLIST, 0, e1, PNULL) ));
X			}
X		else if(lp->vtype == TYFIELD)
X			lp = setfield(e);
X		else	{
X			if(subtype != OPASGN)	/* but is one of += etc */
X				{
X				rp = e->rightp = simple(RVAL, mknode(
X					(subtype<=OPPOWER?TAROP:TLOGOP),subtype,
X					cpexpr(e->leftp),e->rightp));
X				e->subtype = OPASGN;
X				}
X			exlab(0);
X			prexpr(e);
X			frexpr(rp);
X			}
X		frexpblock(e);
X		e = lp;
X		if(t == SUBVAL) goto top;
X		}
X
X	break;
X
Xcase TLIST:
X	for(p=lp ; p ; p = p->nextp)
X		p->datap = simple(t, p->datap);
X	break;
X
Xcase TIOSTAT:
X	e = exio(e, 1);
X	break;
X
Xdefault:
X	break;
X	}
X
Xreturn(e);
X
X
Xtyperr:
X	exprerr("type match error", CNULL);
X	return(e);
X
Xmakesub:
X	if(t==SUBVAL && e->vtype!=TYINT)
X		warn1("Line %d. Non-integer subscript", yylineno);
X	return( simple(RVAL, mknode(TASGNOP,0,gent(TYINT,PNULL),e)) );
X}
X
Xptr fold(e)
Xregister ptr e;
X{
Xint a, b, c;
Xregister ptr lp, rp;
X
Xlp = e->leftp;
Xrp = e->rightp;
X
Xif(lp->tag!=TCONST && lp->tag!=TNEGOP)
X	return(e);
X
Xif(rp->tag!=TCONST && rp->tag!=TNEGOP)
X	return(e);
X
X
Xswitch(e->tag)
X	{
X	case TAROP:
X		if( !isicon(lp,&a) || !isicon(rp,&b) )
X			return(e);
X
X		switch(e->subtype)
X			{
X			case OPPLUS:
X				c = a + b;break;
X			case OPMINUS:
X				c = a - b; break;
X			case OPSTAR:
X				c = a * b; break;
X			case OPSLASH:
X				if(a%b!=0 && (a<0 || b<0) )
X					return(e);
X				c = a / b; break;
X			case OPPOWER:
X				return(e);
X			default:
X				fatal("fold: illegal binary operator");
X			}
X		frexpr(e);
X
X		if(c >= 0)
X			return( mkint(c) );
X		else	return(mknode(TNEGOP,OPMINUS, mkint(-c), PNULL) );
X
X	case TRELOP:
X		if( !isicon(lp,&a) || !isicon(rp,&b) )
X			return(e);
X		frexpr(e);
X
X		switch(e->subtype)
X			{
X			case OPEQ:
X				c =  a == b; break;
X			case OPLT:
X				c = a < b ; break;
X			case OPGT:
X				c = a > b; break;
X			case OPLE:
X				c = a <= b; break;
X			case OPGE:
X				c = a >= b; break;
X			case OPNE:
X				c = a != b; break;
X			default:
X				fatal("fold: invalid relational operator");
X			}
X		return( mkconst(TYLOG, (c ? ".true." : ".false.")) );
X
X
X	case TLOGOP:
X		if(lp->vtype!=TYLOG || rp->vtype!=TYLOG)
X			return(e);
X		a = equals(lp->leftp, ".true.");
X		b = equals(rp->leftp, ".true.");
X		frexpr(e);
X
X		switch(e->subtype)
X			{
X			case OPAND:
X			case OP2AND:
X				c = a & b; break;
X			case OPOR:
X			case OP2OR:
X				c = a | b; break;
X			default:
X				fatal("fold: invalid logical operator");
X			}
X		return( mkconst(TYLOG, (c? ".true." : ".false")) );
X
X	default:
X		return(e);
X	}
X}
X
X#define TO   + 100*
X
X
Xptr coerce(t,e)	/* coerce expression  e  to type  t */
Xint t;
Xregister ptr e;
X{
Xregister int et;
Xint econst;
Xchar buff[100];
Xchar *s, *s1;
Xptr conrep(), xfixf();
X
Xif(e->tag == TNEGOP)
X	{
X	e->leftp = coerce(t, e->leftp);
X	goto settype;
X	}
X
Xet = e->vtype;
Xeconst = (e->tag == TCONST);
XTEST fprintf(diagfile, "coerce type %d to type %d\n", et, t);
Xif(t == et)
X	return(e);
X
Xswitch( et TO t )
X	{
X	case TYCOMPLEX TO TYINT:
X	case TYLREAL TO TYINT:
X		e = coerce(TYREAL,e);
X	case TYREAL TO TYINT:
X		if(econst)
X			e = xfixf(e);
X		if(e->vtype != TYINT)
X			e = mkcall(builtin(TYINT,"ifix"), arg1(e));
X		break;
X
X	case TYINT TO TYREAL:
X		if(econst)
X			{
X			e->leftp = conrep(e->leftp, ".");
X			goto settype;
X			}
X		e = mkcall(builtin(TYREAL,"float"), arg1(e));
X		break;
X
X	case TYLREAL TO TYREAL:
X		if(econst)
X			{
X			for(s=e->leftp ; *s && *s!='d';++s)
X				;
X			*s = 'e';
X			goto settype;
X			}
X		e = mkcall(builtin(TYREAL,"sngl"), arg1(e));
X		break;
X
X	case TYCOMPLEX TO TYREAL:
X		if(econst)
X			{
X			s1 = (char *)(e->leftp) + 1;
X			s = buff;
X			while(*s1!=',' && *s1!='\0')
X				*s1++ = *s++;
X			*s = '\0';
X			cfree(e->leftp);
X			e->leftp = copys(buff);
X			goto settype;
X			}
X		else
X			e = mkcall(mkftnblock(TYREAL,"real"), arg1(e));
X		break;
X
X	case TYINT TO TYLREAL:
X		if(econst)
X			{
X			e->leftp = conrep(e->leftp,"d0");
X			goto settype;
X			}
X	case TYCOMPLEX TO TYLREAL:
X		e = coerce(TYREAL,e);
X	case TYREAL TO TYLREAL:
X		if(econst)
X			{
X			for(s=e->leftp ; *s && *s!='e'; ++s)
X				;
X			if(*s == 'e')
X				*s = 'd';
X			else	e->leftp = conrep(e->leftp,"d0");
X			goto settype;
X			}
X		e = mkcall(builtin(TYLREAL,"dble"), arg1(e));
X		break;
X
X	case TYINT TO TYCOMPLEX:
X	case TYLREAL TO TYCOMPLEX:
X		e = coerce(TYREAL, e);
X	case TYREAL TO TYCOMPLEX:
X		if(e->tag == TCONST)
X			{
X			sprintf(buff, "(%s,0.)", e->leftp);
X			cfree(e->leftp);
X			e->leftp = copys(buff);
X			goto settype;
X			}
X		else
X			e = mkcall(builtin(TYCOMPLEX,"cmplx"),
X				arg2(e, mkconst(TYREAL,"0.")));
X		break;
X
X
X	default:
X		goto mismatch;
X	}
X
Xreturn(e);
X
X
Xmismatch:
X	exprerr("impossible conversion", "");
X	frexpr(e);
X	return( errnode() );
X
X
Xsettype:
X	e->vtype = t;
X	return(e);
X}
X
X
X
X/* check whether expression is in form c, v, or v*c */
Xcvform(p)
Xregister ptr p;
X{
Xswitch(p->tag)
X	{
X	case TCONST:
X		return(p->vtype == TYINT);
X
X	case TNAME:
X		return(vform(p));
X
X	case TAROP:
X		if(p->subtype==OPSTAR && p->rightp->tag==TCONST
X		    && p->rightp->vtype==TYINT && vform(p->leftp))
X			return(1);
X
X	default:
X		return(0);
X	}
X}
X
X
X
X
X/* is p a simple integer variable */
Xvform(p)
Xregister ptr p;
X{
Xreturn( p->tag==TNAME && p->vtype==TYINT && p->vdim==0
X     && p->voffset==0 && p->vsubs==0) ;
X}
X
X
X
Xptr dblop(p)
Xptr p;
X{
Xptr q;
X
Xbgnexec();
Xif(p->subtype == OP2OR)
X	q = mknode(TNOTOP,OPNOT, cpexpr(p->leftp), PNULL);
Xelse	q = cpexpr(p->leftp);
X
Xpushctl(STIF, q);
Xbgnexec();
Xexasgn(cpexpr(p->leftp), OPASGN,  p->rightp);
Xifthen();
Xpopctl();
Xaddexec();
Xreturn(p->leftp);
X}
X
X
X
X
Xdivides(a,b)
Xptr a;
Xint b;
X{
Xif(a->vtype!=TYINT)
X	return(0);
X
Xswitch(a->tag)
X	{
X	case TNEGOP:
X		return( divides(a->leftp,b) );
X
X	case TCONST:
X		return( conval(a) % b == 0);
X
X	case TAROP:
X		switch(a->subtype)
X			{
X			case OPPLUS:
X			case OPMINUS:
X				return(divides(a->leftp,b)&&
X					   divides(a->rightp,b) );
X
X			case OPSTAR:
X				return(divides(a->rightp,b));
X
X			default:
X				return(0);
X			}
X	default:
X		return(0);
X	}
X/* NOTREACHED */
X}
X
X/* truncate floating point constant to integer */
X
X#define MAXD 100
X
Xptr xfixf(e)
Xstruct exprblock *e;
X{
Xchar digit[MAXD+1];	/* buffer into which digits are placed */
Xchar *first;	/* points to first nonzero digit */
Xregister char *end;	/* points at position past last digit */
Xregister char *dot;	/* decimal point is immediately to left of this digit */
Xregister char *s;
Xint expon;
X
Xdot = NULL;
Xend = digit;
Xexpon = 0;
X
Xfor(s = e->leftp ; *s; ++s)
X	if( isdigit(*s) )
X		{
X		if(end-digit > MAXD)
X			return(e);
X		*end++ = *s;
X		}
X	else if(*s == '.')
X		dot = end;
X	else if(*s=='d' || *s=='e')
X		{
X		expon = convci(s+1);
X		break;
X		}
X	else fatal1("impossible character %d in floating constant", *s);
X
Xif(dot == NULL)
X	dot = end;
Xdot += expon;
Xif(dot-digit > MAXD)
X	return(e);
Xfor(first = digit; first<end && *first=='0' ; ++first)
X	;
Xif(dot<=first)
X	{
X	dot = first+1;
X	*first = '0';
X	}
Xelse	while(end < dot)
X		*end++ = '0';
X*dot = '\0';
Xcfree(e->leftp);
Xe->leftp = copys(first);
Xe->vtype = TYINT;
Xreturn(e);
X}

echo x - struct.c
sed -e 's/^X//' > struct.c << ''
X#include "defs"
X
Xoffsets(s)
Xregister ptr s;
X{
Xregister ptr p, q;
Xptr t;
Xptr prevp;
Xint n;
Xint size, align, mask, nelt;
Xdouble rshift;
X
Xs->stralign = 1;
Xs->strsize = 0;
Xs->basetypes = 0;
Xprevp = 0;
Xrshift = 0;
X
Xfor(p = s->strdesc ; p ; p = p->nextp)
X	{
X	q = p->datap;
X	if(q->vclass != 0)
X		dclerr("attempt to give storage class to mos",
X			q->namep);
X	else  q->vclass = CLMOS;
X	if(q->vtype == TYUNDEFINED)
X		impldecl(q);
X
X	sizalign(q, &size, &align, &mask);
X	s->strsize = evenoff(s->strsize, align);
X	q->voffset = mkint(s->strsize);
X	/* sloppy formula */
X	nelt = 1;
X	if(t = q->vdim)
X	    for(t = t->datap ; t ; t = t->nextp)
X		{
X		if(t->upperb == 0) continue;
X		n = conval(t->upperb);
X		if(t->lowerb)
X			n -= conval(t->lowerb)-1;
X		nelt *= n;
X		}
X	if(q->vtype==TYFIELD && q->vdim==0 &&
X	     (n=conval(q->vtypep->frange))*rshift<=fieldmax && rshift>0)
X		{
X		prevp->vtypep->fanymore = 1;
X		q->vtypep->frshift = mkint( (int) rshift );
X		rshift *= n;
X		cfree(q->voffset);
X		q->voffset = mkint(s->strsize - tailor.ftnsize[FTNINT]);
X		}
X	else	{
X		if(q->vdim!=0 && q->vtype==TYFIELD)
X			q->vtype = TYINT;
X		rshift = (q->vtype==TYFIELD ? n : 0);
X		s->strsize +=  nelt * evenoff(size,align);
X		s->stralign = lcm(s->stralign, align);
X		s->basetypes |= mask;
X		}
X	prevp = q;
X	}
X}
X
X
Xlcm(a,b)
Xint a,b;
X{
Xint ab, c;
X
Xif( (ab = a*b) == 0) return(0);
X
Xwhile(b)
X	{
X	c = a%b;
X	a = b;
X	b = c;
X	}
X
Xreturn(ab/a);
X}
X
X
X
X
X
Xsizalign(p, s, a, m)
Xregister ptr p;
Xint *s;
Xint *a;
Xint *m;
X{
Xregister int k, t;
X
Xif(p->tag == TERROR)
X	return;
Xif(p->tag!=TNAME && p->tag!=TTEMP && p->tag!=TFTNBLOCK)
X	badtag("sizalign", p->tag);
Xswitch(t = p->vtype)
X	{
X	case TYFIELD:
X	case TYINT:
X	case TYREAL:
X	case TYLREAL:
X	case TYCOMPLEX:
X	case TYLOG:
X		k = eflftn[t];
X		*s = tailor.ftnsize[k];
X		*a = tailor.ftnalign[k];
X		*m = ftnmask[k];
X		return;
X
X	case TYLCOMPLEX:
X		if(tailor.lngcxtype)
X			{
X			k = FTNDCOMPLEX;
X			*s = tailor.ftnsize[FTNDCOMPLEX];
X			}
X		else
X			{
X			k = FTNDOUBLE;
X			*s = 2*tailor.ftnsize[k];
X			}
X		*a = tailor.ftnalign[k];
X		*m = ftnmask[k];
X		return;
X
X	case TYSTRUCT:
X		*s = p->vtypep->strsize;
X		*a = p->vtypep->stralign;
X		*m = p->vtypep->basetypes;
X		return;
X
X	case TYCHAR:
X		*s = tailor.ftnsize[FTNINT] *
X			ceil(conval(p->vtypep), tailor.ftnchwd);
X		*a = tailor.ftnalign[FTNINT];
X		*m = ftnmask[FTNINT];
X		return;
X
X	case TYSUBR:
X		*s = 1;
X		*a = 1;
X		*m = 1;
X		dclerr("subroutine name as variable", p->sthead->namep);
X		return;
X
X	default:
X		fatal1("sizalign: invalid type %d", t);
X	}
X}
X
X
X
Xevenoff(a,b)	/* round a up to a multiple of b */
Xint a,b;
X{
Xreturn(b * ceil(a,b));
X}
X
X
Xceil(a,b)
Xint a,b;
X{
Xreturn( (a+b-1)/b );
X}
X
X
X
X
Xptr esizeof(type, typep, dim)
Xregister int type;
Xregister ptr typep;
Xptr dim;
X{
Xregister int k;
X
Xswitch(type)
X	{
X	case TYFIELD:
X	case TYINT:
X	case TYREAL:
X	case TYLREAL:
X	case TYCOMPLEX:
X	case TYLCOMPLEX:
X	case TYLOG:
X		k = tailor.ftnsize[ eflftn[type] ];
X		break;
X
X	case TYSTRUCT:
X		k = typep->strsize;
X		break;
X
X	case TYCHAR:
X		k = tailor.ftnsize[FTNINT] * ceil(conval(typep), tailor.ftnchwd);
X		break;
X
X	default:
X		exprerr("invalid sizeof", "");
X		k = 0;
X	}
X/* debug version.  should multiply by dimension */
Xreturn( mkint(k) );
X}
X
X
X
Xptr elenof(type, typep, dim)
Xregister int type;
Xregister ptr typep;
Xptr dim;
X{
Xif(type == TYCHAR)
X	return( mkint( conval(typep) ) );
Xexprerr("invalid lengthof", "");
Xreturn( mkint(0) );
X/* debug version.  should multiply by dimension */
X}

echo x - symtab.c
sed -e 's/^X//' > symtab.c << ''
X#include "defs"
X
X#ifdef HASHEDTABLE
X/* Basic symbol table maintainer.  Action depends on t:
Xt = -1	Remove name from table
Xt =  0	Put name in table if not there.  Copy name string
Xt =  1	Find name in table if there, otherwise return 0.
Xt =  2	Put name in table if not there.  Do not copy name
X*/
X
Xstruct stentry *hashtab[MAXEFLNAMES+1];
Xstruct stentry **hashend	= hashtab+MAXEFLNAMES+1;
X
X#define NEXT(x) (++x<hashend ? x : hashtab )
X
Xstruct stentry *name(s,t)
Xchar *s;
Xint t;
X{
Xint hash;
Xregister struct stentry *p, **hp;
Xchar *copys();
X
Xhash = hashfunct(s);
X
Xfor(hp = hashtab + hash; (p = *hp) ; hp = NEXT(hp) )
X	if(hash==p->hashval && equals(s,p->namep))
X		switch(t)
X		{
X		case -1:
X			cfree(p->namep);
X			cfree(p);
X			delhash(hp);
X			--neflnames;
X			return(0);
X
X		case 0:
X		case 1:
X		case 2:
X			return(p);
X
X		default:
X			fatal("name: illegal argument");
X		}
X
X/* not in table */
Xswitch(t)
X	{
X	case -1:
X		fatal1("cannot delete nonexistent name %s from symbol table", s);
X
X	case 1:
X		return(0);
X
X	case 0:
X	case 2:
X		if(++neflnames >= MAXEFLNAMES)
X			fatal("hash table full");
X
X		*hp = p = ALLOC(stentry);
X		p->namep = (t==0 ? copys(s) : s);
X		p->hashval = hash;
X		return(p);
X
X	default:
X		fatal("illegal call to name");
X	}
X}
X
X
X
Xhashfunct(s)
Xregister char *s;
X{
Xregister int h;
X
Xh = 0;
Xwhile(*s)
X	h += *s++;
X
Xreturn( h % (MAXEFLNAMES+1) );
X}
X
X
Xdelhash(hp)
Xstruct stentry **hp;
X{
Xstruct stentry **hq, **hvp;
X
Xfor ( ; ; )
X	{
X	*hp = 0;
X	hq = hp;
X	for(hp = NEXT(hp) ; *hp &&
X		( (hq < (hvp = hashtab + (*hp)->hashval) && hvp<=hp)
X		|| (hp<hq && hq<hvp) || (hvp<=hp && hp<hq) ) ;
X		hp = NEXT(hp) )
X			;
X	if(*hp == 0)
X		return;
X	*hq = *hp;
X	}
X}
X#endif
X
X#ifndef HASHEDTABLE
X/* Basic symbol table maintainer.  Action depends on t:
Xt = -1	Remove name from table
Xt =  0	Put name in table if not there.  Copy name string
Xt =  1	Find name in table if there, otherwise return 0.
Xt =  2	Put name in table if not there.  Do not copy name
X*/
X
Xstruct stentry *hashtab[MAXEFLNAMES];
Xstruct stentry **hashend hashtab;
X
Xname(s,t)
Xchar *s;
Xint t;
X{
Xint hash;
Xregister struct stentry *p, **hp;
Xchar *copys();
X
Xhash = hashfunct(s);
X
Xfor(hp = hashtab ; hp<hashend ; ++hp)
X	if( (p = *hp) && hash==p->hashval &&  equals(s,p->namep))
X		switch(t)
X		{
X		case -1:
X			cfree(p->namep);
X			cfree(p);
X			*hp = 0;
X			return(0);
X
X		case 0:
X		case 1:
X		case 2:
X			return(p);
X
X		default:
X			fatal("name: illegal argument");
X		}
X
X/* not in table */
Xswitch(t)
X	{
X	case -1:
X		fatal1("cannot delete nonexistent name %s from symbol table", s);
X
X	case 1:
X		return(0);
X
X	case 0:
X	case 2:
X		/* look for an empty slot */
X		for(hp = hashtab ; hp<hashend && *hp!=0 ; ++hp)
X			;
X
X		if(hp == hashend)
X			if(++neflnames >= MAXEFLNAMES)
X				fatal("hash table full");
X			else ++hashend;
X
X		*hp = p = ALLOC(stentry);
X		p->namep = (t==0 ? copys(s) : s);
X		p->hashval = hash;
X		return(p);
X
X	default:
X		fatal("illegal call to name");
X	}
X}
X
X
X
Xhashfunct(s)
Xregister char *s;
X{
Xregister int h;
X
Xh = 0;
Xwhile(*s)
X	h = *s++;
X
Xreturn(h);
X}
X#endif

echo x - tailor.c
sed -e 's/^X//' > tailor.c << ''
X#include "defs"
X
X
Xsetopt(p,q)
Xchar *p;
Xchar *q;
X{
Xint qval;
Xqval = (q!=NULL) && ( equals(q, "yes") || equals(q, "on") );
X
Xif(equals(p,"debug")) dbgopt = 1;
Xelse if(equals(p,"ndebug")) dbgopt = 0;
Xelse if(equals(p,"pfort")) langopt = 0;
Xelse if(equals(p,"ratfor")) langopt = 1;
Xelse if(equals(p,"efl")) langopt = 2;
Xelse if(equals(p,"dots"))
X	dotsopt = qval;
Xelse if(equals(p,"ioerror"))
X	{
X	if(equals(q,"none"))
X		tailor.errmode = IOERRNONE;
X	else if(equals(q,"ibm"))
X		tailor.errmode = IOERRIBM;
X	else if(equals(q,"fortran77"))
X		tailor.errmode = IOERRFORT77;
X	else execerr("unknown ioerror option %s", q);
X	}
Xelse if(equals(p, "system"))
X	{
X	register struct system *sysp;
X	for(sysp = systab ; sysp->sysname ; ++sysp)
X		if( equals(q, sysp->sysname) )
X			break;
X
X	if(sysp->sysname)
X		tailinit(sysp);
X	else
X		execerr("unknown system %s", q);
X	}
Xelse if(equals(p, "continue"))
X		tailor.ftncontnu = equals(q, "column1");
Xelse if(equals(p, "procheader"))
X	tailor.procheader = (q ? copys(q) : 0);
Xelse if(equals(p, "hollincall"))
X	tailor.hollincall = qval;
Xelse if(equals(p, "longcomplextype"))
X	{
X	tailor.lngcxtype = (q ? copys(q) : CNULL);
X	if(qval)
X		eflftn[TYLCOMPLEX] = FTNDCOMPLEX;
X	}
Xelse if(equals(p, "longcomplexprefix"))
X	tailor.lngcxprefix = (q ? copys(q) : CNULL);
Xelse if(equals(p, "fortran77"))
X	{
X	if(tailor.ftn77 = (q==NULL || qval) )
X		tailor.errmode = IOERRFORT77;
X	else if(tailor.errmode == IOERRFORT77)
X		tailor.errmode = IOERRNONE;
X	}
X
Xelse if( !tailop(p,q) )
X	execerr("unknown option %s", p);
X
Xif(langopt==2)
X	setdot(dotsopt);
Xelse if(langopt==1)
X	setdot(1);
X}
X
X
X
X
Xtailinit(sysp)
Xregister struct system *sysp;
X{
Xregister int sysf = sysp->sysno;
Xtailor.ftncontnu = (sysf==UNIX);
Xtailor.ftnsys = sysf;
Xtailor.ftnin = 5;
Xtailor.ftnout = 6;
Xtailor.errmode = (sysf==UNIX ? IOERRFORT77 : IOERRIBM);
Xtailor.charcomp = 2;
Xtailor.hollincall = YES;
Xtailor.deltastno = 1;
Xtailor.dclintrinsics = YES;
X
Xtailsize(sysp->chperwd);
Xtailfmt(sysp->idig, sysp->rdig, sysp->ddig);
X}
X
X
X
X
X
Xtailsize(wordsize)
Xint wordsize;
X{
Xint i;
X
Xtailor.ftnchwd = wordsize;
Xtailor.ftnsize[FTNINT] = wordsize;
Xtailor.ftnsize[FTNREAL] = wordsize;
Xtailor.ftnsize[FTNLOG] = wordsize;
Xtailor.ftnsize[FTNCOMPLEX] = 2*wordsize;
Xtailor.ftnsize[FTNDOUBLE] = 2*wordsize;
Xtailor.ftnsize[FTNDCOMPLEX] = 2*wordsize;
X
Xfor(i = 0 ; i<NFTNTYPES ; ++i)
X	tailor.ftnalign[i] = tailor.ftnsize[i];
X}
X
X
X
X
Xtailfmt(idig, rdig, ddig)
Xint idig, rdig, ddig;
X{
Xsprintf(msg, "i%d", idig);
Xtailor.dfltfmt[TYINT] = copys(msg);
X
Xsprintf(msg, "e%d.%d", rdig+8, rdig);
Xtailor.dfltfmt[TYREAL] = copys(msg);
X
Xsprintf(msg, "d%d.%d", ddig+8, ddig);
Xtailor.dfltfmt[TYLREAL] = copys(msg);
X
Xsprintf(msg, "1h(,1p%s,2h, ,%s,1h)",
X	tailor.dfltfmt[TYREAL], tailor.dfltfmt[TYREAL]);
Xtailor.dfltfmt[TYCOMPLEX] = copys(msg);
X
Xsprintf(msg, "1h(,1p%s,2h, ,%s,1h)",
X	tailor.dfltfmt[TYLREAL], tailor.dfltfmt[TYLREAL]);
Xtailor.dfltfmt[TYLCOMPLEX] = copys(msg);
X
Xtailor.dfltfmt[TYLOG] = "l2";
X}
X
X
X
X
Xtailop(n,v)
Xchar *n, *v;
X{
Xint val;
Xstruct itable { char *optn; int *ioptloc; } *ip;
Xstruct ctable { char *optn; char **coptloc; } *cp;
Xstatic struct ctable formats[ ] =  {
X	"iformat",	&tailor.dfltfmt[TYINT],
X	"rformat",	&tailor.dfltfmt[TYREAL],
X	"dformat",	&tailor.dfltfmt[TYLREAL],
X	"zformat",	&tailor.dfltfmt[TYCOMPLEX],
X	"zdformat",	&tailor.dfltfmt[TYLCOMPLEX],
X	"lformat",	&tailor.dfltfmt[TYLOG],
X	0, 0  };
X
Xstatic struct itable ints[ ] = {
X	"ftnin",	&tailor.ftnin,
X	"ftnout",	&tailor.ftnout,
X	"charperint",  &tailor.ftnchwd,
X	"charcomp",	&tailor.charcomp,
X	"deltastno",	&tailor.deltastno,
X	"dclintrinsics",	&tailor.dclintrinsics,
X	"isize",	&tailor.ftnsize[FTNINT],
X	"rsize",	&tailor.ftnsize[FTNREAL],
X	"dsize",	&tailor.ftnsize[FTNDOUBLE],
X	"lsize",	&tailor.ftnsize[FTNLOG],
X	"zsize",	&tailor.ftnsize[FTNCOMPLEX],
X	"ialign",	&tailor.ftnalign[FTNINT],
X	"ralign",	&tailor.ftnalign[FTNREAL],
X	"dalign",	&tailor.ftnalign[FTNDOUBLE],
X	"lalign",	&tailor.ftnalign[FTNLOG],
X	"zalign",	&tailor.ftnalign[FTNCOMPLEX],
X	0, 0 };
X
Xfor(cp = formats; cp->optn ; ++cp)
X	if(equals(n, cp->optn))
X		{
X		*(cp->coptloc) = copys(v);
X		return(1);
X		}
X
Xfor(ip = ints ; ip->optn ; ++ip)
X	if(equals(n, ip->optn))
X		{
X		if( equals(v, "yes") || equals(v, "on") )
X			val = 1;
X		else if( equals(v, "no") || equals(v, "off") )
X			val = 0;
X		else	val = convci(v);
X		*(ip->ioptloc) = val;
X		return(1);
X		}
X
Xreturn(0);
X}

echo x - temp.c
sed -e 's/^X//' > temp.c << ''
X#include "defs"
X
Xptr gentemp(t)
Xptr t;
X{
Xregister ptr oldp;
Xregister ptr p;
Xregister ptr q;
Xint ttype;
Xptr ttypep, tdim;
X
X/* search the temporary list for a matching type */
X
Xttype = t->vtype;
Xttypep = t->vtypep;
Xtdim = t->vdim;
X
Xfor(oldp = &tempvarlist ; p = oldp->nextp ; oldp = p)
X	if( (q = p->datap) && (q->vtype == ttype) &&
X	  (q->vtypep == ttypep) && eqdim(q->vdim,tdim) )
X		{
X		oldp->nextp = p->nextp;
X		break;
X		}
X
Xif(p == PNULL)
X	{
X	q = allexpblock();
X	q->tag = TTEMP;
X	q->subtype = t->subtype;
X	q->vtype = ttype;
X	q->vclass = t->vclass;
X	q->vtypep = ( ttypep ? cpexpr(ttypep) : PNULL);
X	q->vdim = tdim;
X	mkftnp(q);	/* assign fortran types */
X
X	p = mkchain(q, CHNULL);
X	p->datap = q;
X	}
X
Xp->nextp = thisexec->temps;
Xthisexec->temps = p;
X
Xreturn( cpexpr(q) );
X/* need a copy of the block for the temporary list and another for use */
X}
X
X
Xptr gent(t,tp)  /* make a temporary of type t, typepointer tp */
Xint t;
Xptr tp;
X{
Xstatic struct varblock model;
X
Xmodel.vtype = t;
Xmodel.vtypep = tp;
X
Xreturn( gentemp(&model) );
X}

echo x - tokdefs
sed -e 's/^X//' > tokdefs << ''
X#define EOS 1
X#define NEWLINE 2
X#define LPAR 3
X#define RPAR 4
X#define LBRACK 5
X#define RBRACK 6
X#define COMMA 7
X#define COLON 8
X#define ASGNOP 9
X#define REPOP 10
X#define OR 11
X#define AND 12
X#define NOT 13
X#define RELOP 14
X#define ADDOP 15
X#define MULTOP 16
X#define POWER 17
X#define DOUBLEADDOP 18
X#define ARROW 19
X#define QUALOP 20
X#define NAME 21
X#define OPTNAME 22
X#define STRUCTNAME 23
X#define COMNAME 24
X#define CONST 25
X#define COMMON 26
X#define INTERNAL 27
X#define EXTERNAL 28
X#define AUTOMATIC 29
X#define STATIC 30
X#define VALUE 31
X#define PROCEDURE 32
X#define BLOCKDATA 33
X#define OPTION 34
X#define INCLUDE 35
X#define DEFINE 36
X#define END 37
X#define INTEGER 38
X#define REAL 39
X#define COMPLEX 40
X#define LOGICAL 41
X#define CHARACTER 42
X#define STRUCT 43
X#define FIELD 44
X#define ARRAY 45
X#define DIMENSION 46
X#define LONG 47
X#define SHORT 48
X#define INITIAL 49
X#define EQUIVALENCE 50
X#define IMPLICIT 51
X#define DEBUG 52
X#define IF 53
X#define ELSE 54
X#define WHILE 55
X#define UNTIL 56
X#define REPEAT 57
X#define DO 58
X#define FOR 59
X#define SWITCH 60
X#define CASE 61
X#define DEFAULT 62
X#define GO 63
X#define GOTO 64
X#define BREAK 65
X#define EXIT 66
X#define NEXT 67
X#define RETURN 68
X#define CONTINUE 69
X#define CALL 70
X#define DOUBLE 71
X#define PRECISION 72
X#define DOUBLEPRECISION 73
X#define SIZEOF 74
X#define LENGTHOF 75
X#define LETTER 76
X#define READ 77
X#define WRITE 78
X#define READBIN 79
X#define WRITEBIN 80
X#define TRUE 81
X#define FALSE 82
X#define ESCAPE 83

echo x - tokens
sed -e 's/^X//' > tokens << ''
XEOS
XNEWLINE
XLPAR
XRPAR
XLBRACK
XRBRACK
XCOMMA
XCOLON
XASGNOP
XREPOP
XOR
XAND
XNOT
XRELOP
XADDOP
XMULTOP
XPOWER
XDOUBLEADDOP
XARROW
XQUALOP
XNAME
XOPTNAME
XSTRUCTNAME
XCOMNAME
XCONST
XCOMMON
XINTERNAL
XEXTERNAL
XAUTOMATIC
XSTATIC
XVALUE
XPROCEDURE
XBLOCKDATA
XOPTION
XINCLUDE
XDEFINE
XEND
XINTEGER
XREAL
XCOMPLEX
XLOGICAL
XCHARACTER
XSTRUCT
XFIELD
XARRAY
XDIMENSION
XLONG
XSHORT
XINITIAL
XEQUIVALENCE
XIMPLICIT
XDEBUG
XIF
XELSE
XWHILE
XUNTIL
XREPEAT
XDO
XFOR
XSWITCH
XCASE
XDEFAULT
XGO
XGOTO
XBREAK
XEXIT
XNEXT
XRETURN
XCONTINUE
XCALL
XDOUBLE
XPRECISION
XDOUBLEPRECISION
XSIZEOF
XLENGTHOF
XLETTER
XREAD
XWRITE
XREADBIN
XWRITEBIN
XTRUE
XFALSE
XESCAPE

exit
