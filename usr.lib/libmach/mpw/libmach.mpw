#! /bin/sh

[ -d include ] || mkdir include
[ -d include/mac2 ] || mkdir include/mac2
[ -d include/mach ] || mkdir include/mach
[ -d include/mach/ca ] || mkdir include/mach/ca
[ -d include/mach/mac2 ] || mkdir include/mach/mac2
[ -d include/mach/machine ] || mkdir include/mach/machine
[ -d include/mach/sun3 ] || mkdir include/mach/sun3
[ -d include/mach/vax ] || mkdir include/mach/vax
[ -d include/mach_debug ] || mkdir include/mach_debug
[ -d include/servers ] || mkdir include/servers
[ -d include/sys ] || mkdir include/sys
[ -d libmach ] || mkdir libmach

echo "README"
cat >README <<'@EOF@'
These are the MACH sources needed to make and use libmach.o under MPW.

MacMach version 01; bsd4.3-tahoe; Mach/2.6 #5.1(X129); CMU-MACMACH 013

To use, move everything in include to interfaces:CIncludes.
Use the libmach.o.make to compile a libmach.o library.
Move libmach.o to Libraries:Libraries.

Compile your application with: -d mac2 -d MacOS -d MacOS_DRVR
Link your application the "{Libraries}"libmach.o library.
@EOF@

echo "libmach/libmach.o.make"
cat >libmach/libmach.o.make <<'@EOF@'
# libmach.o.make

# note: define MacOS_drvr to make a libmach for Macintosh drivers

OBJECTS = ¶
		env_mgrUser.c.o ¶
		error_codes.c.o ¶
		excServer.c.o ¶
		excUser.c.o ¶
		ipcxUser.c.o ¶
		mach_debugUser.c.o ¶
		mach_error.c.o ¶
		mach_exception.c.o ¶
		mach_hostUser.c.o ¶
		mach_init.c.o ¶
		mach_traps.a.o ¶
		memory_objectServer.c.o ¶
		mig_strncpy.c.o ¶
		mig_support.c.o ¶
		monitorUser.c.o ¶
		msg.c.o ¶
		netmemoryUser.c.o ¶
		netmemstatUser.c.o ¶
		netnameUser.c.o ¶
		new_mach_user.c.o ¶
		serviceUser.c.o ¶
		slot_name.c.o ¶
		XXX_new_vawp.c.o ¶
		XXX_pdp.c.o ¶
		XXX_pds.c.o ¶
		XXX_pdu.c.o ¶
		XXX_plr.c.o ¶
		bcopy.c.o



libmach.o ÄÄ libmach.o.make {OBJECTS}
	Lib -p {OBJECTS} -o libmach.o
env_mgrUser.c.o Ä libmach.o.make env_mgrUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 env_mgrUser.c
error_codes.c.o Ä libmach.o.make error_codes.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 error_codes.c
excServer.c.o Ä libmach.o.make excServer.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 excServer.c
excUser.c.o Ä libmach.o.make excUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 excUser.c
ipcxUser.c.o Ä libmach.o.make ipcxUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 ipcxUser.c
mach_debugUser.c.o Ä libmach.o.make mach_debugUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 mach_debugUser.c
mach_error.c.o Ä libmach.o.make mach_error.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 mach_error.c
mach_exception.c.o Ä libmach.o.make mach_exception.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 mach_exception.c
mach_hostUser.c.o Ä libmach.o.make mach_hostUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 mach_hostUser.c
mach_init.c.o Ä libmach.o.make mach_init.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 mach_init.c
mach_traps.a.o Ä libmach.o.make mach_traps.a
	 Asm mach_traps.a
memory_objectServer.c.o Ä libmach.o.make memory_objectServer.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 memory_objectServer.c
mig_strncpy.c.o Ä libmach.o.make mig_strncpy.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 mig_strncpy.c
mig_support.c.o Ä libmach.o.make mig_support.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 mig_support.c
monitorUser.c.o Ä libmach.o.make monitorUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 monitorUser.c
msg.c.o Ä libmach.o.make msg.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 msg.c
netmemoryUser.c.o Ä libmach.o.make netmemoryUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 netmemoryUser.c
netmemstatUser.c.o Ä libmach.o.make netmemstatUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 netmemstatUser.c
netnameUser.c.o Ä libmach.o.make netnameUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 netnameUser.c
new_mach_user.c.o Ä libmach.o.make new_mach_user.c mach_user.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 new_mach_user.c
serviceUser.c.o Ä libmach.o.make serviceUser.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 serviceUser.c
slot_name.c.o Ä libmach.o.make slot_name.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 slot_name.c
XXX_new_vawp.c.o Ä libmach.o.make XXX_new_vawp.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 XXX_new_vawp.c
XXX_pdp.c.o Ä libmach.o.make XXX_pdp.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 XXX_pdp.c
XXX_pds.c.o Ä libmach.o.make XXX_pds.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 XXX_pds.c
XXX_pdu.c.o Ä libmach.o.make XXX_pdu.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 XXX_pdu.c
XXX_plr.c.o Ä libmach.o.make XXX_plr.c
	 C -d mac2 -d MacOS -d MacOS_DRVR -sym on -mc68020 XXX_plr.c
bcopy.c.o Ä libmach.o.make bcopy.c
	 C -sym on -mc68020 bcopy.c
@EOF@

echo "include/mach.h"
cat >include/mach.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach.h,v $
 * Revision 1.1  90/02/18  17:48:02  bww
 * 	Mach Release 2.5
 * 	[90/02/18  17:47:49  bww]
 * 
 * Revision 2.2  89/10/28  11:30:47  mrt
 * 	Changed location of mach_interface from mach/ to
 * 	top level include.
 * 	[89/10/27            mrt]
 * 
 * Revision 2.1  89/06/13  16:47:44  mrt
 * Created.
 * 
 */
/* 
 *  Includes all the types that a normal user
 *  of Mach programs should need
 */

#ifndef	_MACH_H_
#define	_MACH_H_

#include <:mach:mach_types.h>
#include <mach_interface.h>
#include <mach_init.h>

#endif	/* _MACH_H_ */
@EOF@

echo "include/mach_error.h"
cat >include/mach_error.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_error.h,v $
 * Revision 1.1  90/02/18  17:48:05  bww
 * 	Mach Release 2.5
 * 	[90/02/18  17:47:49  bww]
 * 
 * Revision 1.3  89/05/05  18:44:57  mrt
 * 	Cleanup for Mach 2.5
 * 
 * 11-May-88  Mary Thompson (mrt) at Carnegie Mellon
 *	Added definition for mach_error_type
 *
 * 29-Mar-88  Mary Thompson (mrt) at Carnegie Mellon
 *	Corrected args to mach_error and added c_plusplus conditionals
 *
 * 30-Oct-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 *
 */ 

#ifndef	_LIB_MACH_ERROR_H_
#define	_LIB_MACH_ERROR_H_	1

#include <:mach:error.h>

char		*mach_error_string(
/*
 *	Returns a string appropriate to the error argument given
 */
#if	c_plusplus
	mach_error_t error_value
#endif	/* c_plusplus */
				);

void		mach_error(
/*
 *	Prints an appropriate message on the standard error stream
 */
#if	c_plusplus
	char 		*str,
	mach_error_t	error_value
#endif	/* c_plusplus */
				);

char		*mach_error_type(
/*
 *	Returns a string with the error system, subsystem and code
*/
#if	c_plusplus
	mach_error_t	error_value
#endif  /* c_plusplus */
				);

#endif	/* _LIB_MACH_ERROR_H_ */
@EOF@

echo "include/mach_exception.h"
cat >include/mach_exception.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/* 
 * HISTORY
 * $Log:	mach_exception.h,v $
 * Revision 1.1  90/02/18  17:48:08  bww
 * 	Mach Release 2.5
 * 	[90/02/18  17:47:49  bww]
 * 
 * Revision 1.4  89/10/25  00:02:41  mrt
 * 	Changed the include exclusion variable to _USR_MACH_EXCEPTION so
 * 	that it would not conflict with include/mach/exception.h.
 * 	[89/10/09            mrt]
 * 
 * Revision 1.3  89/05/05  18:45:18  mrt
 * 	Cleanup for Mach 2.5
 * 
 * 25-Apr-88  Karl Hauth (hauth) at Carnegie-Mellon University
 *	Created.
 *
 */ 

#ifndef	_USR_MACH_EXCEPTION_H_
#define	_USR_MACH_EXCEPTION_H_	1

#include <:mach:kern_return.h>

char		*mach_exception_string(
/*
 *	Returns a string appropriate to the error argument given
 */
#if	c_plusplus
	int	exception
#endif	/* c_plusplus */
				);


void		mach_exception(
/*
 *	Prints an appropriate message on the standard error stream
 */
#if	c_plusplus
	char	*str,
	int	exception
#endif	/* c_plusplus */
				);


char		*mach_sun3_exception_string(
/*
 *	Returns a string appropriate to the error argument given
 */
#if	c_plusplus
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);


void		mach_sun3_exception(
/*
 *	Prints an appropriate message on the standard error stream
 */
#if	c_plusplus
	char	*str,
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);

char		*mach_mac2_exception_string(
/*
 *	Returns a string appropriate to the error argument given
 */
#if	c_plusplus
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);


void		mach_mac2_exception(
/*
 *	Prints an appropriate message on the standard error stream
 */
#if	c_plusplus
	char	*str,
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);

char		*mach_romp_exception_string(
/*
 *	Returns a string appropriate to the error argument given
 */
#if	c_plusplus
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);

void		mach_romp_exception(
/*
 *	Prints an appropriate message on the standard error stream
 */
#if	c_plusplus
	char	*str,
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);

char		*mach_vax_exception_string(
/*
 *	Returns a string appropriate to the error argument given
 */
#if	c_plusplus
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);

void		mach_vax_exception(
/*
 *	Prints an appropriate message on the standard error stream
 */
#if	c_plusplus
	char	*str,
	int	exception,
	int	code,
	int	subcode
#endif	/* c_plusplus */
				);

#endif	/* _USR_MACH_EXCEPTION_H_ */
@EOF@

echo "include/mach_init.h"
cat >include/mach_init.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY 
 * $Log:	mach_init.h,v $
 * Revision 1.1  90/02/18  17:48:11  bww
 * 	Mach Release 2.5
 * 	[90/02/18  17:47:49  bww]
 * 
 * Revision 1.3  89/06/13  16:45:00  mrt
 * 	Defined macros for thread_reply and made task_data be another
 * 	name for thread_reply, as task_data() is no longer exported from
 * 	the kernel.
 * 	[89/05/28            mrt]
 * 
 * 	Moved definitions of round_page and trunc_page to
 * 	here from mach/vm_param.h
 * 	[89/05/18            mrt]
 * 
 * Revision 1.2  89/05/05  18:45:39  mrt
 * 	Cleanup and change includes for Mach 2.5
 * 	[89/04/28            mrt]
 * 
 */
/*
 *	Items provided by the Mach environment initialization.
 */

#ifndef	_MACH_INIT_H_
#define	_MACH_INIT_H_	1

#include <:mach:mach_types.h>

/*
 *	Kernel-related ports; how a task/thread controls itself
 */

#ifndef mac2_mpw_drvr

extern	port_t	task_self_;
extern	port_t	task_notify_;
extern  port_t	thread_reply_;
#define task_data_	thread_reply_

#define	task_self()	task_self_
#define	task_data()	thread_reply_
#define	thread_reply()	thread_reply_
#define	task_notify()	task_notify_

#endif /* mac2_mpw_drvr */

#define	current_task()	task_self()

/*
 *	Other important ports in the Mach user environment
 */

#define	NameServerPort	name_server_port	/* compatibility */

#ifndef mac2_mpw_drvr
extern	port_t	name_server_port;
extern	port_t	environment_port;
extern	port_t	service_port;
#endif /* mac2_mpw_drvr */

/*
 *	Where these ports occur in the "mach_ports_register"
 *	collection... only servers or the runtime library need know.
 */

#if	MACH_INIT_SLOTS
#define	NAME_SERVER_SLOT	0
#define	ENVIRONMENT_SLOT	1
#define SERVICE_SLOT		2

#define	MACH_PORTS_SLOTS_USED	3

#ifndef mac2_mpw_drvr
extern	port_array_t	mach_init_ports;
extern	unsigned int	mach_init_ports_count;
#endif /* mac2_mpw_drvr */
#endif	/* MACH_INIT_SLOTS */

/*
 *	Globally interesting numbers
 */

#ifndef mac2_mpw_drvr
extern	vm_size_t	vm_page_size;

#define round_page(x)	((((vm_offset_t)(x) + (vm_page_size - 1)) / vm_page_size) * vm_page_size)
#define trunc_page(x)	((((vm_offset_t)(x)) / vm_page_size) * vm_page_size)
#endif /* mac2_mpw_drvr */

#endif	/* _MACH_INIT_H_ */
@EOF@

echo "include/mach_interface.h"
cat >include/mach_interface.h <<'@EOF@'
#ifndef	_mach
#define	_mach

/* Module mach */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_mach
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>
#include <:mach:mach_types.h>
#include <:mach:mach_extra.h>

/* Routine xxx_port_allocate */
mig_external kern_return_t xxx_port_allocate
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t *my_port;
{ return xxx_port_allocate(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t *my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_deallocate */
mig_external kern_return_t xxx_port_deallocate
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t my_port;
{ return xxx_port_deallocate(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_enable */
mig_external kern_return_t xxx_port_enable
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t my_port;
{ return xxx_port_enable(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_disable */
mig_external kern_return_t xxx_port_disable
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t my_port;
{ return xxx_port_disable(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_select */
mig_external kern_return_t xxx_port_select
#if	defined(LINTLIBRARY)
    (target_task, port_list, port_listCnt)
	task_t target_task;
	port_array_t *port_list;
	unsigned int *port_listCnt;
{ return xxx_port_select(target_task, port_list, port_listCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t *port_list,
	unsigned int *port_listCnt
);
#else
    ();
#endif
#endif

/* Routine xxx_port_set_backlog */
mig_external kern_return_t xxx_port_set_backlog
#if	defined(LINTLIBRARY)
    (target_task, my_port, backlog)
	task_t target_task;
	port_t my_port;
	int backlog;
{ return xxx_port_set_backlog(target_task, my_port, backlog); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port,
	int backlog
);
#else
    ();
#endif
#endif

/* Routine xxx_port_status */
mig_external kern_return_t xxx_port_status
#if	defined(LINTLIBRARY)
    (target_task, my_port, enabled, num_msgs, backlog, ownership, receive_rights)
	task_t target_task;
	port_t my_port;
	boolean_t *enabled;
	int *num_msgs;
	int *backlog;
	boolean_t *ownership;
	boolean_t *receive_rights;
{ return xxx_port_status(target_task, my_port, enabled, num_msgs, backlog, ownership, receive_rights); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port,
	boolean_t *enabled,
	int *num_msgs,
	int *backlog,
	boolean_t *ownership,
	boolean_t *receive_rights
);
#else
    ();
#endif
#endif

/* Routine task_create */
mig_external kern_return_t task_create
#if	defined(LINTLIBRARY)
    (target_task, inherit_memory, child_task)
	task_t target_task;
	boolean_t inherit_memory;
	task_t *child_task;
{ return task_create(target_task, inherit_memory, child_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	boolean_t inherit_memory,
	task_t *child_task
);
#else
    ();
#endif
#endif

/* Routine task_terminate */
mig_external kern_return_t task_terminate
#if	defined(LINTLIBRARY)
    (target_task)
	task_t target_task;
{ return task_terminate(target_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
);
#else
    ();
#endif
#endif

/* Routine task_threads */
mig_external kern_return_t task_threads
#if	defined(LINTLIBRARY)
    (target_task, thread_list, thread_listCnt)
	task_t target_task;
	thread_array_t *thread_list;
	unsigned int *thread_listCnt;
{ return task_threads(target_task, thread_list, thread_listCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	thread_array_t *thread_list,
	unsigned int *thread_listCnt
);
#else
    ();
#endif
#endif

/* Routine thread_terminate */
mig_external kern_return_t thread_terminate
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_terminate(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine vm_allocate */
mig_external kern_return_t vm_allocate
#if	defined(LINTLIBRARY)
    (target_task, address, size, anywhere)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t size;
	boolean_t anywhere;
{ return vm_allocate(target_task, address, size, anywhere); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t size,
	boolean_t anywhere
);
#else
    ();
#endif
#endif

/* Routine vm_deallocate */
mig_external kern_return_t vm_deallocate
#if	defined(LINTLIBRARY)
    (target_task, address, size)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
{ return vm_deallocate(target_task, address, size); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size
);
#else
    ();
#endif
#endif

/* Routine vm_protect */
mig_external kern_return_t vm_protect
#if	defined(LINTLIBRARY)
    (target_task, address, size, set_maximum, new_protection)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	boolean_t set_maximum;
	vm_prot_t new_protection;
{ return vm_protect(target_task, address, size, set_maximum, new_protection); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	boolean_t set_maximum,
	vm_prot_t new_protection
);
#else
    ();
#endif
#endif

/* Routine vm_inherit */
mig_external kern_return_t vm_inherit
#if	defined(LINTLIBRARY)
    (target_task, address, size, new_inheritance)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	vm_inherit_t new_inheritance;
{ return vm_inherit(target_task, address, size, new_inheritance); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	vm_inherit_t new_inheritance
);
#else
    ();
#endif
#endif

/* Routine vm_read */
mig_external kern_return_t vm_read
#if	defined(LINTLIBRARY)
    (target_task, address, size, data, dataCnt)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	pointer_t *data;
	unsigned int *dataCnt;
{ return vm_read(target_task, address, size, data, dataCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	pointer_t *data,
	unsigned int *dataCnt
);
#else
    ();
#endif
#endif

/* Routine vm_write */
mig_external kern_return_t vm_write
#if	defined(LINTLIBRARY)
    (target_task, address, data, dataCnt)
	vm_task_t target_task;
	vm_address_t address;
	pointer_t data;
	unsigned int dataCnt;
{ return vm_write(target_task, address, data, dataCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	pointer_t data,
	unsigned int dataCnt
);
#else
    ();
#endif
#endif

/* Routine vm_copy */
mig_external kern_return_t vm_copy
#if	defined(LINTLIBRARY)
    (target_task, source_address, size, dest_address)
	vm_task_t target_task;
	vm_address_t source_address;
	vm_size_t size;
	vm_address_t dest_address;
{ return vm_copy(target_task, source_address, size, dest_address); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t source_address,
	vm_size_t size,
	vm_address_t dest_address
);
#else
    ();
#endif
#endif

/* Routine vm_region */
mig_external kern_return_t vm_region
#if	defined(LINTLIBRARY)
    (target_task, address, size, protection, max_protection, inheritance, is_shared, object_name, offset)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t *size;
	vm_prot_t *protection;
	vm_prot_t *max_protection;
	vm_inherit_t *inheritance;
	boolean_t *is_shared;
	memory_object_name_t *object_name;
	vm_offset_t *offset;
{ return vm_region(target_task, address, size, protection, max_protection, inheritance, is_shared, object_name, offset); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t *size,
	vm_prot_t *protection,
	vm_prot_t *max_protection,
	vm_inherit_t *inheritance,
	boolean_t *is_shared,
	memory_object_name_t *object_name,
	vm_offset_t *offset
);
#else
    ();
#endif
#endif

/* Routine vm_statistics */
mig_external kern_return_t vm_statistics
#if	defined(LINTLIBRARY)
    (target_task, vm_stats)
	vm_task_t target_task;
	vm_statistics_data_t *vm_stats;
{ return vm_statistics(target_task, vm_stats); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_statistics_data_t *vm_stats
);
#else
    ();
#endif
#endif

/* Routine task_by_unix_pid */
mig_external kern_return_t task_by_unix_pid
#if	defined(LINTLIBRARY)
    (target_task, process_id, result_task)
	task_t target_task;
	int process_id;
	task_t *result_task;
{ return task_by_unix_pid(target_task, process_id, result_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int process_id,
	task_t *result_task
);
#else
    ();
#endif
#endif

/* Routine mach_ports_register */
mig_external kern_return_t mach_ports_register
#if	defined(LINTLIBRARY)
    (target_task, init_port_set, init_port_setCnt)
	task_t target_task;
	port_array_t init_port_set;
	unsigned int init_port_setCnt;
{ return mach_ports_register(target_task, init_port_set, init_port_setCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t init_port_set,
	unsigned int init_port_setCnt
);
#else
    ();
#endif
#endif

/* Routine mach_ports_lookup */
mig_external kern_return_t mach_ports_lookup
#if	defined(LINTLIBRARY)
    (target_task, init_port_set, init_port_setCnt)
	task_t target_task;
	port_array_t *init_port_set;
	unsigned int *init_port_setCnt;
{ return mach_ports_lookup(target_task, init_port_set, init_port_setCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t *init_port_set,
	unsigned int *init_port_setCnt
);
#else
    ();
#endif
#endif

/* Routine unix_pid */
mig_external kern_return_t unix_pid
#if	defined(LINTLIBRARY)
    (target_task, process_id)
	task_t target_task;
	int *process_id;
{ return unix_pid(target_task, process_id); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int *process_id
);
#else
    ();
#endif
#endif

/* Routine netipc_listen */
mig_external kern_return_t netipc_listen
#if	defined(LINTLIBRARY)
    (request_port, src_addr, dst_addr, src_port, dst_port, protocol, ipc_port)
	port_t request_port;
	int src_addr;
	int dst_addr;
	int src_port;
	int dst_port;
	int protocol;
	port_t ipc_port;
{ return netipc_listen(request_port, src_addr, dst_addr, src_port, dst_port, protocol, ipc_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	int src_addr,
	int dst_addr,
	int src_port,
	int dst_port,
	int protocol,
	port_t ipc_port
);
#else
    ();
#endif
#endif

/* Routine netipc_ignore */
mig_external kern_return_t netipc_ignore
#if	defined(LINTLIBRARY)
    (request_port, ipc_port)
	port_t request_port;
	port_t ipc_port;
{ return netipc_ignore(request_port, ipc_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	port_t ipc_port
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_provided */
mig_external kern_return_t memory_object_data_provided
#if	defined(LINTLIBRARY)
    (memory_control, offset, data, dataCnt, lock_value)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	pointer_t data;
	unsigned int dataCnt;
	vm_prot_t lock_value;
{ return memory_object_data_provided(memory_control, offset, data, dataCnt, lock_value); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	pointer_t data,
	unsigned int dataCnt,
	vm_prot_t lock_value
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_unavailable */
mig_external kern_return_t memory_object_data_unavailable
#if	defined(LINTLIBRARY)
    (memory_control, offset, size)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
{ return memory_object_data_unavailable(memory_control, offset, size); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size
);
#else
    ();
#endif
#endif

/* Routine memory_object_get_attributes */
mig_external kern_return_t memory_object_get_attributes
#if	defined(LINTLIBRARY)
    (memory_control, object_ready, may_cache, copy_strategy)
	memory_object_control_t memory_control;
	boolean_t *object_ready;
	boolean_t *may_cache;
	memory_object_copy_strategy_t *copy_strategy;
{ return memory_object_get_attributes(memory_control, object_ready, may_cache, copy_strategy); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t *object_ready,
	boolean_t *may_cache,
	memory_object_copy_strategy_t *copy_strategy
);
#else
    ();
#endif
#endif

/* Routine vm_set_default_memory_manager */
mig_external kern_return_t vm_set_default_memory_manager
#if	defined(LINTLIBRARY)
    (host, default_manager)
	host_priv_t host;
	memory_object_t *default_manager;
{ return vm_set_default_memory_manager(host, default_manager); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host,
	memory_object_t *default_manager
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_lock_request */
mig_external kern_return_t memory_object_lock_request
#if	defined(LINTLIBRARY)
    (memory_control, offset, size, should_clean, should_flush, lock_value, reply_to)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
	boolean_t should_clean;
	boolean_t should_flush;
	vm_prot_t lock_value;
	port_t reply_to;
{ return memory_object_lock_request(memory_control, offset, size, should_clean, should_flush, lock_value, reply_to); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size,
	boolean_t should_clean,
	boolean_t should_flush,
	vm_prot_t lock_value,
	port_t reply_to
);
#else
    ();
#endif
#endif

/* SimpleRoutine xxx_pager_cache */
mig_external kern_return_t xxx_pager_cache
#if	defined(LINTLIBRARY)
    (memory_control, should_cache)
	memory_object_control_t memory_control;
	boolean_t should_cache;
{ return xxx_pager_cache(memory_control, should_cache); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t should_cache
);
#else
    ();
#endif
#endif

/* Routine xxx_host_info */
mig_external kern_return_t xxx_host_info
#if	defined(LINTLIBRARY)
    (target_task, info)
	port_t target_task;
	machine_info_data_t *info;
{ return xxx_host_info(target_task, info); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t target_task,
	machine_info_data_t *info
);
#else
    ();
#endif
#endif

/* Routine xxx_slot_info */
mig_external kern_return_t xxx_slot_info
#if	defined(LINTLIBRARY)
    (target_task, slot, info)
	task_t target_task;
	int slot;
	machine_slot_data_t *info;
{ return xxx_slot_info(target_task, slot, info); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int slot,
	machine_slot_data_t *info
);
#else
    ();
#endif
#endif

/* Routine xxx_cpu_control */
mig_external kern_return_t xxx_cpu_control
#if	defined(LINTLIBRARY)
    (target_task, cpu, running)
	task_t target_task;
	int cpu;
	boolean_t running;
{ return xxx_cpu_control(target_task, cpu, running); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int cpu,
	boolean_t running
);
#else
    ();
#endif
#endif

/* Routine netport_init */
mig_external kern_return_t netport_init
#if	defined(LINTLIBRARY)
    (request_port)
	port_t request_port;
{ return netport_init(request_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port
);
#else
    ();
#endif
#endif

/* Routine netport_enter */
mig_external kern_return_t netport_enter
#if	defined(LINTLIBRARY)
    (request_port, netport, port, local)
	port_t request_port;
	network_port_t netport;
	port_t port;
	boolean_t local;
{ return netport_enter(request_port, netport, port, local); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	network_port_t netport,
	port_t port,
	boolean_t local
);
#else
    ();
#endif
#endif

/* Routine netport_remove */
mig_external kern_return_t netport_remove
#if	defined(LINTLIBRARY)
    (request_port, netport)
	port_t request_port;
	network_port_t netport;
{ return netport_remove(request_port, netport); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	network_port_t netport
);
#else
    ();
#endif
#endif

/* Routine task_suspend */
mig_external kern_return_t task_suspend
#if	defined(LINTLIBRARY)
    (target_task)
	task_t target_task;
{ return task_suspend(target_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
);
#else
    ();
#endif
#endif

/* Routine task_resume */
mig_external kern_return_t task_resume
#if	defined(LINTLIBRARY)
    (target_task)
	task_t target_task;
{ return task_resume(target_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
);
#else
    ();
#endif
#endif

/* Routine task_get_special_port */
mig_external kern_return_t task_get_special_port
#if	defined(LINTLIBRARY)
    (task, which_port, special_port)
	task_t task;
	int which_port;
	port_t *special_port;
{ return task_get_special_port(task, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int which_port,
	port_t *special_port
);
#else
    ();
#endif
#endif

/* Routine task_set_special_port */
mig_external kern_return_t task_set_special_port
#if	defined(LINTLIBRARY)
    (task, which_port, special_port)
	task_t task;
	int which_port;
	port_t special_port;
{ return task_set_special_port(task, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int which_port,
	port_t special_port
);
#else
    ();
#endif
#endif

/* Routine task_info */
mig_external kern_return_t task_info
#if	defined(LINTLIBRARY)
    (target_task, flavor, task_info_out, task_info_outCnt)
	task_t target_task;
	int flavor;
	task_info_t task_info_out;
	unsigned int *task_info_outCnt;
{ return task_info(target_task, flavor, task_info_out, task_info_outCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int flavor,
	task_info_t task_info_out,
	unsigned int *task_info_outCnt
);
#else
    ();
#endif
#endif

/* Routine thread_create */
mig_external kern_return_t thread_create
#if	defined(LINTLIBRARY)
    (parent_task, child_thread)
	task_t parent_task;
	thread_t *child_thread;
{ return thread_create(parent_task, child_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t parent_task,
	thread_t *child_thread
);
#else
    ();
#endif
#endif

/* Routine thread_suspend */
mig_external kern_return_t thread_suspend
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_suspend(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine thread_resume */
mig_external kern_return_t thread_resume
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_resume(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine thread_abort */
mig_external kern_return_t thread_abort
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_abort(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine thread_get_state */
mig_external kern_return_t thread_get_state
#if	defined(LINTLIBRARY)
    (target_thread, flavor, old_state, old_stateCnt)
	thread_t target_thread;
	int flavor;
	thread_state_t old_state;
	unsigned int *old_stateCnt;
{ return thread_get_state(target_thread, flavor, old_state, old_stateCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_state_t old_state,
	unsigned int *old_stateCnt
);
#else
    ();
#endif
#endif

/* Routine thread_set_state */
mig_external kern_return_t thread_set_state
#if	defined(LINTLIBRARY)
    (target_thread, flavor, new_state, new_stateCnt)
	thread_t target_thread;
	int flavor;
	thread_state_t new_state;
	unsigned int new_stateCnt;
{ return thread_set_state(target_thread, flavor, new_state, new_stateCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_state_t new_state,
	unsigned int new_stateCnt
);
#else
    ();
#endif
#endif

/* Routine thread_get_special_port */
mig_external kern_return_t thread_get_special_port
#if	defined(LINTLIBRARY)
    (thread, which_port, special_port)
	thread_t thread;
	int which_port;
	port_t *special_port;
{ return thread_get_special_port(thread, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int which_port,
	port_t *special_port
);
#else
    ();
#endif
#endif

/* Routine thread_set_special_port */
mig_external kern_return_t thread_set_special_port
#if	defined(LINTLIBRARY)
    (thread, which_port, special_port)
	thread_t thread;
	int which_port;
	port_t special_port;
{ return thread_set_special_port(thread, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int which_port,
	port_t special_port
);
#else
    ();
#endif
#endif

/* Routine thread_info */
mig_external kern_return_t thread_info
#if	defined(LINTLIBRARY)
    (target_thread, flavor, thread_info_out, thread_info_outCnt)
	thread_t target_thread;
	int flavor;
	thread_info_t thread_info_out;
	unsigned int *thread_info_outCnt;
{ return thread_info(target_thread, flavor, thread_info_out, thread_info_outCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_info_t thread_info_out,
	unsigned int *thread_info_outCnt
);
#else
    ();
#endif
#endif

/* Routine task_set_emulation */
mig_external kern_return_t task_set_emulation
#if	defined(LINTLIBRARY)
    (target_port, routine_entry_pt, routine_number)
	task_t target_port;
	vm_address_t routine_entry_pt;
	int routine_number;
{ return task_set_emulation(target_port, routine_entry_pt, routine_number); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_port,
	vm_address_t routine_entry_pt,
	int routine_number
);
#else
    ();
#endif
#endif

/* Routine port_names */
mig_external kern_return_t port_names
#if	defined(LINTLIBRARY)
    (task, port_names_p, port_names_pCnt, port_types, port_typesCnt)
	task_t task;
	port_name_array_t *port_names_p;
	unsigned int *port_names_pCnt;
	port_type_array_t *port_types;
	unsigned int *port_typesCnt;
{ return port_names(task, port_names_p, port_names_pCnt, port_types, port_typesCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_array_t *port_names_p,
	unsigned int *port_names_pCnt,
	port_type_array_t *port_types,
	unsigned int *port_typesCnt
);
#else
    ();
#endif
#endif

/* Routine port_type */
mig_external kern_return_t port_type
#if	defined(LINTLIBRARY)
    (task, port_name, port_type_p)
	task_t task;
	port_name_t port_name;
	port_type_t *port_type_p;
{ return port_type(task, port_name, port_type_p); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_type_t *port_type_p
);
#else
    ();
#endif
#endif

/* Routine port_rename */
mig_external kern_return_t port_rename
#if	defined(LINTLIBRARY)
    (task, old_name, new_name)
	task_t task;
	port_name_t old_name;
	port_name_t new_name;
{ return port_rename(task, old_name, new_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t old_name,
	port_name_t new_name
);
#else
    ();
#endif
#endif

/* Routine port_allocate */
mig_external kern_return_t port_allocate
#if	defined(LINTLIBRARY)
    (task, port_name)
	task_t task;
	port_name_t *port_name;
{ return port_allocate(task, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t *port_name
);
#else
    ();
#endif
#endif

/* Routine port_deallocate */
mig_external kern_return_t port_deallocate
#if	defined(LINTLIBRARY)
    (task, port_name)
	task_t task;
	port_name_t port_name;
{ return port_deallocate(task, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name
);
#else
    ();
#endif
#endif

/* Routine port_set_backlog */
mig_external kern_return_t port_set_backlog
#if	defined(LINTLIBRARY)
    (task, port_name, backlog)
	task_t task;
	port_name_t port_name;
	int backlog;
{ return port_set_backlog(task, port_name, backlog); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	int backlog
);
#else
    ();
#endif
#endif

/* Routine port_status */
mig_external kern_return_t port_status
#if	defined(LINTLIBRARY)
    (task, port_name, enabled, num_msgs, backlog, ownership, receive_rights)
	task_t task;
	port_name_t port_name;
	port_set_name_t *enabled;
	int *num_msgs;
	int *backlog;
	boolean_t *ownership;
	boolean_t *receive_rights;
{ return port_status(task, port_name, enabled, num_msgs, backlog, ownership, receive_rights); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_set_name_t *enabled,
	int *num_msgs,
	int *backlog,
	boolean_t *ownership,
	boolean_t *receive_rights
);
#else
    ();
#endif
#endif

/* Routine port_set_allocate */
mig_external kern_return_t port_set_allocate
#if	defined(LINTLIBRARY)
    (task, set_name)
	task_t task;
	port_set_name_t *set_name;
{ return port_set_allocate(task, set_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t *set_name
);
#else
    ();
#endif
#endif

/* Routine port_set_deallocate */
mig_external kern_return_t port_set_deallocate
#if	defined(LINTLIBRARY)
    (task, set_name)
	task_t task;
	port_set_name_t set_name;
{ return port_set_deallocate(task, set_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name
);
#else
    ();
#endif
#endif

/* Routine port_set_add */
mig_external kern_return_t port_set_add
#if	defined(LINTLIBRARY)
    (task, set_name, port_name)
	task_t task;
	port_set_name_t set_name;
	port_name_t port_name;
{ return port_set_add(task, set_name, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name,
	port_name_t port_name
);
#else
    ();
#endif
#endif

/* Routine port_set_remove */
mig_external kern_return_t port_set_remove
#if	defined(LINTLIBRARY)
    (task, port_name)
	task_t task;
	port_name_t port_name;
{ return port_set_remove(task, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name
);
#else
    ();
#endif
#endif

/* Routine port_set_status */
mig_external kern_return_t port_set_status
#if	defined(LINTLIBRARY)
    (task, set_name, members, membersCnt)
	task_t task;
	port_set_name_t set_name;
	port_name_array_t *members;
	unsigned int *membersCnt;
{ return port_set_status(task, set_name, members, membersCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name,
	port_name_array_t *members,
	unsigned int *membersCnt
);
#else
    ();
#endif
#endif

/* Routine port_insert_send */
mig_external kern_return_t port_insert_send
#if	defined(LINTLIBRARY)
    (task, my_port, his_name)
	task_t task;
	port_t my_port;
	port_name_t his_name;
{ return port_insert_send(task, my_port, his_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_t my_port,
	port_name_t his_name
);
#else
    ();
#endif
#endif

/* Routine port_extract_send */
mig_external kern_return_t port_extract_send
#if	defined(LINTLIBRARY)
    (task, his_name, his_port)
	task_t task;
	port_name_t his_name;
	port_t *his_port;
{ return port_extract_send(task, his_name, his_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t his_name,
	port_t *his_port
);
#else
    ();
#endif
#endif

/* Routine port_insert_receive */
mig_external kern_return_t port_insert_receive
#if	defined(LINTLIBRARY)
    (task, my_port, his_name)
	task_t task;
	port_t my_port;
	port_name_t his_name;
{ return port_insert_receive(task, my_port, his_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_t my_port,
	port_name_t his_name
);
#else
    ();
#endif
#endif

/* Routine port_extract_receive */
mig_external kern_return_t port_extract_receive
#if	defined(LINTLIBRARY)
    (task, his_name, his_port)
	task_t task;
	port_name_t his_name;
	port_t *his_port;
{ return port_extract_receive(task, his_name, his_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t his_name,
	port_t *his_port
);
#else
    ();
#endif
#endif

/* Routine vm_map */
mig_external kern_return_t vm_map
#if	defined(LINTLIBRARY)
    (target_task, address, size, mask, anywhere, memory_object, offset, copy, cur_protection, max_protection, inheritance)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t size;
	vm_address_t mask;
	boolean_t anywhere;
	memory_object_t memory_object;
	vm_offset_t offset;
	boolean_t copy;
	vm_prot_t cur_protection;
	vm_prot_t max_protection;
	vm_inherit_t inheritance;
{ return vm_map(target_task, address, size, mask, anywhere, memory_object, offset, copy, cur_protection, max_protection, inheritance); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t size,
	vm_address_t mask,
	boolean_t anywhere,
	memory_object_t memory_object,
	vm_offset_t offset,
	boolean_t copy,
	vm_prot_t cur_protection,
	vm_prot_t max_protection,
	vm_inherit_t inheritance
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_error */
mig_external kern_return_t memory_object_data_error
#if	defined(LINTLIBRARY)
    (memory_control, offset, size, error_value)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
	kern_return_t error_value;
{ return memory_object_data_error(memory_control, offset, size, error_value); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size,
	kern_return_t error_value
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_set_attributes */
mig_external kern_return_t memory_object_set_attributes
#if	defined(LINTLIBRARY)
    (memory_control, object_ready, may_cache, copy_strategy)
	memory_object_control_t memory_control;
	boolean_t object_ready;
	boolean_t may_cache;
	memory_object_copy_strategy_t copy_strategy;
{ return memory_object_set_attributes(memory_control, object_ready, may_cache, copy_strategy); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t object_ready,
	boolean_t may_cache,
	memory_object_copy_strategy_t copy_strategy
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_destroy */
mig_external kern_return_t memory_object_destroy
#if	defined(LINTLIBRARY)
    (memory_control, reason)
	memory_object_control_t memory_control;
	kern_return_t reason;
{ return memory_object_destroy(memory_control, reason); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	kern_return_t reason
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_supply */
mig_external kern_return_t memory_object_data_supply
#if	defined(LINTLIBRARY)
    (memory_control, offset, data, dataCnt, dealloc_data, lock_value, precious, reply_to)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	pointer_t data;
	unsigned int dataCnt;
	boolean_t dealloc_data;
	vm_prot_t lock_value;
	boolean_t precious;
	port_t reply_to;
{ return memory_object_data_supply(memory_control, offset, data, dataCnt, dealloc_data, lock_value, precious, reply_to); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	pointer_t data,
	unsigned int dataCnt,
	boolean_t dealloc_data,
	vm_prot_t lock_value,
	boolean_t precious,
	port_t reply_to
);
#else
    ();
#endif
#endif

/* Routine port_set_backup */
mig_external kern_return_t port_set_backup
#if	defined(LINTLIBRARY)
    (task, port_name, backup, previous)
	task_t task;
	port_name_t port_name;
	port_t backup;
	port_t *previous;
{ return port_set_backup(task, port_name, backup, previous); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_t backup,
	port_t *previous
);
#else
    ();
#endif
#endif

/* Routine vm_machine_attribute */
mig_external kern_return_t vm_machine_attribute
#if	defined(LINTLIBRARY)
    (target_task, address, size, attribute, value)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	vm_machine_attribute_t attribute;
	vm_machine_attribute_val_t *value;
{ return vm_machine_attribute(target_task, address, size, attribute, value); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	vm_machine_attribute_t attribute,
	vm_machine_attribute_val_t *value
);
#else
    ();
#endif
#endif

#endif	_mach
@EOF@

echo "include/sys/syscall.h"
cat >include/sys/syscall.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	syscall.h,v $
 * Revision 2.13  90/08/30  11:50:46  bohman
 * 	Changes for mac2.
 * 	[90/08/28            bohman]
 * 
 * Revision 2.12  90/02/19  15:14:23  jjc
 * 	Defined SYS_wait4 for Sun 4.
 * 	[89/09/02            jjc]
 * 
 * Revision 2.11  89/08/02  09:09:59  jsb
 * 	Added entries for Multimax syscalls.
 * 	[89/08/01            mbj]
 * 
 * Revision 2.10  89/05/30  10:44:09  rvb
 * 	Additions for Ultrix/MIPS
 * 	[89/05/30  08:37:37  rvb]
 * 
 * Revision 2.9  89/05/11  14:58:43  gm0w
 * 	Fixed up ifdef/endif's for vax and i386 numbers.
 * 	[89/05/05            gm0w]
 * 
 * Revision 2.8  89/03/15  15:59:08  gm0w
 * 	Separated vax and i386 syscall numbers.
 * 
 * Revision 2.7  89/03/09  22:07:57  rpd
 * 	More cleanup.
 * 
 * Revision 2.6  89/02/25  17:56:33  gm0w
 * 	Made CMUCS and MACH_VMTP defines done unconditionally.
 * 	Changed BALANCE to balance.
 * 	[89/02/14            mrt]
 * 
 * Revision 2.5  89/01/23  22:28:45  af
 * 	Add mips specific system calls
 * 	[89/01/10            af]
 * 	
 * 	Changes for I386 -- treat it like vax
 * 	[89/01/09            rvb]
 * 
 * Revision 2.4  89/01/18  01:19:30  jsb
 * 	Added NFS and AFS system calls.
 * 	[89/01/13            jsb]
 * 
 * Revision 2.3  88/07/15  16:02:22  mja
 * Moved UMODE_* bit definitions to <sys/table.h>.
 * 
 * 10-Oct-87  Mike Accetta (mja) at Carnegie-Mellon University
 *	Added getmodes()/setmodes() bit definitions and updated for
 *	more local system calls.
 *	[ V5.1(XF18) ]
 *
 * 22-Sep-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	At CMU CS, added local system calls.
 *
 * 22-Sep-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added changes for IBM RT.
 *
 */
/*
 * Copyright (c) 1980 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)syscall.h	5.4 (Berkeley) 4/3/86
 */

#ifndef	_SYS_SYSCALL_H_
#define _SYS_SYSCALL_H_

/* CMU system calls */
#define SYS_getmodes	(-9)
#define SYS_setmodes	(-8)
#define SYS_IPCAtrium	(-7)
#define SYS_table	(-6)
#define SYS_rpause	(-5)
#define SYS_xutimes	(-4)
				/* -3 is unused */
#define SYS_getaid	(-2)
#define SYS_setaid	(-1)

#define SYS_syscall	0
/* end CMU system calls */

#define SYS_exit	1
#define SYS_fork	2
#define SYS_read	3
#define SYS_write	4
#define SYS_open	5
#define SYS_close	6
#ifdef	sun4
#define	SYS_wait4	7
#endif	sun4
				/*  7 is old: wait */
#define SYS_creat	8
#define SYS_link	9
#define SYS_unlink	10
#define SYS_execv	11
#define SYS_chdir	12
				/* 13 is old: time */
#define SYS_mknod	14
#define SYS_chmod	15
#define SYS_chown	16
				/* 17 is old: sbreak */
				/* 18 is old: stat */
#define SYS_lseek	19
#define SYS_getpid	20
#define SYS_mount	21
#define SYS_umount	22
				/* 23 is old: setuid */
#define SYS_getuid	24
				/* 25 is old: stime */
#define SYS_ptrace	26
				/* 27 is old: alarm */
				/* 28 is old: fstat */
				/* 29 is old: pause */
				/* 30 is old: utime */
				/* 31 is old: stty */
				/* 32 is old: gtty */
#define SYS_access	33
				/* 34 is old: nice */
				/* 35 is old: ftime */
#define SYS_sync	36
#define SYS_kill	37
#define SYS_stat	38
				/* 39 is old: setpgrp */
#define SYS_lstat	40
#define SYS_dup		41
#define SYS_pipe	42
				/* 43 is old: times */
#define SYS_profil	44
				/* 45 is unused */
				/* 46 is old: setgid */
#define SYS_getgid	47
				/* 48 is old: sigsys */
				/* 49 is unused */
				/* 50 is unused */
#define SYS_acct	51
				/* 52 is old: phys */
				/* 53 is old: syslock */
#define SYS_ioctl	54
#define SYS_reboot	55
				/* 56 is old: mpxchan */
#define SYS_symlink	57
#define SYS_readlink	58
#define SYS_execve	59
#define SYS_umask	60
#define SYS_chroot	61
#define SYS_fstat	62
				/* 63 is unused */
#define SYS_getpagesize 64
#define SYS_mremap	65
#ifdef	ibmrt
#define SYS_vfork	66
#endif
#ifdef	vax
				/* 66 is old: vfork */
#endif
				/* 67 is old: vread */
				/* 68 is old: vwrite */
#define SYS_sbrk	69
#define SYS_sstk	70
#define SYS_mmap	71
#ifdef	ibmrt
#define SYS_vadvise	72
#endif
#ifdef	vax
				/* 72 is old: vadvise */
#endif	vax
#define SYS_munmap	73
#define SYS_mprotect	74
#define SYS_madvise	75
#define SYS_vhangup	76
				/* 77 is old: vlimit */
#define SYS_mincore	78
#define SYS_getgroups	79
#define SYS_setgroups	80
#define SYS_getpgrp	81
#define SYS_setpgrp	82
#define SYS_setitimer	83
#define SYS_wait	84
#define SYS_swapon	85
#define SYS_getitimer	86
#define SYS_gethostname	87
#define SYS_sethostname	88
#define SYS_getdtablesize 89
#define SYS_dup2	90
#define SYS_getdopt	91
#define SYS_fcntl	92
#define SYS_select	93
#define SYS_setdopt	94
#define SYS_fsync	95
#define SYS_setpriority	96
#define SYS_socket	97
#define SYS_connect	98
#define SYS_accept	99
#define SYS_getpriority	100
#define SYS_send	101
#define SYS_recv	102
#define SYS_sigreturn	103
#define SYS_bind	104
#define SYS_setsockopt	105
#define SYS_listen	106
				/* 107 was vtimes */
#define SYS_sigvec	108
#define SYS_sigblock	109
#define SYS_sigsetmask	110
#define SYS_sigpause	111
#define SYS_sigstack	112
#define SYS_recvmsg	113
#define SYS_sendmsg	114
				/* 115 is old vtrace */
#define SYS_gettimeofday 116
#define SYS_getrusage	117
#define SYS_getsockopt	118
				/* 119 is old resuba */
#define SYS_readv	120
#define SYS_writev	121
#define SYS_settimeofday 122
#define SYS_fchown	123
#define SYS_fchmod	124
#define SYS_recvfrom	125
#define SYS_setreuid	126
#define SYS_setregid	127
#define SYS_rename	128
#define SYS_truncate	129
#define SYS_ftruncate	130
#define SYS_flock	131
				/* 132 is unused */
#define SYS_sendto	133
#define SYS_shutdown	134
#define SYS_socketpair	135
#define SYS_mkdir	136
#define SYS_rmdir	137
#define SYS_utimes	138
				/* 139 is unused */
#define SYS_adjtime	140
#define SYS_getpeername	141
#define SYS_gethostid	142
#define SYS_sethostid	143
#define SYS_getrlimit	144
#define SYS_setrlimit	145
#define SYS_killpg	146
				/* 147 is unused */
#define SYS_setquota	148
#define SYS_quota	149
#define SYS_getsockname	150

#ifdef	ibmrt
#define SYS_exect		151
#define SYS_getfpemulator	153
#define SYS_iopen		154
#define SYS_iread		155
#define SYS_iwrite		156
#define SYS_iinc		157
#define SYS_idec		158
#define SYS_pioctl		159
#define SYS_setpag		160
#define SYS_icreate		161
#define SYS_getfloatstate	167
#define SYS_setfloatstate	168
#define SYS_nfs_svc		169
#define SYS_getdirentries	170
#define SYS_statfs		171
#define SYS_fstatfs		172
#define SYS_unmount		173
#define SYS_async_daemon	174
#define SYS_nfs_getfh		175
#define SYS_getdomainname	176
#define SYS_setdomainname	177
#define SYS_quotactl		178
#define SYS_exportfs		179
#define SYS_vfsmount		180
#define SYS_afs_call		181
#endif	ibmrt

#if	defined(mac2)
#define SYS_nfs_svc		155
#define SYS_getdirentries	156
#define SYS_statfs		157
#define SYS_fstatfs		158
#define SYS_unmount		159
#define SYS_async_daemon	160
#define SYS_nfs_getfh		161
#define SYS_getdomainname	162
#define SYS_setdomainname	163
#define SYS_quotactl		165
#define SYS_exportfs		166
#define SYS_vfsmount		167
#define SYS_pioctl		168
#define SYS_setpag		169
#define SYS_icreate		170
#define SYS_iopen		171
#define SYS_iread		172
#define SYS_iwrite		173
#define SYS_iinc		174
#define SYS_idec		175
#define SYS_afs_call		180
#endif	defined(mac2)

#ifdef	sun
#define SYS_nfs_svc		155
#define SYS_getdirentries	156
#define SYS_statfs		157
#define SYS_fstatfs		158
#define SYS_unmount		159
#define SYS_async_daemon	160
#define SYS_nfs_getfh		161
#define SYS_getdomainname	162
#define SYS_setdomainname	163
#define SYS_quotactl		165
#define SYS_exportfs		166
#define SYS_vfsmount		167
#define SYS_pioctl		168
#define SYS_setpag		169
#define SYS_icreate		170
#define SYS_iopen		171
#define SYS_iread		172
#define SYS_iwrite		173
#define SYS_iinc		174
#define SYS_idec		175
#define SYS_afs_call		180
#endif	sun

#ifdef	vax
#define SYS_nfs_svc		159
#define SYS_statfs		160
#define SYS_fstatfs		161
#define SYS_unmount		162
#define SYS_async_daemon	163
#define SYS_getdirentries	164
#define SYS_nfs_getfh		165
#define SYS_quotactl		166
#define SYS_exportfs		167
#define SYS_vfsmount		168
#define SYS_getdomainname	169
#define SYS_setdomainname	170
#define SYS_pioctl		171
#define SYS_setpag		172
#define SYS_icreate		173
#define SYS_iopen		174
#define SYS_iread		175
#define SYS_iwrite		176
#define SYS_iinc		177
#define SYS_idec		178
#define SYS_afs_call		179
#endif	vax

#ifdef	i386
#define SYS_nfs_svc		159
#define SYS_statfs		160
#define SYS_fstatfs		161
#define SYS_unmount		162
#define SYS_async_daemon	163
#define SYS_getdirentries	164
#define SYS_nfs_getfh		165
#define SYS_quotactl		166
#define SYS_exportfs		167
#define SYS_vfsmount		168
#define SYS_getdomainname	169
#define SYS_setdomainname	170
#define SYS_pioctl		171
#define SYS_setpag		172
#define SYS_icreate		173
#define SYS_iopen		174
#define SYS_iread		175
#define SYS_iwrite		176
#define SYS_iinc		177
#define SYS_idec		178
#define SYS_afs_call		179
#endif	i386

#if	balance
#define SYS_getdirentries	151
#define SYS_tmp_ctl		152
#define SYS_universe		153
#define SYS_nfs_svc		155
#define SYS_statfs		157
#define SYS_fstatfs		158
#define SYS_unmount		159
#define SYS_async_daemon	160
#define SYS_nfs_getfh		161
#define SYS_getdomainname	162
#define SYS_setdomainname	163
#define SYS_quotactl		165
#define SYS_exportfs		166
#define SYS_vfsmount		167
#define SYS_pioctl		168
#define SYS_setpag		169
#define SYS_icreate		170
#define SYS_iopen		171
#define SYS_iread		172
#define SYS_iwrite		173
#define SYS_iinc		174
#define SYS_idec		175
#define SYS_afs_call		180
#endif	balance

#ifdef	mips
#define SYS_sysmips		151
				/* 152 - 157 are old */
#define SYS_nfs_svc		158
#define SYS_getdirentries	159
#define SYS_statfs		160
#define SYS_fstatfs		161
#define SYS_unmount		162
#define SYS_async_daemon	163
#define SYS_nfs_getfh		164
#define SYS_getdomainname	165
#define SYS_setdomainname	166
				/* 167 is old pcfs_mount */
#define SYS_quotactl		168
#define SYS_exportfs		169
#define SYS_vfsmount		170
				/* 171 is old */
				/* 172 - 187 is ultrix junk */
				/* 188 - 189 unused */
#define SYS_iopen		190
#define SYS_iread		191
#define SYS_iwrite		192
#define SYS_iinc		193
#define SYS_idec		194
#define SYS_pioctl		195
#define SYS_setpag		196
#define SYS_icreate		197
#define SYS_afs_call		198

#endif	mips

#if	multimax
#define	SYS_old_mapfrcounter	151
#define	SYS_mapfrcounter	152
#define	SYS_nfs_svc		155
#define	SYS_getdirentries	156
#define	SYS_statfs		157
#define	SYS_fstatfs		158
#define	SYS_unmount		159
#define	SYS_async_daemon	160
#define	SYS_nfs_getfh		161
#define	SYS_getdomainname	162
#define	SYS_setdomainname	163
#define	SYS_quotactl		165
#define	SYS_exportfs		166
#define	SYS_vfsmount		167
#define	SYS_pioctl		168
#define	SYS_setpag		169
#define	SYS_icreate		170
#define	SYS_iopen		171
#define	SYS_iread		172
#define	SYS_iwrite		173
#define	SYS_iinc		174
#define	SYS_idec		175
#define	SYS_afs_call		180
#endif	multimax

#if	!defined(KERNEL) || MACH_VMTP
#define SYS_invoke		182
#define SYS_recvreq		183
#define SYS_sendreply		184
#define SYS_forward		185
#define SYS_probeentity		186
#define SYS_getreply		187
#endif	!defined(KERNEL) || MACH_VMTP

#endif	_SYS_SYSCALL_H_
@EOF@

echo "include/sys/types.h"
cat >include/sys/types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	types.h,v $
 * Revision 2.6  89/07/12  01:28:10  jjc
 * 	Added definitions of "label_t" and "physadr" for SPARC.
 * 	[88/06/06            jjc]
 * 
 * Revision 2.5  89/03/09  22:09:27  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  17:57:44  gm0w
 * 	Made all CMUCS conditionals to be unconditional.
 * 	Changed romp to ibmrt.
 * 	[89/02/14            mrt]
 * 
 * Revision 2.3  89/01/23  22:29:21  af
 * 	Changes for I386:
 * 		define unchar
 * 		use physaddr and label_t like a vax ???
 * 	[89/01/09            rvb]
 * 	
 * 	Added Mips dependent definitions of "label_t" and "physaddr".
 * 	[89/01/04            af]
 * 
 * Revision 2.2  88/08/24  02:50:41  mwyoung
 * 	Adjusted include file references.
 * 	[88/08/17  02:26:37  mwyoung]
 * 
 * 10-Jun-87  Mary Thompson (mrt) at Carnegie Mellon
 *	Changed dependencies on CS_GENERIC to CMU in order to
 *	eliminate include of sys/features.
 *
 * 02-Mar-87  Mike Accetta (mja) at Carnegie-Mellon University
 *	CS_BUGFIX:  Restored previous unsigned fixes for _quad and
 *	off_t types by Bill Bolosky although this time under a
 *	different conditional and only under -DKERNEL so that, sigh,
 *	user programs which import the file but don't use the type
 *	consistently won't break.  Of course, lseek takes an off_t as
 *	its second paramter which can be legitimately signed.  This
 *	whole thing is a hack and I suspect that eventually someone is
 *	going to have to end up rewriting some kernel code.
 *	[ V5.1(F4) ]
 *
 * 24-Oct-86  Jonathan J. Chew (jjc) at Carnegie-Mellon University
 *	Added 68000 dependent definition of "label_t" and "physadr".
 *	Conditionalized on whether ASSEMBLER is undefined.
 *
 *  7-Oct-86  David L. Black (dlb) at Carnegie-Mellon University
 *	Merged Multimax changes.
 *
 * 24-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Moved boolean declaration to its own file.
 *
 * 23-Aug-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Renamed "machtypes.h" to "types.h".
 *
 * 16-Jul-86  Bill Bolosky (bolosky) at Carnegie-Mellon University
 *	CS_GENERIC: changed type quad from longs to u_longs,
 *	and off_t from int to u_long.
 *
 * 19-Feb-86  Bill Bolosky (bolosky) at Carnegie-Mellon University
 *	romp: Added alternate definitions of label_t and physaddr.
 *
 * 25-Jan-86  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Upgraded to 4.3.
 *
 * 15-Jun-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Allow for nested calls of types.h.
 *
 */
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)types.h	7.1 (Berkeley) 6/4/86
 */

#ifndef	_SYS_TYPES_H_
#define _SYS_TYPES_H_

#if	!defined(ASSEMBLER) && !defined(LOCORE)

/*
 * Basic system types and major/minor device constructing/busting macros.
 */

/* major part of a device */
#define major(x)	((int)(((unsigned)(x)>>8)&0377))

/* minor part of a device */
#define minor(x)	((int)((x)&0377))

/* make a device number */
#define makedev(x,y)	((dev_t)(((x)<<8) | (y)))

#include <:mach:machine:vm_types.h>

typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	unsigned short	ushort;		/* sys III compat */
#ifdef	i386
typedef	unsigned char	unchar;		/* kd driver compat */
#endif	i386

#if	defined(vax) || defined(ns32000) || defined(i386)
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	struct	label_t	{
	int	val[14];
} label_t;
#endif	defined(vax) || defined(ns32000) || defined(i386)
#ifdef	ibmrt
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	struct	label_t	{
	int	val[16];
} label_t;
#endif	ibmrt
#ifdef	mc68000
typedef struct  _physadr { short r[1]; } *physadr;
typedef struct  label_t {
        int     val[13];
} label_t;
#endif	mc68000
#ifdef sparc
typedef struct  _physadr { int r[1]; } *physadr;
typedef struct label_t {
        int     val[2];
} label_t;
#endif
#ifdef	mips
typedef	struct	_physadr { int r[1]; } *physadr;
/*
 * WARNING:
 * this must match the definition of kernel jmpbuf's in machine/pcb.h
 */
typedef	struct	label_t	{
	int	val[12];
} label_t;
#endif	mips
#ifdef	KERNEL
typedef	struct	_quad { u_long val[2]; } quad;
#else	KERNEL
typedef	struct	_quad { long val[2]; } quad;
#endif	KERNEL
typedef	long	daddr_t;
typedef	char *	caddr_t;
typedef	u_long	ino_t;
typedef	long	swblk_t;
typedef	long	size_t;
typedef	long	time_t;
typedef	short	dev_t;
#ifdef	KERNEL
typedef	u_long	off_t;
#else	KERNEL
typedef	long	off_t;
#endif	KERNEL
typedef	u_short	uid_t;
typedef	u_short	gid_t;

#define NBBY	8		/* number of bits in a byte */
/*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 */
#ifndef	FD_SETSIZE
#define FD_SETSIZE	256
#endif

typedef long	fd_mask;
#define NFDBITS	(sizeof(fd_mask) * NBBY)	/* bits per mask */
#ifndef	howmany
#define howmany(x, y)	(((x)+((y)-1))/(y))
#endif

typedef	struct fd_set {
	fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
} fd_set;

#define FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
#define FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
#define FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
#define FD_ZERO(p)	bzero((char *)(p), sizeof(*(p)))

#endif	ASSEMBLER
#endif	_SYS_TYPES_H_
@EOF@

echo "include/mac2/machparam.h"
cat >include/mac2/machparam.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	machparam.h,v $
 * Revision 2.2  90/08/30  18:23:58  bohman
 * 	Created.
 * 
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mac2/machparam.h
 */

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)machparam.h	7.1 (Berkeley) 6/5/86
 */

#ifndef _MACHINE_MACH_PARAM_H_
#define _MACHINE_MACH_PARAM_H_

#include <:mach:mac2:vm_param.h>

/*
 * Machine dependent constants for mac2.
 */
#define	NBPG	MAC2_PGBYTES		/* bytes/page */
#define	PGOFSET	(NBPG-1)		/* byte offset into page */
#define	PGSHIFT	MAC2_PGSHIFT		/* LOG2(NBPG) */

/*
 * These segment definitions
 * are only defined to allow
 * sun exec format compatability.
 */
#define	NBSG	131072		/* bytes/segment */
#define	SGOFSET	(NBSG-1)	/* byte offset into segment */
#define	SGSHIFT	17		/* LOG2(NBSG) */
#define NSGVA	2048		/* segments per virtual address space */

#define	CLSIZE		1
#define	CLSIZELOG2	0

#define	SSIZE		1	/* initial stack size/NBPG */
#define	SINCR		1	/* increment of stack/NBPG */

/*
 * UPAGES is defined to provide berkeley
 * debugger compatability.  The u-area
 * consists of the fake user structure
 * plus the thread kernel_stack (which
 * includes the thread pcb).
 */
#define	UPAGES		2

/* clicks to bytes */
#define	ctob(x)	((x)<<PGSHIFT)

/* bytes to clicks */
#define	btoc(x)	((((unsigned)(x)+(NBPG-1))>>PGSHIFT))

/*
 * Macros to decode processor status word.
 */
#define	USERMODE(ps)	(((ps) & SR_SUPR) == 0)
#define	BASEPRI(ps)	(((ps) & SR_IPL) == 0)

#ifdef KERNEL
#ifndef	ASSEMBLER
#include <:machine:cpu_inline.c>
#endif

#ifndef ASSEMBLER
int	cpuspeed;
#endif
#define	DELAY(n)	{ register int N = cpuspeed * (n); while (--N > 0); }

#else KERNEL
#define	DELAY(n)	{ register int N = (n); while (--N > 0); }
#endif KERNEL

/* the following are needed for BSD/TAHOE compatability */

#define MACHINE "mac2"

#include <:mac2:endian.h>

#define	CHAR_BIT	NBBY
#define	CHAR_MAX	0x7f
#define	CHAR_MIN	0x80
#define	CLK_TCK		60			/* for times() */
#define	INT_MAX		0x7fffffff
#define	INT_MIN		0x80000000
#define	LONG_MAX	0x7fffffff
#define	LONG_MIN	0x80000000
#define	SCHAR_MAX	0x7f
#define	SCHAR_MIN	0x80
#define	SHRT_MAX	0x7fff
#define	SHRT_MIN	0x8000
#define	UCHAR_MAX	0xff
#define	UINT_MAX	0xffffffff
#define	ULONG_MAX	0xffffffff
#define	USHRT_MAX	0xffff

#endif	_MACHINE_MACH_PARAM_H_
@EOF@

echo "include/mac2/endian.h"
cat >include/mac2/endian.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	endian.h,v $
 * Revision 2.2  90/08/30  11:01:12  bohman
 * 	Created.
 * 	[90/08/29  11:33:02  bohman]
 * 
 * 16-Jan-89  Zon Williamson (zon) at Carnegie-Mellon University
 *      Created this version for mac2 BSD/TAHOE compatability.
 *	This should be included by "machparam.h".
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mac2/endian.h
 */

/*
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)endian.h	7.3 (Berkeley) 6/29/88
 */ 

#ifndef _MAC2_ENDIAN_H_
#define _MAC2_ENDIAN_H_

/*
 * Definitions for byte order,
 * according to byte significance from low address to high.
 */
#undef LITTLE_ENDIAN
#undef BIG_ENDIAN
#undef PDP_ENDIAN
#define	LITTLE_ENDIAN	1234	/* least-significant byte first */
#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp) */

#define	BYTE_ORDER	BIG_ENDIAN	/* byte order on mac2 */

/*
 * Macros for network/external number representation conversion.
 */
#if BYTE_ORDER == BIG_ENDIAN && !defined(lint)
#define	ntohl(x)	(x)
#define	ntohs(x)	(x)
#define	htonl(x)	(x)
#define	htons(x)	(x)
#else
unsigned short	ntohs(), htons();
unsigned long	ntohl(), htonl();
#endif

#endif	_MAC2_ENDIAN_H_
@EOF@

echo "include/servers/errorlib.h"
cat >include/servers/errorlib.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	errorlib.h,v $
 * Revision 1.1  90/02/18  17:47:53  bww
 * 	Mach Release 2.5
 * 	[90/02/18  17:47:49  bww]
 * 
 * Revision 2.1  89/06/13  16:51:13  mrt
 * Created.
 * 
 * Revision 1.2  89/05/05  18:41:26  mrt
 * 	Added definition of SERV_NETMEMORY_MOD
 * 
 * 	16-May-88	Mary R. Thompson (mrt) at Carnegie Mellon
 * 	[89/04/29            mrt]
 * 
 *	Corrected the definitions of IPC_RCV_MOD and IPC_SEND_MOD
 *
 * 09-Mar-88	Douglas Orr (dorr) at Carnegie-Mellon University
 *	created.
 */
/*
 * File:	errrolib.h
 * Purpose:
 *	Generic error code interface
 */

#ifndef _ERRORLIB_H_
#define _ERRORLIB_H_

#include <:mach:error.h>

#define	IPC_SEND_MOD		(err_ipc|err_sub(0))
#define	IPC_RCV_MOD		(err_ipc|err_sub(1))
#define	IPC_MIG_MOD		(err_ipc|err_sub(2))

#define	SERV_NETNAME_MOD	(err_server|err_sub(0))
#define	SERV_ENV_MOD		(err_server|err_sub(1))
#define	SERV_EXECD_MOD		(err_server|err_sub(2))
#define	SERV_NETMEMORY_MOD	(err_server|err_sub(3))


#define	NO_SUCH_ERROR		"unknown error code"

struct error_subsystem {
	char			* subsys_name;
	int			max_code;
	char			* * codes;
};

struct error_system {
	int			max_sub;
	char			* bad_sub;
	struct error_subsystem	* subsystem;
};

extern	struct error_system 	errors[err_max_system+1];

#define	errlib_count(s)		(sizeof(s)/sizeof(s[0]))

#endif /* _ERRORLIB_H_ */
@EOF@

echo "include/servers/netname_defs.h"
cat >include/servers/netname_defs.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	netname_defs.h,v $
 * Revision 1.1  90/02/19  21:53:40  bww
 * 	Mach Release 2.5
 * 	[90/02/19  21:47:02  bww]
 * 
 * Revision 1.7  89/05/02  11:13:45  dpj
 * 	Fixed all files to conform to standard copyright/log format
 * 
 * 28-Jul-88  Mary R. Thompson (mrt) at Carnegie Mellon
 *	Copied definitions of NAME_NOT_YOURS and NAME_NOT_CHECKED_IN
 *	from the old netname_defs.h so that old code would not break
 *
 *  8-Mar-88  Daniel Julin (dpj) at Carnegie-Mellon University
 *	Added NETNAME_INVALID_PORT.
 *
 * 28-Feb-88  Daniel Julin (dpj) at Carnegie-Mellon University
 *	Added NETNAME_PENDING.
 *
 * 23-Dec-86  Robert Sansom (rds) at Carnegie Mellon University
 *	Copied from the previous version of the network server.
 *
 */
/*
 * netname_defs.h
 *
 *
 * $ Header: netname_defs.h,v 1.7 89/05/02 11:13:45 dpj Exp $
 *
 */

/*
 * Definitions for the mig interface to the network name service.
 */


#ifndef	_NETNAME_DEFS_
#define	_NETNAME_DEFS_

#define NETNAME_SUCCESS		(0)
#define	NETNAME_PENDING		(-1)
#define NETNAME_NOT_YOURS	(1000)
#define NAME_NOT_YOURS		(1000)
#define NETNAME_NOT_CHECKED_IN	(1001)
#define NAME_NOT_CHECKED_IN	(1001)
#define NETNAME_NO_SUCH_HOST	(1002)
#define NETNAME_HOST_NOT_FOUND	(1003)
#define	NETNAME_INVALID_PORT	(1004)

typedef char netname_name_t[80];

#endif /* NETNAME_DEFS_ */
@EOF@

echo "include/servers/netmemory_defs.h"
cat >include/servers/netmemory_defs.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	netmemory_defs.h,v $
 * Revision 1.1  90/02/19  21:48:21  bww
 * 	Mach Release 2.5
 * 	[90/02/19  21:47:02  bww]
 * 
 * Revision 1.3  89/08/24  17:46:18  mrt
 * 	Cleanup
 * 
 * Revision 1.2  89/04/29  13:22:14  mrt
 * 	Clean up for Mach 2.5. Inlcuded servers/errorlib.h to define
 * 	errorcode base.
 * 	[89/04/29            mrt]
 * 
 */
/*
 *	File:	netmemory_defs.h
 *	Author:	Joseph S. Barrera III
 *
 *	Copyright (C) 1989, Joseph S. Barrera III
 *
 *	C definitions for netmemory mig interface.
 *
 */

#ifndef	NETMEMORY_DEFS
#define	NETMEMORY_DEFS		1

#include <:mach:error.h>
#include <:servers:errorlib.h>


#define	NETMEMORY_SUCCESS		ERR_SUCCESS
#define NETMEMORY_INVALID_ARGUMENT	(SERV_NETMEMORY_MOD | 0x1)
#define	NETMEMORY_RESOURCE_SHORTAGE	(SERV_NETMEMORY_MOD | 0x2)

typedef mach_error_t netmemory_return_t;

typedef struct fault_info {
    int read_faults;
    int write_faults;
    int protection_faults;
} fault_info_t;

#endif	/* NETMEMORY_DEFS */
@EOF@

echo "include/servers/emdefs.h"
cat >include/servers/emdefs.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	emdefs.h,v $
 * Revision 1.1  90/02/19  21:47:12  bww
 * 	Mach Release 2.5
 * 	[90/02/19  21:47:02  bww]
 * 
 * Revision 1.4  89/07/30  20:28:47  mrt
 * 	Made error code values start ate SERV_ENV_MOD+0 instead of +1 to
 * 	correspond to error_code routine.
 * 	[89/07/29            mrt]
 * 
 * Revision 1.3  89/05/09  22:00:38  mrt
 * 	Added ENV_PORT_NULL error code.
 * 	[89/05/06            mrt]
 * 
 * Revision 1.2  89/05/05  18:28:59  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*  
 *  File: emdefs
 *	Exported definitions for Environment Maganger
 *  Author: Mary Thompson
 */

#ifndef _env_mgr_defs
#define _env_mgr_defs

#include <:servers:errorlib.h>

#define env_name_size		(80)
#define env_val_size		(256)

#define ENV_SUCCESS			(KERN_SUCCESS)

#define ENV_VAR_NOT_FOUND	(SERV_ENV_MOD | 0)
#define ENV_WRONG_VAR_TYPE	(SERV_ENV_MOD | 1)
#define ENV_UNKNOWN_PORT	(SERV_ENV_MOD | 2)
#define ENV_READ_ONLY		(SERV_ENV_MOD | 3)
#define ENV_NO_MORE_CONN	(SERV_ENV_MOD | 4)
#define ENV_PORT_TABLE_FULL	(SERV_ENV_MOD | 5)
#define ENV_PORT_NULL		(SERV_ENV_MOD | 6)

typedef char	env_name_t[env_name_size];

typedef char	env_str_val_t[env_val_size];

typedef env_name_t *env_name_list; 	/* Variable sized array */

typedef env_str_val_t *env_str_list; 	/* Variable sized array */

#endif /* _env_mgr_defs */
@EOF@

echo "include/servers/ipcx_types.h"
cat >include/servers/ipcx_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	ipcx_types.h,v $
 * Revision 1.1  90/02/19  21:47:39  bww
 * 	Mach Release 2.5
 * 	[90/02/19  21:47:02  bww]
 * 
 * Revision 1.2  89/07/04  17:37:03  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*
 * Abstract: ipcx_types.h
 *	declarations for ipcexecd 
 */
#ifndef _ipcx_types
#define _ipcx_types

typedef char a_string[256];

#define DEFAULT_PREFIX	"Mach-"

#define IPC_ERROR_BASE  	27600
#define IPCX_FILENOTFOUND 	(IPC_ERROR_BASE + 0)
#define IPCX_USERWRONG	 	(IPC_ERROR_BASE + 1)
#define IPCX_FORKFAILED 	(IPC_ERROR_BASE + 2)

#endif /* _ipcx_types */

@EOF@

echo "include/servers/netname.h"
cat >include/servers/netname.h <<'@EOF@'
#ifndef	_netname
#define	_netname

/* Module netname */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_netname
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include "netname_defs.h"

/* Routine netname_check_in */
mig_external kern_return_t netname_check_in
#if	defined(LINTLIBRARY)
    (server_port, port_name, signature, port_id)
	port_t server_port;
	netname_name_t port_name;
	port_t signature;
	port_t port_id;
{ return netname_check_in(server_port, port_name, signature, port_id); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t port_name,
	port_t signature,
	port_t port_id
);
#else
    ();
#endif
#endif

/* Routine netname_look_up */
mig_external kern_return_t netname_look_up
#if	defined(LINTLIBRARY)
    (server_port, host_name, port_name, port_id)
	port_t server_port;
	netname_name_t host_name;
	netname_name_t port_name;
	port_t *port_id;
{ return netname_look_up(server_port, host_name, port_name, port_id); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t host_name,
	netname_name_t port_name,
	port_t *port_id
);
#else
    ();
#endif
#endif

/* Routine netname_check_out */
mig_external kern_return_t netname_check_out
#if	defined(LINTLIBRARY)
    (server_port, port_name, signature)
	port_t server_port;
	netname_name_t port_name;
	port_t signature;
{ return netname_check_out(server_port, port_name, signature); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t port_name,
	port_t signature
);
#else
    ();
#endif
#endif

/* Routine netname_version */
mig_external kern_return_t netname_version
#if	defined(LINTLIBRARY)
    (server_port, version)
	port_t server_port;
	netname_name_t version;
{ return netname_version(server_port, version); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t version
);
#else
    ();
#endif
#endif

#endif	_netname
@EOF@

echo "include/servers/env_mgr.h"
cat >include/servers/env_mgr.h <<'@EOF@'
#ifndef	_env_mgr
#define	_env_mgr

/* Module env_mgr */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_env_mgr
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>
#include <:servers:emdefs.h>

/* Routine env_set_string */
mig_external kern_return_t env_set_string
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	env_str_val_t env_val;
{ return env_set_string(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	env_str_val_t env_val
);
#else
    ();
#endif
#endif

/* Routine env_get_string */
mig_external kern_return_t env_get_string
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	env_str_val_t env_val;
{ return env_get_string(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	env_str_val_t env_val
);
#else
    ();
#endif
#endif

/* Routine env_del_string */
mig_external kern_return_t env_del_string
#if	defined(LINTLIBRARY)
    (port, env_name)
	port_t port;
	env_name_t env_name;
{ return env_del_string(port, env_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name
);
#else
    ();
#endif
#endif

/* Routine env_set_port */
mig_external kern_return_t env_set_port
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	port_t env_val;
{ return env_set_port(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	port_t env_val
);
#else
    ();
#endif
#endif

/* Routine env_get_port */
mig_external kern_return_t env_get_port
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	port_t *env_val;
{ return env_get_port(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	port_t *env_val
);
#else
    ();
#endif
#endif

/* Routine env_del_port */
mig_external kern_return_t env_del_port
#if	defined(LINTLIBRARY)
    (port, env_name)
	port_t port;
	env_name_t env_name;
{ return env_del_port(port, env_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name
);
#else
    ();
#endif
#endif

/* Routine env_list_strings */
mig_external kern_return_t env_list_strings
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt)
	port_t port;
	env_name_list *env_names;
	unsigned int *env_namesCnt;
	env_str_list *env_string_vals;
	unsigned int *env_string_valsCnt;
{ return env_list_strings(port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list *env_names,
	unsigned int *env_namesCnt,
	env_str_list *env_string_vals,
	unsigned int *env_string_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_list_ports */
mig_external kern_return_t env_list_ports
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt)
	port_t port;
	env_name_list *env_names;
	unsigned int *env_namesCnt;
	port_array_t *env_ports_vals;
	unsigned int *env_ports_valsCnt;
{ return env_list_ports(port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list *env_names,
	unsigned int *env_namesCnt,
	port_array_t *env_ports_vals,
	unsigned int *env_ports_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_set_stlist */
mig_external kern_return_t env_set_stlist
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt)
	port_t port;
	env_name_list env_names;
	unsigned int env_namesCnt;
	env_str_list env_string_vals;
	unsigned int env_string_valsCnt;
{ return env_set_stlist(port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list env_names,
	unsigned int env_namesCnt,
	env_str_list env_string_vals,
	unsigned int env_string_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_set_ptlist */
mig_external kern_return_t env_set_ptlist
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt)
	port_t port;
	env_name_list env_names;
	unsigned int env_namesCnt;
	port_array_t env_ports_vals;
	unsigned int env_ports_valsCnt;
{ return env_set_ptlist(port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list env_names,
	unsigned int env_namesCnt,
	port_array_t env_ports_vals,
	unsigned int env_ports_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_copy_conn */
mig_external kern_return_t env_copy_conn
#if	defined(LINTLIBRARY)
    (port, new_env_port)
	port_t port;
	port_t *new_env_port;
{ return env_copy_conn(port, new_env_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
);
#else
    ();
#endif
#endif

/* Routine env_new_conn */
mig_external kern_return_t env_new_conn
#if	defined(LINTLIBRARY)
    (port, new_env_port)
	port_t port;
	port_t *new_env_port;
{ return env_new_conn(port, new_env_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
);
#else
    ();
#endif
#endif

/* Routine env_restrict_conn */
mig_external kern_return_t env_restrict_conn
#if	defined(LINTLIBRARY)
    (port, new_env_port)
	port_t port;
	port_t *new_env_port;
{ return env_restrict_conn(port, new_env_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
);
#else
    ();
#endif
#endif

/* Routine env_disconnect */
mig_external kern_return_t env_disconnect
#if	defined(LINTLIBRARY)
    (port)
	port_t port;
{ return env_disconnect(port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port
);
#else
    ();
#endif
#endif

#endif	_env_mgr
@EOF@

echo "include/servers/service.h"
cat >include/servers/service.h <<'@EOF@'
#ifndef	_service
#define	_service

/* Module service */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_service
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>

/* Routine old_service_checkin */
mig_external kern_return_t old_service_checkin
#if	defined(LINTLIBRARY)
    (service_request, service_desired, service_granted)
	port_t service_request;
	port_t service_desired;
	port_t *service_granted;
{ return old_service_checkin(service_request, service_desired, service_granted); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t service_request,
	port_t service_desired,
	port_t *service_granted
);
#else
    ();
#endif
#endif

/* Routine service_checkin */
mig_external kern_return_t service_checkin
#if	defined(LINTLIBRARY)
    (service_request, service_desired, service_granted)
	port_t service_request;
	port_t service_desired;
	port_t *service_granted;
{ return service_checkin(service_request, service_desired, service_granted); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t service_request,
	port_t service_desired,
	port_t *service_granted
);
#else
    ();
#endif
#endif

#endif	_service
@EOF@

echo "include/servers/netmemory.h"
cat >include/servers/netmemory.h <<'@EOF@'
#ifndef	_netmemory
#define	_netmemory

/* Module netmemory */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_netmemory
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:mach_types.h>
#include "netmemory_defs.h"

/* Routine netmemory_create */
mig_external kern_return_t netmemory_create
#if	defined(LINTLIBRARY)
    (server_port, object_size, paging_object, control_port)
	port_t server_port;
	vm_size_t object_size;
	port_t *paging_object;
	port_t *control_port;
{ return netmemory_create(server_port, object_size, paging_object, control_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	vm_size_t object_size,
	port_t *paging_object,
	port_t *control_port
);
#else
    ();
#endif
#endif

/* Routine netmemory_destroy */
mig_external kern_return_t netmemory_destroy
#if	defined(LINTLIBRARY)
    (control_port)
	port_t control_port;
{ return netmemory_destroy(control_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t control_port
);
#else
    ();
#endif
#endif

/* Routine netmemory_cache */
mig_external kern_return_t netmemory_cache
#if	defined(LINTLIBRARY)
    (server_port, paging_object, local_paging_object)
	port_t server_port;
	port_t paging_object;
	port_t *local_paging_object;
{ return netmemory_cache(server_port, paging_object, local_paging_object); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	port_t paging_object,
	port_t *local_paging_object
);
#else
    ();
#endif
#endif

/* Routine paging_object_server_statistics */
mig_external kern_return_t paging_object_server_statistics
#if	defined(LINTLIBRARY)
    (object_server, rusage, rusageCnt, faults_total, faults_totalCnt)
	port_t object_server;
	pointer_t *rusage;
	unsigned int *rusageCnt;
	pointer_t *faults_total;
	unsigned int *faults_totalCnt;
{ return paging_object_server_statistics(object_server, rusage, rusageCnt, faults_total, faults_totalCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t object_server,
	pointer_t *rusage,
	unsigned int *rusageCnt,
	pointer_t *faults_total,
	unsigned int *faults_totalCnt
);
#else
    ();
#endif
#endif

/* Routine netmemory_cover */
mig_external kern_return_t netmemory_cover
#if	defined(LINTLIBRARY)
    (server_port, object_data, object_dataCnt, paging_object, control_port)
	port_t server_port;
	pointer_t object_data;
	unsigned int object_dataCnt;
	port_t *paging_object;
	port_t *control_port;
{ return netmemory_cover(server_port, object_data, object_dataCnt, paging_object, control_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	pointer_t object_data,
	unsigned int object_dataCnt,
	port_t *paging_object,
	port_t *control_port
);
#else
    ();
#endif
#endif

#endif	_netmemory
@EOF@

echo "include/mach/boolean.h"
cat >include/mach/boolean.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	boolean.h,v $
 * Revision 2.6  89/04/05  13:03:18  rvb
 * 	DON'T type cast TRUE and FALSE this causes major problems with
 * 	GCC, since boolean_t is an int and can not fit into a 1 bit
 * 	unsigned field.  BUT 0 and 1 can.
 * 	[89/03/21            rvb]
 * 
 * Revision 2.5  89/03/09  20:18:18  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:12:08  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  00:51:34  mwyoung
 * Relocated from sys/boolean.h
 * 
 * Revision 2.2  88/08/24  02:23:06  mwyoung
 * 	Adjusted include file references.
 * 	[88/08/17  02:09:46  mwyoung]
 *
 * 18-Nov-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Header file fixup, purge history.
 *
 */
/*
 *	File:	mach/boolean.h
 *
 *	Boolean data type.
 *
 */

#ifndef	_MACH_BOOLEAN_H_
#define _MACH_BOOLEAN_H_

/*
 *	Pick up "boolean_t" type definition
 */

#ifndef	ASSEMBLER
#include <:mach:machine:boolean.h>
#endif	ASSEMBLER
#endif	_MACH_BOOLEAN_H_

/*
 *	Define TRUE and FALSE, only if they haven't been before,
 *	and not if they're explicitly refused.  Note that we're
 *	outside the BOOLEAN_H_ conditional, to avoid ordering
 *	problems.
 */

#if	(defined(KERNEL) || defined(EXPORT_BOOLEAN)) && !defined(NOBOOL)

#ifndef	TRUE
#define TRUE	1
#endif	TRUE

#ifndef	FALSE
#define FALSE	0
#endif	FALSE

#endif	(defined(KERNEL) || defined(EXPORT_BOOLEAN)) && !defined(NOBOOL)
@EOF@

echo "include/mach/device.defs"
cat >include/mach/device.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	device.defs,v $
 * Revision 2.3  89/02/25  18:13:01  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:29:03  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:37:41  rpd]
 * 
 * Revision 2.4  89/01/12  07:52:24  rpd
 * 	Fixed includes/imports.
 * 
 * 29-Jun-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Moved data type declarations to "mach_types.defs".
 *
 * 10-Feb-88  Douglas Orr (dorr) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 * File:	mach/device.defs
 *
 * Abstract:
 *	Mach device support.  Mach devices are accessed through
 *	block and character device interfaces to the kernel.
 */

subsystem device 2500;
#include <:mach:std_types.defs>
#include <:mach:device_types.defs>

simpleroutine	block_write(
	    port		: port_t;
	in  device		: dev_t;
	in  block_number	: daddr_t;
	in  block_size		: int;
	in  block		: io_buf_t
	);

simpleroutine	block_write_async(
	    port		: port_t;
	in  device		: dev_t;
	in  block_number	: daddr_t;
	in  block_size		: int;
	in  block		: io_buf_t
	);

routine	block_read(
	    port		: port_t;
	in  device		: dev_t;
	in  block_number	: daddr_t;
	in  block_size		: int;
	out block		: io_buf_ptr_t
	);

routine	block_read_ahead(
	    port		: port_t;
	in  device		: dev_t;
	in  block_number	: daddr_t;
	in  ra_block_number	: daddr_t;
	in  block_size		: int;
	out block		: io_buf_ptr_t
	);
@EOF@

echo "include/mach/device_types.defs"
cat >include/mach/device_types.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	device_types.defs,v $
 * Revision 2.5  89/04/08  23:40:14  rpd
 * 	Cleaned up definition of io_buf_ptr_t.
 * 	[89/04/08  22:52:30  rpd]
 * 
 * Revision 2.4  89/03/09  20:19:12  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:13:08  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:29:17  rpd
 * 	Created from device.defs.
 * 	[89/01/15  14:31:32  rpd]
 * 
 */
/*
 *	Mach kernel device interface type declarations
 */

#ifndef	_MACH_DEVICE_TYPES_DEFS_
#define _MACH_DEVICE_TYPES_DEFS_

#include <:mach:std_types.defs>

type dev_t = short;
type daddr_t = int;

import <sys/types.h>;

type io_buf_t = ^int;
type io_buf_ptr_t = ^array[] of MSG_TYPE_INTEGER_8;

import <mach/device_types.h>;

#endif	_MACH_DEVICE_TYPES_DEFS_
@EOF@

echo "include/mach/device_types.h"
cat >include/mach/device_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	device_types.h,v $
 * Revision 2.4  89/03/09  20:19:18  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:13:13  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:29:33  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:34:58  rpd]
 * 
 * Revision 2.2  89/01/12  11:14:32  rpd
 * 	Created.
 * 	[89/01/12  11:13:03  rpd]
 * 
 */
/*
 *	Mach kernel device interface type declarations
 *
 */

#ifndef	_MACH_DEVICE_TYPES_H_
#define _MACH_DEVICE_TYPES_H_

typedef char		* io_buf_t;	
typedef io_buf_t	* io_buf_ptr_t;

#endif	_MACH_DEVICE_TYPES_H_
@EOF@

echo "include/mach/error.h"
cat >include/mach/error.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	error.h,v $
 * Revision 2.5  89/03/09  20:19:23  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:13:18  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  00:51:57  mwyoung
 * Relocated from sys/error.h
 * 
 * Revision 2.2  88/10/18  00:37:31  mwyoung
 * 	Added {system,sub and code}_emask 
 * 	[88/10/17  17:06:58  mrt]
 * 
 *	Added {system,sub and code}_emask 
 *
 *  12-May-88 Mary Thompson (mrt) at Carnegie Mellon
 *	Changed mach_error_t from unsigned int to kern_return_t
 *	which is a 32 bit integer regardless of machine type.
 *      insigned int was incompatible with old usages of mach_error.
 *
 *  10-May-88 Douglas Orr (dorr) at Carnegie-Mellon University
 *	Missing endif replaced
 *
 *   5-May-88 Mary Thompson (mrt) at Carnegie Mellon
 *	Changed typedef of mach_error_t from long to unsigned int
 *	to keep our Camelot users happy. Also moved the nonkernel
 *	function declarations from here to mach_error.h.
 *
 *  10-Feb-88 Douglas Orr (dorr) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 * File:	mach/error.h
 * Purpose:
 *	error module definitions
 *
 */

#ifndef	_MACH_ERROR_H_
#define _MACH_ERROR_H_

#include <:mach:kern_return.h>

/*
 *	error number layout as follows:
 *
 *	hi		 		       lo
 *	| system(6) | subsystem(12) | code(14) |
 */


#define err_none		(mach_error_t)0
#define ERR_SUCCESS		(mach_error_t)0
#define ERR_ROUTINE_NIL		(mach_error_fn_t)0


#define err_system(x)		(((x)&0x3f)<<26)
#define err_sub(x)		(((x)&0xfff)<<14)

#define err_get_system(err)	(((err)>>26)&0x3f)
#define err_get_sub(err)	(((err)>>14)&0xfff)
#define err_get_code(err)	((err)&0x3fff)

#define system_emask		(err_system(0x3f))
#define sub_emask		(err_sub(0xfff))
#define code_emask		(0x3fff)


/*	major error systems	*/
#define err_kern		err_system(0x0)		/* kernel */
#define err_us			err_system(0x1)		/* user space library */
#define err_server		err_system(0x2)		/* user space servers */
#define err_ipc			err_system(0x3)		/* mach-ipc errors */
#define err_local		err_system(0x3e)	/* user defined errors */
#define err_ipc_compat		err_system(0x3f)	/* (compatibility) mach-ipc errors */

#define err_max_system		0x3f


/*	unix errors get lumped into one subsystem  */
#define unix_err(errno)		(err_kern|err_sub(3)|errno)

typedef	kern_return_t	mach_error_t;
typedef mach_error_t	(* mach_error_fn_t)();

#endif	_MACH_ERROR_H_
@EOF@

echo "include/mach/exc.defs"
cat >include/mach/exc.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exc.defs,v $
 * Revision 2.3  89/02/25  18:13:23  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:29:49  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:38:37  rpd]
 * 
 * Revision 2.3  89/01/12  07:53:10  rpd
 * 	Fixed includes.
 * 
 * 29-Jun-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Moved data type declarations to "mach_types.defs".
 *
 * 30-Nov-87  David Black (dlb) at Carnegie-Mellon University
 *	Rewrote interface to use messages for synchronization.
 *
 *  9-Oct-87  David Black (dlb) at Carnegie-Mellon University
 *	Translation won't work for this interface; all combinations of 
 *	user/kernel to user/kernel are possible.  Removed translation.
 *
 * 29-Sep-87  David Black (dlb) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 * Abstract:
 *	MiG definitions file for Mach exception interface.
 */

subsystem exc 2400;

#include <:mach:std_types.defs>

ServerPrefix catch_;

routine		exception_raise(
	requestport	exception_port	: port_t;
	replyport	clear_port	: port_t;
			thread		: port_t;
			task		: port_t;
			exception	: int;
			code		: int;
			subcode		: int);
@EOF@

echo "include/mach/exception.h"
cat >include/mach/exception.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exception.h,v $
 * Revision 2.6  89/10/15  02:05:21  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.5  89/03/09  20:19:30  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:13:29  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  00:52:07  mwyoung
 * Relocated from sys/exception.h
 * 
 * Revision 2.2  88/08/24  02:26:52  mwyoung
 * 	Adjusted include file references.
 * 	[88/08/17  02:12:09  mwyoung]
 *
 * 29-Sep-87  David Black (dlb) at Carnegie-Mellon University
 *	Created.
 *
 */

#ifndef	_MACH_EXCEPTION_H_
#define _MACH_EXCEPTION_H_

#include <:mach:machine:exception.h>

/*
 *	Machine-independent exception definitions.
 */

#define EXC_BAD_ACCESS		1	/* Could not access memory */
		/* Code contains kern_return_t describing error. */
		/* Subcode contains bad memory address. */

#define EXC_BAD_INSTRUCTION	2	/* Instruction failed */
		/* Illegal or undefined instruction or operand */

#define EXC_ARITHMETIC		3	/* Arithmetic exception */
		/* Exact nature of exception is in code field */

#define EXC_EMULATION		4	/* Emulation instruction */
		/* Emulation support instruction encountered */
		/* Details in code and subcode fields	*/

#define EXC_SOFTWARE		5	/* Software generated exception */
		/* Exact exception is in code field. */
		/* Codes 0 - 0xFFFF reserved to hardware */
		/* Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) */

#define EXC_BREAKPOINT		6	/* Trace, breakpoint, etc. */
		/* Details in code field. */

#endif	_MACH_EXCEPTION_H_
@EOF@

echo "include/mach/host_info.h"
cat >include/mach/host_info.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	host_info.h,v $
 * Revision 2.4  89/10/15  02:05:31  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.3  89/10/11  17:32:15  dlb
 * 	Include mach/machine/vm_types.h instead of mach/vm_param.h
 * 	[89/10/11            dlb]
 * 
 * Revision 2.2  89/10/11  14:36:55  dlb
 * 	Add sched_info flavor to return minimum times for use by
 * 	external schedulers.
 * 	[89/06/08            dlb]
 * 
 * 	Added kernel_version type definitions.
 * 	[88/12/02            dlb]
 * 
 * Revision 2.1.1.3  89/08/02  23:07:57  dlb
 * 	Cleanup changes.
 * 	[89/08/02            dlb]
 * 
 * Revision 2.1.1.2  89/07/25  18:45:09  dlb
 * 	Add sched_info flavor to return minimum times for use by
 * 	external schedulers.
 * 	[89/06/08            dlb]
 * 
 * Revision 2.1.1.1  89/01/30  22:42:52  dlb
 * 	Added kernel_version type definitions.
 * 	[88/12/02            dlb]
 * 
 * 30-Nov-88  David Black (dlb) at Carnegie-Mellon University
 *	Created.  2 flavors so far: basic info,  slot numbers.
 *
 */

/*
 *	File:	mach/host_info.h
 *
 *	Definitions for host_info call.
 */

#ifndef	_MACH_HOST_INFO_H_
#define	_MACH_HOST_INFO_H_

#include <:mach:machine.h>
#include <:mach:machine:vm_types.h>

/*
 *	Generic information structure to allow for expansion.
 */
typedef int	*host_info_t;		/* varying array of int. */

#define	HOST_INFO_MAX	(1024)		/* max array size */
typedef int	host_info_data_t[HOST_INFO_MAX];

#define KERNEL_VERSION_MAX (512)
typedef char	kernel_version_t[KERNEL_VERSION_MAX];
/*
 *	Currently defined information.
 */
#define HOST_BASIC_INFO		1	/* basic info */
#define HOST_PROCESSOR_SLOTS	2	/* processor slot numbers */
#define HOST_SCHED_INFO		3	/* scheduling info */

struct host_basic_info {
	int		max_cpus;	/* max number of cpus possible */
	int		avail_cpus;	/* number of cpus now available */
	vm_size_t	memory_size;	/* size of memory in bytes */
	cpu_type_t	cpu_type;	/* cpu type */
	cpu_subtype_t	cpu_subtype;	/* cpu subtype */
};

typedef	struct host_basic_info	host_basic_info_data_t;
typedef struct host_basic_info	*host_basic_info_t;
#define HOST_BASIC_INFO_COUNT \
		(sizeof(host_basic_info_data_t)/sizeof(int))

struct host_sched_info {
	int		min_timeout;	/* minimum timeout in milliseconds */
	int		min_quantum;	/* minimum quantum in milliseconds */
};

typedef	struct host_sched_info	host_sched_info_data_t;
typedef struct host_sched_info	*host_sched_info_t;
#define HOST_SCHED_INFO_COUNT \
		(sizeof(host_sched_info_data_t)/sizeof(int))

#endif	_MACH_HOST_INFO_H_
@EOF@

echo "include/mach/kern_return.h"
cat >include/mach/kern_return.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	kern_return.h,v $
 * Revision 2.9  90/07/03  16:38:33  mrt
 * 	Add KERN_MEMORY_PRESENT.
 * 	[90/06/21  19:55:20  dlb]
 * 
 * Revision 2.8  89/10/11  14:37:06  dlb
 * 	Add KERN_ABORTED for internal use only.
 * 	[89/03/07            dlb]
 * 
 * Revision 2.7  89/03/09  20:20:17  rpd
 * 	More cleanup.
 * 
 * Revision 2.6  89/02/25  18:13:36  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.5  89/02/07  00:52:16  mwyoung
 * Relocated from sys/kern_return.h
 * 
 * Revision 2.4  88/08/24  02:31:47  mwyoung
 * 	Adjusted include file references.
 * 	[88/08/17  02:15:07  mwyoung]
 * 
 * Revision 2.3  88/07/20  16:48:31  rpd
 * Added KERN_NAME_EXISTS.
 * Added KERN_ALREADY_IN_SET, KERN_NOT_IN_SET.
 * Made comments legible.
 * 
 *  3-Feb-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added memory management error conditions.
 *	Documented.
 *
 * 23-Feb-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Deleted kern_return_t casts on error codes so that they may be
 *	used in assembly code.
 *
 * 17-Sep-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 */
/*
 *	File:	h/kern_return.h
 *	Author:	Avadis Tevanian, Jr.
 *	Copyright (C) 1985, Avadis Tevanian, Jr.
 *
 *	Kernel return codes.
 *
 */

#ifndef	_MACH_KERN_RETURN_H_
#define _MACH_KERN_RETURN_H_

#include <:mach:machine:kern_return.h>

#define KERN_SUCCESS			0

#define KERN_INVALID_ADDRESS		1
		/* Specified address is not currently valid.
		 */

#define KERN_PROTECTION_FAILURE		2
		/* Specified memory is valid, but does not permit the
		 * required forms of access.
		 */

#define KERN_NO_SPACE			3
		/* The address range specified is already in use, or
		 * no address range of the size specified could be
		 * found.
		 */

#define KERN_INVALID_ARGUMENT		4
		/* The function requested was not applicable to this
		 * type of argument, or an argument
		 */

#define KERN_FAILURE			5
		/* The function could not be performed.  A catch-all.
		 */

#define KERN_RESOURCE_SHORTAGE		6
		/* A system resource could not be allocated to fulfill
		 * this request.  This failure may not be permanent.
		 */

#define KERN_NOT_RECEIVER		7
		/* The task in question does not hold receive rights
		 * for the port argument.
		 */

#define KERN_NO_ACCESS			8
		/* Bogus access restriction.
		 */

#define KERN_MEMORY_FAILURE		9
		/* During a page fault, the target address refers to a
		 * memory object that has been destroyed.  This
		 * failure is permanent.
		 */

#define KERN_MEMORY_ERROR		10
		/* During a page fault, the memory object indicated
		 * that the data could not be returned.  This failure
		 * may be temporary; future attempts to access this
		 * same data may succeed, as defined by the memory
		 * object.
		 */

#define KERN_ALREADY_IN_SET		11
		/* The port argument is already a member of a set.
		 */

#define KERN_NOT_IN_SET			12
		/* The port argument is not a member of a set.
		 */

#define KERN_NAME_EXISTS		13
		/* The task already has a translation for the name.
		 */

#define KERN_ABORTED			14
		/* The operation was aborted.  Ipc code will
		 * catch this and reflect it as a message error.
		 */

#define KERN_MEMORY_PRESENT		15
		/* An attempt was made to supply "precious" data
		 * for memory that is already present in a
		 * memory object.
		 */

#endif	_MACH_KERN_RETURN_H_
@EOF@

echo "include/mach/kernel_event.h"
cat >include/mach/kernel_event.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	kernel_event.h,v $
 * Revision 2.3  89/10/15  02:05:36  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.2  89/10/11  14:37:21  dlb
 * 	Add constants from kern_mon_param.h. Cleanup.
 * 	[89/08/02            dlb]
 * 
 * 	Added the kern_mon_data_t and kern_mon_buffer_t types for the
 * 	structure.
 * 	[89/02/16            tfl]
 * 
 * Revision 2.1.1.2  89/08/02  23:44:50  dlb
 * 	Add constants from kern_mon_param.h. Cleanup.
 * 	[89/08/02            dlb]
 * 
 * Revision 2.1.1.1  89/07/26  12:04:21  dlb
 * 	Added the kern_mon_data_t and kern_mon_buffer_t types for the
 * 	structure.
 * 	[89/02/16            tfl]
 * 
 * 	Created.
 * 	[88/04/15            tfl]
 * 
 */
/*
 *	File:	kernel_event.h
 *	Author:	Ted Lehr
 *
 *	Copyright (C) 1987, Ted Lehr
 *
 * 	Kernel Monitoring header file to be exported to user.  Contains
 *	the the definition of a kernel event.  
 *
 */

#ifndef _MACH_KERNEL_EVENT_H_
#define _MACH_KERNEL_EVENT_H_

/*
 * The kern_mon_data_t and kern_mon_buffer_t are used by MIG
 * to generate the interfaces correctly.  They are not
 * "necessary" but fulfill stylistic conventions.
 */

typedef
struct 	kernel_event {	/* unit kernel event */
	 unsigned 	event_type;	 /* the type of kernel event	*/
	 unsigned	first_element;	 /* the stopped thread 		*/
	 unsigned	second_element;  /* the started thread 		*/
	 unsigned	third_element;   /* flag and cpu number 	*/
	 unsigned 	hi_time;         /* hi time stamp 		*/
	 unsigned 	lo_time;         /* lo time stamp 		*/
} kern_mon_event, *kern_mon_event_t, kern_mon_data_t, *kern_mon_buffer_t;

#define MONITOR_MIG_BUF_SIZE    320             /* ONLY allowable size of   *
						 * buffer passed to monitor *
						 * calls                    */


/***************************************************************************
 *
 *	Kernel Sensor types:
 */
#define MONITOR_CNTXT_SWTCH	0x0;

#endif _MACH_KERNEL_EVENT_H_
@EOF@

echo "include/mach/mach.defs"
cat >include/mach/mach.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach.defs,v $
 * Revision 2.14  90/07/03  16:38:38  mrt
 * 	Eliminate MACH_XP conditionals.  Prefix pager_cache with xxx.
 * 	Add deallocate support to memory_object_data_supply.  Until MiG
 * 	is fixed, this always deallocates its data (XXX).
 * 	Remove pager_data_provided_inline.
 * 	Add memory_object_data_supply.
 * 	Convert vm_set_default_memory_manager to use real host port.
 * 	[90/06/11            dlb]
 * 
 * Revision 2.13  90/03/08  23:10:53  af
 * 		Added vm_machine_attribute.
 * 	[90/01/14            af]
 * 
 * Revision 2.12  90/02/20  19:43:48  mrt
 * 		Removed vm_allocate_with_pager. It has been obsolete for some
 * 		time and its inclusion messes up the libmach.a write-around.
 * 		Removed ancient history and content-free log mesages.
 * 	[90/02/20            mrt]
 * 
 * Revision 2.11  89/10/11  14:37:34  dlb
 * 	Prefix host_info, slot_info, and cpu_control with xxx.
 * 	[88/11/28            dlb]
 * 
 * Revision 2.10  89/10/10  22:50:52  mwyoung
 * 	Move memory_object_get_attributes and
 * 	vm_set_default_memory_manager to unused msg IDs within the
 * 	mach subsystem ID range (they had been OUTSIDE the range).
 * 	Msg IDs used belong to the obsolete calls pager_data_lock
 * 	and pager_clean_request (removed as of 21-Jan-88, before the
 * 	external pager interface was even in experimental use).
 * 
 * 	WARNING! There are NO more msg IDs left at the end of this
 * 	subsystem.
 * 	[89/09/06            dbg]
 * 
 * 
 * Revision 2.8  89/05/06  02:57:49  rpd
 * 	Purged <kern/task_statistics.h>, <kern/thread_statistics.h>.
 * 	[89/05/05  20:43:26  rpd]
 * 
 * Revision 2.7  89/05/01  17:02:43  rpd
 * 	Do not define KERNEL_SERVER here; it is passed in now.
 * 	Removed port_set_select.
 * 	[89/05/01  14:52:15  rpd]
 * 
 * Revision 2.6  89/04/18  16:43:24  mwyoung
 * 	Add memory_object_get_attributes, vm_set_default_memory_manager.
 * 	[89/04/07            mwyoung]
 * 
 * Revision 2.5  89/04/08  23:40:22  rpd
 * 	Added IsLong to the variabled-sized inline arguments of
 * 	task_info, thread_info, thread_set_state, thread_get_state.
 * 	[89/04/08  22:53:40  rpd]
 * 	
 *	Moved from kern/ to mach/ at this point.
 * 
 * Revision 2.19  89/01/12  07:56:49  rpd
 * 	Moved ipc_statistics, callout_info, callout_statistics, fpa_counters
 * 	calls out to other interface files.
 * 	[89/01/12  04:47:56  rpd]
 * 
 * Revision 2.18  89/01/10  23:31:31  rpd
 * 	Changed MACH_IPCSTATS to MACH_IPC_STATS.
 * 	Added MACH_IPC_XXXHACK, which enables the xxx_port_* calls.
 * 	[89/01/10  23:08:52  rpd]
 * 
 * Revision 2.17  89/01/04  13:36:35  rpd
 * 	Added host_fpa_counters and host_fpa_counters_reset calls.
 * 	These are conditional on ROMP_FPA_COUNT, which an RT option.
 * 	[89/01/01  15:02:29  rpd]
 * 
 * Revision 2.16  88/10/18  03:21:19  mwyoung
 * 	All the host_info call to be made on any kernel-provided object.
 * 	[88/09/23            mwyoung]
 * 
 * Revision 2.15  88/10/18  00:29:45  mwyoung
 * 	Changed the formal parameters in port_names and port_type
 * 	to be different than the routine names. Lint doesn't like 
 * 	the code that was generated.
 * 	[88/10/17  16:55:57  mrt]
 * 
 * Revision 2.14  88/10/11  10:19:18  rpd
 * 	Added port_set_backup.
 * 	[88/10/11  08:04:46  rpd]
 * 
 * Revision 2.12  88/09/25  22:14:59  rpd
 * 	Added new port_set_select call, the port set equivalent of port_select.
 * 	[88/09/19  16:27:14  rpd]
 * 	
 * 	Changed includes to the new style.
 * 	Added host_ipc_statistics_reset, host_callout_info,
 * 	host_callout_statistics, host_callout_statistics_reset.
 * 	[88/09/09  04:45:02  rpd]
 * 
 * Revision 2.11  88/08/30  17:28:07  mwyoung
 * 	So that transition compatibility code can temporarily use the
 * 	"xxx_" forms of the IPC routines, change the tag on which the
 * 	calls are generated.
 * 	[88/08/30            mwyoung]
 * 
 * Revision 2.10  88/08/25  18:16:23  mwyoung
 * 	Fill in memory_object_destroy call.  Adjust documentation for
 * 	thread_get_state.
 * 	[88/08/11  18:46:11  mwyoung]
 * 
 */
/*
 *	Matchmaker definitions file for Mach kernel interface.
 */
#ifdef	KERNEL
#include <mach_ipc_xxxhack.h>
#include <mach_emulation.h>
#include <mach_device.h>
#include <mach_net.h>
#include <mach_np.h>
#else
#define MACH_IPC_XXXHACK	1
#define MACH_EMULATION		1
#define MACH_DEVICE		0
#define MACH_NET		1
#define MACH_NP			1
#endif	KERNEL

subsystem mach 2000;

#include <:mach:std_types.defs>
#include <:mach:mach_types.defs>

uimport <mach/mach_extra.h>;

simport <kern/mach_redefines.h>;	/* XXX - for routines
					   that haven't been
					   implemented yet */

#if	MACH_IPC_XXXHACK
/*
 *	Allocate a new port (with all rights) in the target task.
 *	The port name in that task is returned.
 */
routine xxx_port_allocate(
		target_task	: task_t;
	out	my_port		: port_t);

/*
 *	Deallocate the port with the given name from the target task.
 */
routine xxx_port_deallocate(
		target_task	: task_t;
		my_port		: port_t);

/*
 *	Add the port in the target task with the given name to
 *	the port set selected by PORT_ENABLED during a msg_receive
 *	operation in that task.
 */
routine xxx_port_enable(
		target_task	: task_t;
		my_port		: port_t);

/*
 *	Remove the port in the target task with the given name from
 *	the port set selected by PORT_ENABLED during a msg_receive
 *	operation in that task.
 */
routine xxx_port_disable(
		target_task	: task_t;
		my_port		: port_t);

/*
 *	Return the list of ports, for which the target task
 *	is the receiver, on which messages are queued.
 */
routine xxx_port_select(
		target_task	: task_t;
	out	port_list	: port_array_t);

/*
 *	Set the number of messages that may be queued to
 *	the port in the target task with the given name
 *	before further message queueing operations block.
 */
routine xxx_port_set_backlog(
		target_task	: task_t;
		my_port		: port_t;
		backlog		: int);

/*
 *	Return information about the port with the given
 *	name in the target task.  Only the ownership and
 *	receive_rights results are meaningful unless the
 *	target task holds receive rights for the port.
 */
routine xxx_port_status(
		target_task	: task_t;
		my_port		: port_t;
	out	enabled		: boolean_t;
	out	num_msgs	: int;
	out	backlog		: int;
	out	ownership	: boolean_t;
	out	receive_rights	: boolean_t);
#else	MACH_IPC_XXXHACK
skip;			/* old port_allocate */
skip;			/* old port_deallocate */
skip;			/* old port_enable */
skip;			/* old port_disable */
skip;			/* old port_select */
skip;			/* old port_set_backlog */
skip;			/* old port_status */
#endif	MACH_IPC_XXXHACK

/*
 *	Create a new task with an empty set of IPC rights,
 *	and having an address space constructed from the
 *	target task (or empty, if inherit_memory is FALSE).
 */
routine task_create(
		target_task	: task_t;
		inherit_memory	: boolean_t;
	out	child_task	: task_t);

/*
 *	Destroy the target task, causing all of its threads
 *	to be destroyed, all of its IPC rights to be deallocated,
 *	and all of its address space to be deallocated.
 */
routine task_terminate(
		target_task	: task_t);

skip;			/* old task suspend */
skip;			/* old task_resume */

/*
 *	Returns the set of threads belonging to the target task.
 */
routine task_threads(
		target_task	: task_t;
	out	thread_list	: thread_array_t);

skip;		/* task_ports: OBSOLETE */
skip;		/* old task_status */
skip;		/* old task_set_notify */
skip;		/* old thread_create */

/*
 *	Destroy the target thread.
 */
routine thread_terminate(
		target_thread	: thread_t);

skip;		/* old thread_suspend */
skip;		/* old thread_resume */
skip;		/* old thread_status */
skip;		/* old thread_mutate */

/*
 *	Allocate zero-filled memory in the address space
 *	of the target task, either at the specified address,
 *	or wherever space can be found (if anywhere is TRUE),
 *	of the specified size.  The address at which the
 *	allocation actually took place is returned.
 */
routine vm_allocate(
		target_task	: vm_task_t;
	inout	address		: vm_address_t;
		size		: vm_size_t;
		anywhere	: boolean_t);

skip;   /* vm_allocate_with_pager - replaced by vm_map */
		
/*
 *	Deallocate the specified range from the virtual
 *	address space of the target task.
 */
routine vm_deallocate(
		target_task	: vm_task_t;
		address		: vm_address_t;
		size		: vm_size_t);

/*
 *	Set the current or maximum protection attribute
 *	for the specified range of the virtual address
 *	space of the target task.  The current protection
 *	limits the memory access rights of threads within
 *	the task; the maximum protection limits the accesses
 *	that may be given in the current protection.
 *	Protections are specified as a set of {read, write, execute}
 *	*permissions*.
 */
routine vm_protect(
		target_task	: vm_task_t;
		address		: vm_address_t;
		size		: vm_size_t;
		set_maximum	: boolean_t;
		new_protection	: vm_prot_t);

/*
 *	Set the inheritance attribute for the specified range
 *	of the virtual address space of the target task.
 *	The inheritance value is one of {none, copy, share}, and
 *	specifies how the child address space should acquire
 *	this memory at the time of a task_create call.
 */
routine vm_inherit(
		target_task	: vm_task_t;
		address		: vm_address_t;
		size		: vm_size_t;
		new_inheritance	: vm_inherit_t);

/*
 *	Returns the contents of the specified range of the
 *	virtual address space of the target task.  [The
 *	range must be aligned on a virtual page boundary,
 *	and must be a multiple of pages in extent.  The
 *	protection on the specified range must permit reading.]
 */
routine vm_read(
		target_task	: vm_task_t;
		address		: vm_address_t;
		size		: vm_size_t;
	out	data		: pointer_t);

/*
 *	Writes the contents of the specified range of the
 *	virtual address space of the target task.  [The
 *	range must be aligned on a virtual page boundary,
 *	and must be a multiple of pages in extent.  The
 *	protection on the specified range must permit writing.]
 */
routine vm_write(
		target_task	: vm_task_t;
		address		: vm_address_t;
		data		: pointer_t);

/*
 *	Copy the contents of the source range the virtual
 *	address space of the target task to the destination
 *	range in that same address space.  [Both of the
 *	ranges must be aligned on a virtual page boundary,
 *	and must be multiples of pages in extent.  The
 *	protection on the source range must permit reading,
 *	and the protection on the destination range must
 *	permit writing.]
 */
routine vm_copy(
		target_task	: vm_task_t;
		source_address	: vm_address_t;
		size		: vm_size_t;
		dest_address	: vm_address_t);

/*
 *	Returns information about the contents of the virtual
 *	address space of the target task at the specified
 *	address.  The returned protection, inheritance, sharing
 *	and memory object values apply to the entire range described
 *	by the address range returned; the memory object offset
 *	corresponds to the beginning of the address range.
 *	[If the specified address is not allocated, the next
 *	highest address range is described.  If no addresses beyond
 *	the one specified are allocated, the call returns KERN_NO_SPACE.]
 */
routine vm_region(
		target_task	: vm_task_t;
	inout	address		: vm_address_t;
	out	size		: vm_size_t;
	out	protection	: vm_prot_t;
	out	max_protection	: vm_prot_t;
	out	inheritance	: vm_inherit_t;
	out	is_shared	: boolean_t;
	out	object_name	: memory_object_name_t;
	out	offset		: vm_offset_t);

/*
 *	Return virtual memory statistics for the host
 *	on which the target task resides.  [Note that the
 *	statistics are not specific to the target task.]
 */
routine vm_statistics(
		target_task	: vm_task_t;
	out	vm_stats	: vm_statistics_data_t);

/* RUBBISH */
routine task_by_unix_pid(
		target_task	: task_t;
		process_id	: int;
	out	result_task	: task_t);

skip;	/* preserve numbering */

/*
 *	Stash a handful of ports for the target task; child
 *	tasks inherit this stash at task_create time.
 */
routine	mach_ports_register(
		target_task	: task_t;
		init_port_set	: port_array_t);
		
/*
 *	Retrieve the stashed ports for the target task.
 */
routine	mach_ports_lookup(
		target_task	: task_t;
	out	init_port_set	: port_array_t);

/* GARBAGE */
routine unix_pid(
		target_task	: task_t;
	out	process_id	: int);

#if	MACH_NET
/*
 *	Redirect network IP messages to the specified Mach port.
 */
routine netipc_listen(
		request_port	: port_t;
		src_addr	: int;
		dst_addr	: int;
		src_port	: int;
		dst_port	: int;
		protocol	: int;
		ipc_port	: port_t);

/*
 *	Stop IP message redirection as set up by netipc_listen.
 */
routine netipc_ignore(
		request_port	: port_t;
		ipc_port	: port_t);
#else	MACH_NET
skip;
skip;
#endif	MACH_NET

/*
 *	Provide the data contents of a range of the given memory
 *	object, with the access restriction specified.  [Only
 *	whole virtual pages of data can be accepted; partial pages
 *	will be discarded.  Data should be provided on request, but
 *	may be provided in advance as desired.  When data already
 *	held by this kernel is provided again, the new data is ignored.
 *	The access restriction is the subset of {read, write, execute}
 *	which are prohibited.  The kernel may not provide any data (or
 *	protection) consistency among pages with different virtual page
 *	alignments within the same object.]
 */
simpleroutine memory_object_data_provided(
		memory_control	: memory_object_control_t;
		offset		: vm_offset_t;
		data		: pointer_t;
		lock_value	: vm_prot_t);

/*
 *	Indicate that a range of the given temporary memory object does
 *	not exist, and that the backing memory object should be used
 *	instead (or zero-fill memory be used, if no backing object exists).
 *	[This call is intended for use only by the default memory manager.
 *	It should not be used to indicate a real error -- memory_object_data_error
 *	should be used for that purpose.]
 */
simpleroutine memory_object_data_unavailable(
		memory_control	: memory_object_control_t;
		offset		: vm_offset_t;
		size		: vm_size_t);

/*
 *	Retrieves the attributes currently associated with
 *	a memory object.
 */
routine memory_object_get_attributes(
		memory_control	: memory_object_control_t;
	out	object_ready	: boolean_t;
	out	may_cache	: boolean_t;
	out	copy_strategy	: memory_object_copy_strategy_t);


/*
 *	Sets the default memory manager, the port to which
 *	newly-created temporary memory objects are delivered.
 *	[See (memory_object_default)memory_object_create.]
 *	The old memory manager port is returned.
 */
routine vm_set_default_memory_manager(
		host		: host_priv_t;
	inout	default_manager	: memory_object_t);

skip;	/* pager_flush_request : OBSOLETE */

/*
 *	Control use of the data associated with the given
 *	memory object.  For each page in the given range,
 *	perform the following operations, in order:
 *		1)  restrict access to the page (disallow
 *		    forms specified by "prot");
 *		2)  write back modifications (if "should_clean"
 *		    is asserted, and the page is dirty); and,
 *		3)  flush the cached copy (if "should_flush"
 *		    is asserted).
 *	The set of pages is defined by a starting offset
 *	("offset") and size ("size").  Only pages with the
 *	same page alignment as the starting offset are
 *	considered.
 *
 *	NOTE: Precious pages are freed by should_flush.  To get them
 *	returned, should_clean AND should_flush are required.
 *
 *	A single acknowledgement is sent (to the "reply_to"
 *	port) when these actions are complete.
 */
simpleroutine memory_object_lock_request(
		memory_control	: memory_object_control_t;
		offset		: vm_offset_t;
		size		: vm_size_t;
		should_clean	: boolean_t;
		should_flush	: boolean_t;
		lock_value	: vm_prot_t;
		reply_to	: port_t);

/*
 *	Specify whether data for the given memory object may be
 *	retained by the kernel even after all address space
 *	mappings of the object have been deallocated.
 *
 * XXX	Obsolete.  Use memory_object_set_attributes instead.
 */
simpleroutine xxx_pager_cache(
		memory_control	: memory_object_control_t;
		should_cache	: boolean_t);

skip;		/* old thread_wait */
skip;		/* old task_wait */

/*
 *	Returns information about the host on which the
 *	target object resides.  [This object may be
 *	a task, thread, or memory_object_control port.]
 */
routine xxx_host_info(
		target_task	: port_t;
	out	info		: machine_info_data_t);
	
/*
 *	Returns information about a particular processor on
 *	the host on which the target task resides.
 */
routine xxx_slot_info(
		target_task	: task_t;
		slot		: int;
	out	info		: machine_slot_data_t);

/*
 *	Performs control operations (currently only
 *	turning off or on) on a particular processor on
 *	the host on which the target task resides.
 */
routine xxx_cpu_control(
		target_task	: task_t;
		cpu		: int;
		running		: boolean_t);

skip;		/* old thread_statistics */
skip;		/* old task_statistics */

#if	MACH_NP
/*
 *	Initialize the direct network IPC system.
 */
routine	netport_init(
		request_port	: port_t);

/*
 *	Enter an association between a network port
 *	and a local Mach port.
 */
routine	netport_enter(
		request_port	: port_t;
		netport		: network_port_t;
		port		: port_t;
		local		: boolean_t);

/*
 *	Remove an association established by netport_enter.
 */
routine	netport_remove(
		request_port	: port_t;
		netport		: network_port_t);
#else	MACH_NP
skip;
skip;
skip;
#endif	MACH_NP

skip;		/* pager_data_provided_inline : OBSOLETE */

/*
 *	Increment the suspend count for the target task.
 *	No threads within a task may run when the suspend
 *	count for that task is non-zero.
 */
routine	task_suspend(
		target_task	: task_t);

/*
 *	Decrement the suspend count for the target task,
 *	if the count is currently non-zero.  If the resulting
 *	suspend	count is zero, then threads within the task
 *	that also have non-zero suspend counts may execute.
 */
routine	task_resume(
		target_task	: task_t);

/*
 *	Returns the current value of the selected special port
 *	associated with the target task.
 */
routine task_get_special_port(
		task		: task_t;
		which_port	: int;
	out	special_port	: port_t);

/*
 *	Set one of the special ports associated with the
 *	target task.
 */
routine task_set_special_port(
		task		: task_t;
		which_port	: int;
		special_port	: port_t);

/*
 *	Returns information about the target task.
 */
routine	task_info(
		target_task	: task_t;
		flavor		: int;
	out	task_info_out	: task_info_t, IsLong);


/*
 *	Create a new thread within the target task, returning
 *	the port representing that new thread.  The
 *	initial execution state of the thread is undefined.
 */
routine thread_create(
		parent_task	: task_t;
	out	child_thread	: thread_t);

/*
 *	Increment the suspend count for the target thread.
 *	Once this call has completed, the thread will not
 *	execute any further user or meta- instructions.
 *	Once suspended, a thread may not execute again until
 *	its suspend count is zero, and the suspend count
 *	for its task is also zero.
 */
routine	thread_suspend(
		target_thread	: thread_t);

/*
 *	Decrement the suspend count for the target thread,
 *	if that count is not already zero.
 */
routine	thread_resume(
		target_thread	: thread_t);

/*
 *	Cause any user or meta- instructions currently being
 *	executed by the target thread to be aborted.  [Meta-
 *	instructions consist of the basic traps for IPC
 *	(e.g., msg_send, msg_receive) and self-identification
 *	(e.g., task_self, thread_self, thread_reply).  Calls
 *	described by MiG interfaces are not meta-instructions
 *	themselves.]
 */
routine thread_abort(
		target_thread	: thread_t);

/*
 *	Return the selected state information for the target
 *	thread.  If the thread is currently executing, the results
 *	may be stale.  [Flavor THREAD_STATE_FLAVOR_LIST provides a
 *	list of valid flavors for the target thread.]
 */
routine thread_get_state(
		target_thread	: thread_t;
		flavor		: int;
	out	old_state	: thread_state_t, IsLong);

/*
 *	Set the selected state information for the target thread.
 *	If the thread is currently executing, the state change
 *	may be ill-defined.
 */
routine	thread_set_state(
		target_thread	: thread_t;
		flavor		: int;
		new_state	: thread_state_t, IsLong);

/*
 *	Returns the current value of the selected special port
 *	associated with the target thread.
 */
routine thread_get_special_port(
		thread		: thread_t;
		which_port	: int;
	out	special_port	: port_t);

/*
 *	Set one of the special ports associated with the
 *	target thread.
 */
routine thread_set_special_port(
		thread		: thread_t;
		which_port	: int;
		special_port	: port_t);

/*
 *	Returns information about the target thread.
 */
routine	thread_info(
		target_thread	: thread_t;
		flavor		: int;
	out	thread_info_out	: thread_info_t, IsLong);

#if	MACH_EMULATION
/*
 *	Establish a user-level handler for the specified
 *	system call.
 */
routine task_set_emulation(
		target_port	: task_t;
		routine_entry_pt: vm_address_t;
		routine_number  : int);	
#else	MACH_EMULATION
skip;
#endif	MACH_EMULATION

#if	MACH_DEVICE
/*
 *	Returns a port that may be used for low level device I/O
 */
routine task_get_io_port(
		task		: task_t;
	out	io_port		: port_t);
#else	MACH_DEVICE
skip;
#endif	MACH_DEVICE

skip;	/* old host_ipc_statistics */

/*
 *	Returns the set of port and port set names
 *	to which the target task has access, along with
 *	the type (set or port) for each name.
 */
routine port_names(
		task		: task_t;
	out	port_names_p	: port_name_array_t;
	out	port_types	: port_type_array_t);

/*
 *	Returns the type (set or port) for the port name
 *	within the target task.
 */
routine port_type(
		task		: task_t;
		port_name	: port_name_t;
	out	port_type_p	: port_type_t);

/*
 *	Changes the name by which a port (or port set) is known to
 *	the target task.
 */
routine port_rename(
		task		: task_t;
		old_name	: port_name_t;
		new_name	: port_name_t);

/*
 *	Allocate a new port (with all rights) in the target task.
 *	The port name in that task is returned.
 */
routine port_allocate(
		task		: task_t;
	out	port_name	: port_name_t);

/*
 *	Deallocate the port with the given name from the target task.
 */
routine port_deallocate(
		task		: task_t;
		port_name	: port_name_t);

/*
 *	Set the number of messages that may be queued to
 *	the port in the target task with the given name
 *	before further message queueing operations block.
 *	The target task must hold receive rights for the
 *	port named.
 */
routine port_set_backlog(
		task		: task_t;
		port_name	: port_name_t;
		backlog		: int);

/*
 *	Return information about the port with the given
 *	name in the target task.  Only the ownership and
 *	receive_rights results are meaningful unless the
 *	target task holds receive rights for the port.
 */
routine port_status(
		task		: task_t;
		port_name	: port_name_t;
	out	enabled		: port_set_name_t;
	out	num_msgs	: int;
	out	backlog		: int;
	out	ownership	: boolean_t;
	out	receive_rights	: boolean_t);

/*
 *	Allocate a new port set in the target task, returning
 *	the name of that new port set.  [The new set is
 *	initially empty.]
 */
routine port_set_allocate(
		task		: task_t;
	out	set_name	: port_set_name_t);

/*
 *	Deallocate the named port set from the target task.
 *	Ports that are currently members of the named port
 *	set are first removed from the set.
 */
routine port_set_deallocate(
		task		: task_t;
		set_name	: port_set_name_t);

/*
 *	Add the named port to the port set named within
 *	the target task.  [If the port currently is a member
 *	of another port set, it is removed from that set.]
 */
routine port_set_add(
		task		: task_t;
		set_name	: port_set_name_t;
		port_name	: port_name_t);

/*
 *	Remove the named port from the port set named within
 *	the target task.
 */
routine port_set_remove(
		task		: task_t;
		port_name	: port_name_t);

/*
 *	Returns the current set of ports that are members
 *	of the named port set in the target task.
 */
routine port_set_status(
		task		: task_t;
		set_name	: port_set_name_t;
	out	members		: port_name_array_t);

/*
 *	Insert send rights for the specified port into
 *	the target task with the specified port name.
 *	[If the name is in use, or the target task already
 *	has another name for the specified port, then
 *	the operation will fail.]
 */
routine port_insert_send(
		task		: task_t;
		my_port		: port_t;
		his_name	: port_name_t);

/*
 *	Returns send rights for the named port in the
 *	target task, removing that port name and port
 *	send rights from the target task.  [If the
 *	target task holds receive rights for this port,
 *	the operation will fail.]
 */
routine port_extract_send(
		task		: task_t;
		his_name	: port_name_t;
	out	his_port	: port_t);

/*
 *	Insert receive rights for the specified port into
 *	the target task with the specified port name.
 *	[If the name is in use, or the target task already
 *	has another name for the specified port, then
 *	the operation will fail.
 */
routine port_insert_receive(
		task		: task_t;
		my_port		: port_t = MSG_TYPE_PORT_ALL;
		his_name	: port_name_t);

/*
 *	Returns receive rights for the named port in the
 *	target task, removing that port name and all port
 *	rights from the target task.
 */
routine port_extract_receive(
		task		: task_t;
		his_name	: port_name_t;
	out	his_port	: port_t = MSG_TYPE_PORT_ALL);

/*
 *	Map a user-defined memory object into the virtual address
 *	space of the target task.  If desired (anywhere is TRUE),
 *	the kernel will find a suitable address range of the
 *	specified size; else, the specific address will be allocated.
 *
 *	The beginning address of the range will be aligned on a virtual
 *	page boundary, be at or beyond the address specified, and
 *	meet the mask requirements (bits turned on in the mask must not
 *	be turned on in the result); the size of the range, in bytes,
 *	will be rounded	up to an integral number of virtual pages.
 *
 *	The memory in the resulting range will be associated with the
 *	specified memory object, with the beginning of the memory range
 *	referring to the specified offset into the memory object.
 *
 *	The mapping will take the current and maximum protections and
 *	the inheritance attributes specified; see the vm_protect and
 *	vm_inherit calls for a description of these attributes.
 *
 *	If desired (copy is TRUE), the memory range will be filled
 *	with a copy of the data from the memory object; this copy will
 *	be private to this mapping in this target task.  Otherwise,
 *	the memory in this mapping will be shared with other mappings
 *	of the same memory object at the same offset (in this task or
 *	in other tasks).  [The Mach kernel only enforces shared memory
 *	consistency among mappings on one host with similar page alignments.
 *	The user-defined memory manager for this object is responsible
 *	for further consistency.]
 */
routine vm_map(
		target_task	: vm_task_t;
	inout	address		: vm_address_t;
		size		: vm_size_t;
		mask		: vm_address_t;
		anywhere	: boolean_t;
		memory_object	: memory_object_t;
		offset		: vm_offset_t;
		copy		: boolean_t;
		cur_protection	: vm_prot_t;
		max_protection	: vm_prot_t;
		inheritance	: vm_inherit_t);

/*
 *	Indicate that a range of the specified memory object cannot
 *	be provided at this time.  [Threads waiting for memory pages
 *	specified by this call will experience a memory exception.
 *	Only threads waiting at the time of the call are affected.]
 */
simpleroutine memory_object_data_error(
		memory_control	: memory_object_control_t;
		offset		: vm_offset_t;
		size		: vm_size_t;
		error_value	: kern_return_t);

/*
 *	Make decisions regarding the use of the specified
 *	memory object.
 */
simpleroutine memory_object_set_attributes(
		memory_control	: memory_object_control_t;
		object_ready	: boolean_t;
		may_cache	: boolean_t;
		copy_strategy	: memory_object_copy_strategy_t);

/*
 */
simpleroutine memory_object_destroy(
		memory_control	: memory_object_control_t;
		reason		: kern_return_t);

/*
 *	Provide the data contents of a range of the given memory
 *	object, with the access restriction specified, optional
 *	precious attribute, and reply message.  [Only
 *	whole virtual pages of data can be accepted; partial pages
 *	will be discarded.  Data should be provided on request, but
 *	may be provided in advance as desired.  When data already
 *	held by this kernel is provided again, the new data is ignored.
 *	The access restriction is the subset of {read, write, execute}
 *	which are prohibited.  The kernel may not provide any data (or
 *	protection) consistency among pages with different virtual page
 *	alignments within the same object.  The precious value controls
 *	how the kernel treats the data.  If it is FALSE, the kernel treats
 *	its copy as a temporary and may throw it away if it hasn't been
 *	changed.  If the precious value is TRUE, the kernel treats its
 *	copy as a data repository and promises to return it to the manager;
 *	the manager may tell the kernel to throw it away instead by flushing
 *	and not cleaning the data -- see memory_object_lock_request.  The
 *	reply_to port is for a compeletion message; it will be
 *	memory_object_supply_completed.]
 */

/*
 * XXX	This will eventually use the dealloc_data argument to decide
 * XXX	whether to deallocate the data.  Until MiG supports this,
 * XXX	data is always deallocated, and dealloc_data should
 * XXX	always be TRUE.
 */

simpleroutine memory_object_data_supply(
		memory_control	: memory_object_control_t;
		offset		: vm_offset_t;
		data		: pointer_t, Dealloc;
		dealloc_data	: boolean_t;
		lock_value	: vm_prot_t;
		precious	: boolean_t;
		reply_to	: port_t);

skip;	/* old host_callout_info */
skip;	/* old host_callout_statistics */
skip;	/* old host_callout_statistics_reset */
skip;	/* old port_set_select */

/*
 *	Sets a backup port for the named port.  The task
 *	must have receive rights for the named port.
 *	Returns the previous backup port, if any.
 */
routine port_set_backup(
		task		: task_t;
		port_name	: port_name_t;
		backup		: port_t;
	out	previous	: port_t);

/*
 *	Set/Get special properties of memory associated
 *	to some virtual address range, such as cachability, 
 *	migrability, replicability.  Machine-dependent.
 */
routine vm_machine_attribute(
		target_task	: vm_task_t;
		address		: vm_address_t;
		size		: vm_size_t;
		attribute	: vm_machine_attribute_t;
	inout	value		: vm_machine_attribute_val_t);

skip;	/* old host_fpa_counters_reset */

@EOF@

echo "include/mach/mach_extra.h"
cat >include/mach/mach_extra.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_extra.h,v $
 * Revision 2.6  89/03/09  20:20:38  rpd
 * 	More cleanup.
 * 
 * Revision 2.5  89/02/25  18:13:51  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.4  89/02/19  12:57:33  rpd
 * 	Moved from kern/ to mach/.
 * 
 * Revision 2.3  89/02/07  01:02:51  mwyoung
 * Relocated from sys/mach_extra.h
 * 
 * Revision 2.2  88/07/20  16:50:42  rpd
 * Removed port_messages definition, because port_select is going away.
 * It spelled port_select wrong, so it's a safe change....
 * Also added copyright.
 * 
 * 11-Mar-87  Mary Thompson at Carnegie Mellon
 *	added definition for PORT_DEFAULT
 *
 *  8-Jan-87  Mary Thompson at Carnegie Mellon
 *	started
 *
 */
/*
 *
 *  This file defines new names for some of the Mach user interface primitives.
 *  It is imported by the user side of mach (mach.h and mach_user.c)
 *  and exported by mach.h to the user.
 *
 */

#ifndef	_MACH_MACH_EXTRA_H_
#define _MACH_MACH_EXTRA_H_

#define port_restrict	port_disable
#define port_unrestrict port_enable
#define PORT_DEFAULT	PORT_ENABLED

#endif	_MACH_MACH_EXTRA_H_
@EOF@

echo "include/mach/mach_host.defs"
cat >include/mach/mach_host.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_host.defs,v $
 * Revision 2.5  90/07/20  08:48:47  mrt
 * 	Delete thread_depress_abort.  Subsumed by thread_abort.
 * 	[90/07/16            dlb]
 * 	Convert host_processor_sets to non-privileged form: return name
 * 	ports given host port instead of returning control ports given
 * 	privileged host port.
 * 	[90/07/13            dlb]
 * 
 * Revision 2.4  89/12/22  15:54:26  rpd
 * 	Under KERNEL_SERVER, pass the out arguments of
 * 	processor_set_create as port_t's.  They really are
 * 	the appropriate processor set types, but processor_set_create
 * 	does the type conversions internally.  This isn't pretty.
 * 	[89/12/15            dlb]
 * 
 * Revision 2.3  89/10/15  02:05:40  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.2  89/10/11  14:38:34  dlb
 * 	Add IsLong specifiers to variable length arguments to info calls.
 * 	Add thread_depress_abort.
 * 	Add processor_set_{tasks,threads}, host_processor_sets,
 * 	       host_processor_set_priv.
 * 	Add priority and policy calls.
 * 	Split processor_set_default.  Add task_assign_default and
 * 	       thread_assign_default.
 * 	Add host_kernel_version.
 * 
 * Revision 2.1.1.3  89/08/02  23:58:37  dlb
 * 	Remove KERNEL_SERVER define.  Cleanup.
 * 	[89/08/02            dlb]
 * 
 * Revision 2.1.1.2  89/08/02  23:10:06  dlb
 * 	Add IsLong specifiers to variable length arguments to info calls.
 * 	[89/08/02            dlb]
 * 
 * Revision 2.1.1.1  89/07/25  17:05:31  dlb
 * 	Add thread_depress_abort.
 * 	[89/06/20            dlb]
 * 
 * 	Add processor_set_{tasks,threads}, host_processor_sets,
 * 	host_processor_set_priv.
 * 	[89/06/08            dlb]
 * 
 * 	Add priority and policy calls.
 * 	[89/05/12            dlb]
 * 
 * 	Move type definitions to mach_types.defs, delete kernel keyword.
 * 	[89/01/25            dlb]
 * 
 * 	Moved to mach/ from kern/
 * 	[89/01/25            dlb]
 * 
 * 	Split processor_set_default.  Add task_assign_default and
 * 	thread_assign_default.
 * 	[88/12/21            dlb]
 * 
 * 	Minor cleanups, add host_kernel_version.
 * 	[88/12/02            dlb]
 * 
 * Revision 2.1  89/01/30  16:17:06  dlb
 * Created.
 * 
 */

/*
 * File:	mach/mach_host.defs
 *
 * Abstract:
 *	Mach host operations support.  Includes processor allocation and
 *	control.  
 */

subsystem mach_host 2600;

/*
 *	Basic types
 */

#include <:mach:std_types.defs>
#include <:mach:mach_types.defs>

/*
 *	Get list of processors on this host.
 */

routine host_processors(
		host_priv	: host_priv_t;
	out	processor_list	: processor_array_t);

/*
 *	Return information about this host.
 */

routine host_info(
		host		: host_t;
		flavor		: int;
	out	host_info_out	: host_info_t, IsLong);


/*
 *	Return information about this processor.
 */
routine processor_info(
		processor	: processor_t;
		flavor		: int;
	out	host		: host_t;
	out	processor_info_out: processor_info_t, IsLong);

/*
 *	Start processor.
 */

routine	processor_start(
		processor	: processor_t);

/*
 *	Exit processor -- may not be restartable.
 */

routine	processor_exit(
		processor	: processor_t);

/*
 *	Do something machine-dependent to processor.
 */
routine processor_control(
		processor	: processor_t;
		processor_cmd	: processor_info_t, IsLong);

/*
 *	Get default processor set for host.
 */
routine processor_set_default(
		host		: host_t;
	out	default_set	: processor_set_name_t);

/*
 *	Get rights to default processor set for host.
 *	Replaced by host_processor_set_priv.
 */
routine xxx_processor_set_default_priv(
		host		: host_priv_t;
	out	default_set	: processor_set_t);

/*
 *	Create new processor set.  Returns real port for manipulations,
 *	and name port for obtaining information.
 */
routine processor_set_create(
		host		: host_t;
#if	KERNEL_SERVER
	out	new_set		: port_t;
	out	new_name	: port_t);
#else	KERNEL_SERVER
	out	new_set		: processor_set_t;
	out	new_name	: processor_set_name_t);
#endif	KERNEL_SERVER

/*
 *	Destroy processor set.
 */
routine processor_set_destroy(
		set		: processor_set_t);

/*
 *	Get information about processor set.
 */
routine processor_set_info(
		set_name	: processor_set_name_t;
		flavor		: int;
	out	host		: host_t;
	out	info_out	: processor_set_info_t, IsLong);

/*
 *	Assign processor to processor set.
 */
routine processor_assign(
		processor	: processor_t;
		new_set		: processor_set_t;
		wait		: boolean_t);

/*
 *	Get current assignment for processor.
 */

routine processor_get_assignment(
		processor	: processor_t;
	out	assigned_set	: processor_set_name_t);

/*
 *	Assign thread to processor set.
 */
routine	thread_assign(
		thread		: thread_t;
		new_set		: processor_set_t);

/*
 *	Assign thread to default set.
 */
routine thread_assign_default(
		thread		: thread_t);

/*
 *	Get current assignment for thread.
 */
routine thread_get_assignment(
		thread		: thread_t;
	out	assigned_set	: processor_set_name_t);

/*
 *	Assign task to processor set.
 */
routine task_assign(
		task		: task_t;
		new_set		: processor_set_t;
		assign_threads	: boolean_t);
/*
 *	Assign task to default set.
 */
routine task_assign_default(
		task		: task_t;
		assign_threads	: boolean_t);

/*
 *	Get current assignment for task.
 */
routine task_get_assignment(
		task		: task_t;
	out	assigned_set	: processor_set_name_t);

/*
 *	Get string describing current kernel version.
 */
routine	host_kernel_version(
		host		: host_t;
	out	kernel_version	: kernel_version_t);

/*
 *	Set priority for thread.
 */
routine thread_priority(
		thread		: thread_t;
		priority	: int;
		set_max		: boolean_t);

/*
 *	Set max priority for thread.
 */
routine thread_max_priority(
		thread		: thread_t;
		processor_set	: processor_set_t;
		max_priority	: int);

/*
 *	Set task priority.
 */
routine task_priority(
		task		: task_t;
		priority	: int;
		change_threads	: boolean_t);

/*
 *	Set max priority for processor_set.
 */
routine processor_set_max_priority(
		processor_set	: processor_set_t;
		max_priority	: int;
		change_threads	: boolean_t);

/*
 *	Set policy for thread
 */
routine thread_policy(
		thread		: thread_t;
		policy		: int;
		data		: int);

/*
 *	Enable policy for processor set
 */
routine processor_set_policy_enable(
		processor_set	: processor_set_t;
		policy		: int);

/*
 *	Disable policy for processor set
 */
routine processor_set_policy_disable(
		processor_set	: processor_set_t;
		policy		: int;
		change_threads	: boolean_t);
/*
 *	List all tasks in processor set.
 */
routine processor_set_tasks(
		processor_set	: processor_set_t;
	out	task_list	: task_array_t);

/*
 *	List all threads in processor set.
 */
routine processor_set_threads(
		processor_set	: processor_set_t;
	out	thread_list	: thread_array_t);

/*
 *	List all processor sets on host.
 */
routine host_processor_sets(
		host		: host_t;
	out	processor_sets	: processor_set_name_array_t);

/*
 *	Get control port for a processor set.
 */
routine host_processor_set_priv(
		host_priv	: host_priv_t;
		set_name	: processor_set_name_t;
	out	set		: processor_set_t);
@EOF@

echo "include/mach/mach_param.h"
cat >include/mach/mach_param.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_param.h,v $
 * Revision 2.10  89/03/10  01:58:13  rpd
 * 	Moved TASK_MAX, PORT_MAX, etc. to kern/mach_param.h.
 * 
 * Revision 2.9  89/03/10  01:30:05  rpd
 * 	More cleanup.
 * 
 * Revision 2.8  89/03/07  23:42:17  rpd
 * 	Moved KERNEL dependent constants to kern/mach_param.h.
 * 	Doubled TASK_MAX and THREAD_MAX, and adjusted
 * 	PORT_MAX and SET_MAX so that they are doubled too.
 * 
 * Revision 2.7  89/03/07  03:49:47  rpd
 * 	Moved to mach/.
 * 
 * Revision 2.6  89/02/25  18:06:05  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.5  89/02/07  01:03:02  mwyoung
 * Relocated from sys/mach_param.h
 * 
 * Revision 2.4  88/12/21  14:17:22  mja
 * 	Increased the number of PORT_MAX
 * 	[88/12/20  15:25:11  mrt]
 * 
 * Revision 2.3  88/08/24  02:33:34  mwyoung
 * 	Adjusted include file references.
 * 	[88/08/17  02:16:09  mwyoung]
 * 
 * Revision 2.2  88/07/20  21:04:16  rpd
 *	Added definition of SET_MAX, the maximum number of sets allowed.
 * 
 * 19-Aug-87  Daniel Julin (dpj) at Carnegie-Mellon University
 *	Made small kernel messages bigger under MACH_NP, because a lot
 *	of space is used by the netmsg header anyway.
 *
 * 14-Aug-87  Rick Rashid (rfr) at Carnegie-Mellon University
 *	Reduced TASK_CHUNK and THREAD_CHUNK.
 *
 *  3-Mar-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added KERN_MSG_SMALL_SIZE.
 *
 *  1-Jan-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Calculate PORT_MAX as dependent upon TASK_MAX and THREAD_MAX.
 *
 * 21-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added PORT_BACKLOG_MAX.
 *
 * 21-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Changed number of registered ports, to make the task structure
 *	power-of-two sized.  Don't ask.
 *
 * 31-Aug-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added TASK_PORT_REGISTER_MAX.
 *
 * 10-Aug-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added port parameters.
 *
 *  8-Aug-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added number of ports definition.
 *
 * 24-Jul-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Increase TASK parameters.
 *
 * 29-Jan-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created
 *
 */
/*
 *	File:	mach/mach_param.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Copyright (C) 1986, Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Mach system sizing parameters
 *
 */

#ifndef	_MACH_MACH_PARAM_H_
#define _MACH_MACH_PARAM_H_

#define PORT_BACKLOG_DEFAULT	5
#define PORT_BACKLOG_MAX	16

#define TASK_PORT_REGISTER_MAX	4	/* Number of "registered" ports */

#endif	_MACH_MACH_PARAM_H_
@EOF@

echo "include/mach/mach_traps.h"
cat >include/mach/mach_traps.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_traps.h,v $
 * Revision 2.6  89/10/11  14:38:46  dlb
 * 	Add host traps.
 * 	[89/01/25            dlb]
 * 
 * Revision 2.5  89/03/09  20:20:46  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:37:15  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/19  12:57:44  rpd
 * 	Moved from kern/ to mach/.
 * 
 * Revision 2.2  89/01/15  16:24:46  rpd
 * 	Updated includes for the new mach/ directory.
 * 	[89/01/15  15:03:03  rpd]
 * 
 * 18-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Add thread_reply.  Leave in task_data as an alternate name -
 *	they are functionally indistinguishable.
 *
 * 15-Oct-86  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Include ../kern/mach_types.h instead of <kern/mach_types.h> when
 *	building for the kernel.
 *
 *  1-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created, mostly to help build the lint library.
 *	Should eventually include this in "syscall_sw.c".
 *
 */
/*
 *	Definitions of general Mach system traps.
 *
 *	IPC traps are defined in <mach/message.h>.
 *	Kernel RPC functions are defined in <kern/mach.h>.
 */

#ifndef	_MACH_MACH_TRAPS_H_
#define _MACH_MACH_TRAPS_H_

#define _MACH_INIT_	1

#include <:mach:mach_types.h>

#ifdef	KERNEL
port_t		task_self
#else	KERNEL
task_t		task_self
#endif	KERNEL
#ifdef	LINTLIBRARY
			()
	 { return(PORT_NULL); }
#else	LINTLIBRARY
			();
#endif	LINTLIBRARY

port_t		task_data
#ifdef	LINTLIBRARY
			()
	 { return(PORT_NULL); }
#else	LINTLIBRARY
			();
#endif	LINTLIBRARY

port_t		task_notify
#ifdef	LINTLIBRARY
			()
	 { return(PORT_NULL); }
#else	LINTLIBRARY
			();

#endif	LINTLIBRARY

#ifdef	KERNEL
port_t		thread_self
#else	KERNEL
thread_t	thread_self
#endif	KERNEL
#ifdef	LINTLIBRARY
			()
	 { return(PORT_NULL); }
#else	LINTLIBRARY
			();
#endif	LINTLIBRARY

port_t		thread_reply
#ifdef	LINTLIBRARY
			()
	 { return(PORT_NULL); }
#else	LINTLIBRARY
			();
#endif	LINTLIBRARY

#ifdef	KERNEL
port_t		host_self
#else	KERNEL
host_t		host_self
#endif	KERNEL
#ifdef	LINTLIBRARY
			()
	 { return(PORT_NULL); }
#else	LINTLIBRARY
			();
#endif	LINTLIBRARY

#ifdef	KERNEL
port_t		host_priv_self
#else	KERNEL
host_priv_t	host_priv_self
#endif	KERNEL
#ifdef	LINTLIBRARY
			()
	 { return(PORT_NULL); }
#else	LINTLIBRARY
			();
#endif	LINTLIBRARY

#endif	_MACH_MACH_TRAPS_H_
@EOF@

echo "include/mach/mach_types.defs"
cat >include/mach/mach_types.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_types.defs,v $
 * Revision 2.11  90/07/20  08:48:54  mrt
 * 	Add processor_set_name_array_t to replace processor_set_array_t.
 * 	[90/07/13            dlb]
 * 	Add monitor types.
 * 	[90/06/29            dlb]
 * 
 * Revision 2.10  90/03/08  23:10:59  af
 * 		Added vm_attribute's types.
 * 	[90/01/14            af]
 * 
 * Revision 2.9  89/10/11  14:39:01  dlb
 * 	Add a few more array type definitions.
 * 	[89/06/08            dlb]
 * 
 * 	Add host and processor type definitions.
 * 	[89/01/25            dlb]
 * 
 * Revision 2.8  89/10/10  10:55:42  mwyoung
 * 	Use vm_object_lookup directly as the in-translation for
 * 	the memory_object type.  At some point, the memory_object
 * 	interface should use destructors.
 * 	[89/10/04            mwyoung]
 * 
 * Revision 2.7  89/07/14  15:26:33  rvb
 * 	Fixed long-standing erroneous size for machine_slot_data_t.
 * 	Only a new mig and a picky guy (me) would notice.
 * 	[89/07/12            af]
 * 
 * Revision 2.6  89/05/21  23:12:10  mrt
 * 	Added a simport of kern/type_conversion.h  under a KERNEL_SERVER
 * 	conditional.
 * 	[89/05/21            mrt]
 * 
 * Revision 2.5  89/04/08  23:40:32  rpd
 * 	Use new-fangled syntax for translation/destructor functions.
 * 	Define internal_memory_pointer_t.
 * 	[89/04/08  22:55:37  rpd]
 * 
 * Revision 2.4  89/03/09  20:20:52  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:37:59  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:30:33  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:36:47  rpd]
 * 
 * Revision 2.6  89/01/12  07:57:37  rpd
 * 	Moved standard stuff to std_types.defs.  Moved debugging definitions
 * 	like ipc_statistics_t out to other files.
 * 	[89/01/12  04:50:24  rpd]
 * 
 * Revision 2.5  89/01/04  13:37:11  rpd
 * 	Increased size of fpa_counters_t.
 * 	[89/01/03  16:46:38  rpd]
 * 	
 * 	Added fpa_counters_t type.
 * 	[89/01/01  15:03:09  rpd]
 * 
 * Revision 2.4  88/09/25  22:15:16  rpd
 * 	Bumped size of callout_statistics_t to account for the
 * 	new field, cos_num_untimeout_hit.
 * 	[88/09/09  23:14:38  rpd]
 * 	
 * 	Fixed log.  Changed includes to the new style.
 * 	Added definitions of callout_info_t,
 * 	callout_info_array_t, callout_statistics_t.
 * 	[88/09/09  04:46:31  rpd]
 * 
 */
/*
 *	Mach kernel interface type declarations
 */

#ifndef	_MACH_MACH_TYPES_DEFS_
#define _MACH_MACH_TYPES_DEFS_

#include <:mach:std_types.defs>

#if	KERNEL_SERVER
simport <kern/type_conversion.h>;
#endif	KERNEL_SERVER

type task_t = port_t
#if	KERNEL_SERVER
		intran: task_t convert_port_to_task(port_t)
		outtran: port_t convert_task_to_port(task_t)
		destructor: task_deallocate(task_t)
#endif	KERNEL_SERVER
		;


type thread_t = port_t
#if	KERNEL_SERVER
		intran: thread_t convert_port_to_thread(port_t)
		outtran: port_t convert_thread_to_port(thread_t)
		destructor: thread_deallocate(thread_t)
#endif	KERNEL_SERVER
		;

type thread_state_t		= array[*:1024] of int;

/*
 * Mig doesn't handle translations of the components of an array,
 * so use port_t instead of thread_t.
 */
type task_array_t = ^array[] of port_t;
type thread_array_t = ^array[] of port_t;

type vm_task_t = port_t
#if	KERNEL_SERVER
		intran: vm_map_t convert_port_to_map(port_t)
		destructor: vm_map_deallocate(vm_map_t)
#endif	KERNEL_SERVER
		;

type vm_address_t = int;
type vm_offset_t = int;
type vm_size_t = int;
type vm_prot_t = int;
type vm_inherit_t = int;
type vm_statistics_data_t = struct[13] of int;
type vm_machine_attribute_t = int;
type vm_machine_attribute_val_t = int;

type thread_info_t		= array[*:1024] of int;
type task_info_t		= array[*:1024] of int;

type memory_object_t = port_t;
type memory_object_control_t = port_t
#if	KERNEL_SERVER
		intran: vm_object_t vm_object_lookup(port_t)
		outtran: port_t NEVER_HAPPENS(vm_object_t)
#endif	KERNEL_SERVER
		;
type memory_object_name_t = port_t;

type memory_object_copy_strategy_t = int;

type internal_memory_pointer_t =
	^array [] of MSG_TYPE_INTERNAL_MEMORY|MSG_TYPE_BYTE
	ctype: pointer_t;

type machine_info_data_t = struct[5] of int;
type machine_slot_data_t = struct[8] of int;

type vm_page_data_t = array[4096] of MSG_TYPE_BYTE;

type network_port_t = struct[6] of int;


type host_t = port_t
#if	KERNEL_SERVER
		intran: host_t convert_port_to_host(port_t)
		outtran: port_t convert_host_to_port(host_t)
#endif	KERNEL_SERVER
		;
type host_priv_t = port_t
#if	KERNEL_SERVER
		intran: host_t convert_port_to_host_priv(port_t)
#endif	KERNEL_SERVER
		;
type host_info_t 			= array[*:1024] of int;

type processor_t = port_t
#if	KERNEL_SERVER
		intran: processor_t convert_port_to_processor(port_t)
		outtran: port_t convert_processor_to_port(processor_t)
#endif	KERNEL_SERVER
		;
type processor_array_t 		= ^array[] of port_t;
type processor_info_t		= array[*:1024] of int;

type processor_set_t = port_t
#if	KERNEL_SERVER
		intran: processor_set_t convert_port_to_pset(port_t)
		outtran: port_t convert_pset_to_port(processor_set_t)
		destructor: pset_deallocate(processor_set_t)
#endif	KERNEL_SERVER
		;

type processor_set_name_t = port_t
#if	KERNEL_SERVER
		intran: processor_set_t convert_port_to_pset_name(port_t)
		outtran: port_t convert_pset_name_to_port(processor_set_t)
		destructor: pset_deallocate(processor_set_t)
#endif	KERNEL_SERVER
		;

type processor_set_name_array_t = ^array[] of port_t;

type processor_set_info_t	= array[*:1024] of int;	

type kernel_version_t		= (MSG_TYPE_STRING, 512*8);

type monitor_t = port_t
#if	KERNEL_SERVER
		intran: monitor_t convert_port_to_monitor(port_t)
		outtran: port_t convert_monitor_to_port(monitor_t)
		destructor: monitor_deallocate(monitor_t)
#endif	KERNEL_SERVER
		;

type kern_mon_data_t		= struct[6] of int;
type kern_mon_buffer_t		= array[*:320] of kern_mon_data_t;

import <mach/mach_types.h>;

#endif	_MACH_MACH_TYPES_DEFS_
@EOF@

echo "include/mach/mach_types.h"
cat >include/mach/mach_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_types.h,v $
 * Revision 2.11  90/08/30  11:48:07  bohman
 * 	Added KERNEL definitions for vm_task_t and host_priv_t
 * 	which are used by function prototypes in mach_interface.h.
 * 	[90/08/28            bohman]
 * 
 * Revision 2.10  90/07/20  08:49:00  mrt
 * 	processor_set_array_t --> processor_set_name_array_t.
 * 	[90/07/13            dlb]
 * 
 * Revision 2.9  90/03/08  23:11:02  af
 * 	Added vm_attributes.h
 * 	[90/01/14            af]
 * 
 * Revision 2.8  89/10/11  14:39:45  dlb
 * 	Kernel monitor support.
 * 	Host, processor, and processor set support.
 * 
 * Revision 2.7  89/05/21  22:45:54  mrt
 * 	Moved the in-kernel conversion functions to 
 * 	kern/type_conversion.h and removed the non-kernel
 * 	include of mach_init.h. It is now included in the user
 * 	level mach.h
 * 	[89/05/20            mrt]
 * 
 * 
 * Revision 2.6  89/05/06  02:58:04  rpd
 * 	Include <mach/std_types.h> for backwards compatibility.
 * 	[89/05/05  21:00:43  rpd]
 * 
 * Revision 2.5  89/04/08  23:40:37  rpd
 * 	Removed the memory_object/msg_send_from_kernel hack.
 * 	[89/04/08  22:56:08  rpd]
 * 
 * Revision 2.4  89/03/09  20:20:59  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:38:04  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:30:50  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:35:53  rpd]
 * 
 * Revision 2.10  89/01/12  11:15:18  rpd
 * 	Removed pointer_t declaration; it belongs in std_types.h.
 * 
 * Revision 2.9  89/01/12  07:57:53  rpd
 * 	Moved basic stuff to std_types.h.  Removed debugging definitions.
 * 	Moved io_buf definitions to device_types.h.
 * 	[89/01/12  04:51:54  rpd]
 * 
 * Revision 2.8  89/01/04  13:37:34  rpd
 * 	Include <kern/fpa_counters.h>, for fpa_counters_t.
 * 	[89/01/01  15:03:52  rpd]
 * 
 * Revision 2.7  88/09/25  22:15:28  rpd
 * 	Changed sys/callout.h to kern/callout_statistics.h.
 * 	[88/09/09  14:00:19  rpd]
 * 	
 * 	Changed includes to the new style.
 * 	Added include of sys/callout.h.
 * 	[88/09/09  04:47:42  rpd]
 * 
 * Revision 2.6  88/08/06  18:22:34  rpd
 * Changed sys/mach_ipc_netport.h to kern/ipc_netport.h.
 * 
 * Revision 2.5  88/07/21  00:36:06  rpd
 * Added include of ipc_statistics.h.
 * 
 * Revision 2.4  88/07/17  19:33:20  mwyoung
 * *** empty log message ***
 * 
 * 29-Jun-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Use new <mach/memory_object.h>.
 *
 *  9-Apr-88  Daniel Julin (dpj) at Carnegie-Mellon University
 *	Changed mach_ipc_vmtp.h to mach_ipc_netport.h.
 *
 *  1-Mar-88  Mary Thompson (mrt) at Carnegie Mellon
 *	Added a conditional on _MACH_INIT_ before the include
 *	of mach_init.h so that the kernel make of mach_user_internal
 *	would not include mach_init.h
 *
 * 18-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Added includes of task_info, thread_info, task_special_ports,
 *	thread_special_ports for new interfaces.
 *
 * 12-Dec-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Reduced old history.
 */
/*
 *	File:	mach/mach_types.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Copyright (C) 1986, Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Mach external interface definitions.
 *
 */

#ifndef	_MACH_MACH_TYPES_H_
#define _MACH_MACH_TYPES_H_

#include <:mach:port.h>
#include <:mach:vm_inherit.h>
#include <:mach:vm_prot.h>
#include <:mach:memory_object.h>
#include <:mach:vm_statistics.h>
#include <:mach:vm_attributes.h>
#include <:mach:machine:vm_types.h>
#include <:mach:machine.h>
#include <:mach:thread_status.h>
#include <:mach:thread_info.h>
#include <:mach:thread_special_ports.h>
#include <:mach:task_info.h>
#include <:mach:task_special_ports.h>
#include <:mach:netport.h>

#include <:mach:host_info.h>
#include <:mach:processor_info.h>

#ifdef	KERNEL
#include <:kern:kern_mon.h>
#include <:kern:task.h>
#include <:kern:thread.h>
typedef vm_map_t	vm_task_t;

#include <:vm:vm_user.h>
#include <:vm:vm_object.h>

#include <:kern:host.h>
typedef	host_t		host_priv_t;
#include <:kern:processor.h>
#else	KERNEL
typedef	port_t		task_t;
typedef	task_t		vm_task_t;
typedef port_t		*task_array_t;
typedef	port_t		thread_t;
typedef port_t		monitor_t;
typedef	thread_t	*thread_array_t;

typedef port_t		host_t;
typedef port_t		host_priv_t;
typedef port_t		processor_t;
typedef port_t		*processor_array_t;
typedef port_t		processor_set_t;
typedef port_t		processor_set_name_t;
typedef port_t		*processor_set_name_array_t;
#endif	KERNEL

/*
 *	Backwards compatibility, for those programs written
 *	before mach/{std,mach}_types.{defs,h} were set up.
 */
#include <:mach:std_types.h>


typedef	vm_offset_t	vm_address_t;
typedef	unsigned int	vm_region_t;
typedef	vm_region_t	*vm_region_array_t;

typedef	char		vm_page_data_t[4096];


#endif	_MACH_MACH_TYPES_H_
@EOF@

echo "include/mach/machine.h"
cat >include/mach/machine.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	machine.h,v $
 * Revision 2.17  90/08/08  17:18:19  mrt
 * 	Added subtypes for SUN4C_{60,65} and mips' R3000
 * 	[90/08/02            mrt]
 * 
 * Revision 2.16  90/07/06  12:58:49  mrt
 * 	Added changes for Sun 4/330.
 * 	[90/05/07            jjc]
 * 
 * Revision 2.15  89/10/11  14:39:56  dlb
 * 	Removed should_exit - replaced by action thread.
 * 	[89/01/25            dlb]
 * 
 * Revision 2.14  89/07/14  17:21:39  rvb
 * 	Added CPU types and subtypes for MC68030, MC68040, MC88000,
 * 	HPPA, ARM and Sun4-SPARC.
 * 	[89/07/13            mrt]
 * 
 * Revision 2.12  89/05/30  10:38:58  rvb
 * 	Add R2000 machine types.
 * 	[89/05/30  08:28:53  rvb]
 * 
 * Revision 2.11  89/04/18  16:43:32  mwyoung
 * 	Use <machine/vm_types.h> rather than <vm/vm_param.h> to get
 * 	VM types.  Remove old history... none of it was insightful.
 * 
 * 	The variable declarations should be moved elsewhere.
 * 	[89/01/24            mwyoung]
 * 
 */
/*
 *	Machine independent machine abstraction.
 *	Copyright (C) 1986, Avadis Tevanian, Jr.
 */

#ifndef	_MACH_MACHINE_H_
#define _MACH_MACHINE_H_

#ifdef	KERNEL
#include <cpus.h>
#endif	KERNEL

#include <:mach:machine:vm_types.h>
#include <:mach:boolean.h>

/*
 *	For each host, there is a maximum possible number of
 *	cpus that may be available in the system.  This is the
 *	compile-time constant NCPUS, which is defined in cpus.h.
 *
 *	In addition, there is a machine_slot specifier for each
 *	possible cpu in the system.
 */

struct machine_info {
	int		major_version;	/* kernel major version id */
	int		minor_version;	/* kernel minor version id */
	int		max_cpus;	/* max number of cpus compiled */
	int		avail_cpus;	/* number actually available */
	vm_size_t	memory_size;	/* size of memory in bytes */
};

typedef struct machine_info	*machine_info_t;
typedef struct machine_info	machine_info_data_t;	/* bogus */

typedef int	cpu_type_t;
typedef int	cpu_subtype_t;

#define CPU_STATE_MAX		3

#define CPU_STATE_USER		0
#define CPU_STATE_SYSTEM	1
#define CPU_STATE_IDLE		2

struct machine_slot {
	boolean_t	is_cpu;		/* is there a cpu in this slot? */
	cpu_type_t	cpu_type;	/* type of cpu */
	cpu_subtype_t	cpu_subtype;	/* subtype of cpu */
	boolean_t	running;	/* is cpu running */
	long		cpu_ticks[CPU_STATE_MAX];
	int		clock_freq;	/* clock interrupt frequency */
};

typedef struct machine_slot	*machine_slot_t;
typedef struct machine_slot	machine_slot_data_t;	/* bogus */

#ifdef	KERNEL
extern struct machine_info	machine_info;
extern struct machine_slot	machine_slot[NCPUS];

extern vm_offset_t		interrupt_stack[NCPUS];
#endif	KERNEL

/*
 *	Machine types known by all.
 */

#define CPU_TYPE_VAX		((cpu_type_t) 1)
#define CPU_TYPE_ROMP		((cpu_type_t) 2)
#define CPU_TYPE_MC68020	((cpu_type_t) 3)
#define CPU_TYPE_NS32032	((cpu_type_t) 4)
#define CPU_TYPE_NS32332        ((cpu_type_t) 5)
#define CPU_TYPE_NS32532        ((cpu_type_t) 6)
#define CPU_TYPE_I386		((cpu_type_t) 7)
#define CPU_TYPE_MIPS		((cpu_type_t) 8)
#define	CPU_TYPE_MC68030	((cpu_type_t) 9)
#define CPU_TYPE_MC68040	((cpu_type_t) 10)
#define CPU_TYPE_HPPA           ((cpu_type_t) 11)
#define CPU_TYPE_ARM		((cpu_type_t) 12)
#define CPU_TYPE_MC88000	((cpu_type_t) 13)
#define CPU_TYPE_SPARC		((cpu_type_t) 14)
		

/*
 *	Machine subtypes (these are defined here, instead of in a machine
 *	dependent directory, so that any program can get all definitions
 *	regardless of where is it compiled).
 */

/*
 *	VAX subtypes (these do *not* necessary conform to the actual cpu
 *	ID assigned by DEC available via the SID register).
 */
 
#define CPU_SUBTYPE_VAX780	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_VAX785	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_VAX750	((cpu_subtype_t) 3)
#define CPU_SUBTYPE_VAX730	((cpu_subtype_t) 4)
#define CPU_SUBTYPE_UVAXI	((cpu_subtype_t) 5)
#define CPU_SUBTYPE_UVAXII	((cpu_subtype_t) 6)
#define CPU_SUBTYPE_VAX8200	((cpu_subtype_t) 7)
#define CPU_SUBTYPE_VAX8500	((cpu_subtype_t) 8)
#define CPU_SUBTYPE_VAX8600	((cpu_subtype_t) 9)
#define CPU_SUBTYPE_VAX8650	((cpu_subtype_t) 10)
#define CPU_SUBTYPE_VAX8800	((cpu_subtype_t) 11)
#define CPU_SUBTYPE_UVAXIII	((cpu_subtype_t) 12)

/*
 *	ROMP subtypes.
 */

#define CPU_SUBTYPE_RT_PC	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_RT_APC	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_RT_135	((cpu_subtype_t) 3)

/*
 *	68020 subtypes.
 */

#define CPU_SUBTYPE_SUN3_50	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_SUN3_160	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_SUN3_260	((cpu_subtype_t) 3)
#define CPU_SUBTYPE_SUN3_110	((cpu_subtype_t) 4)
#define CPU_SUBTYPE_SUN3_60	((cpu_subtype_t) 5)

#define CPU_SUBTYPE_HP_320	((cpu_subtype_t) 6)
	/* 16.67 Mhz HP 300 series, custom MMU [HP 320] */
#define CPU_SUBTYPE_HP_330	((cpu_subtype_t) 7)
	/* 16.67 Mhz HP 300 series, MC68851 MMU [HP 318,319,330,349] */
#define CPU_SUBTYPE_HP_350	((cpu_subtype_t) 8)
	/* 25.00 Mhz HP 300 series, custom MMU [HP 350] */


/*
 *	32032/32332/32532 subtypes.
 */

#define CPU_SUBTYPE_MMAX_DPC	    ((cpu_subtype_t) 1)	/* 032 CPU */
#define CPU_SUBTYPE_SQT		    ((cpu_subtype_t) 2)
#define CPU_SUBTYPE_MMAX_APC_FPU    ((cpu_subtype_t) 3)	/* 32081 FPU */
#define CPU_SUBTYPE_MMAX_APC_FPA    ((cpu_subtype_t) 4)	/* Weitek FPA */
#define CPU_SUBTYPE_MMAX_XPC	    ((cpu_subtype_t) 5)	/* 532 CPU */

/*
 *	80386 subtypes.
 */

#define CPU_SUBTYPE_AT386	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_EXL		((cpu_subtype_t) 2)

/*
 *	Mips subtypes.
 */

#define CPU_SUBTYPE_MIPS_R2300	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MIPS_R2600	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_MIPS_R2800	((cpu_subtype_t) 3)
#define CPU_SUBTYPE_MIPS_R2000a	((cpu_subtype_t) 4)	/* pmax */
#define CPU_SUBTYPE_MIPS_R2000	((cpu_subtype_t) 5)
#define CPU_SUBTYPE_MIPS_R3000a	((cpu_subtype_t) 6)	/* 3max */
#define CPU_SUBTYPE_MIPS_R3000	((cpu_subtype_t) 7)


/*
 * 	MC68030 subtypes
 */

#define CPU_SUBTYPE_NeXT	((cpu_subtype_t) 1) 
	/* NeXt thinks MC68030 is 6 rather than 9 */
#define CPU_SUBTYPE_HP_340	((cpu_subtype_t) 2) 
	/* 16.67 Mhz HP 300 series [HP 332,340] */
#define CPU_SUBTYPE_HP_360	((cpu_subtype_t) 3) 
	/* 25.00 Mhz HP 300 series [HP 360] */
#define CPU_SUBTYPE_HP_370	((cpu_subtype_t) 4) 
	/* 33.33 Mhz HP 300 series [HP 370] */


/*
 *	HPPA subtypes  Hewlett-Packard HP-PA family of
 *	risc processors 800 series workstations.
 *	Port done by Hewlett-Packard
 */

#define CPU_SUBTYPE_HPPA_825	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_HPPA_835	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_HPPA_840	((cpu_subtype_t) 3)
#define CPU_SUBTYPE_HPPA_850	((cpu_subtype_t) 4)
#define CPU_SUBTYPE_HPPA_855	((cpu_subtype_t) 5)

/* 
 * 	Acorn subtypes - Acorn Risc Machine port done by
 *		Olivetti System Software Laboratory
 */

#define CPU_SUBTYPE_ARM_A500_ARCH	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_ARM_A500		((cpu_subtype_t) 2)
#define CPU_SUBTYPE_ARM_A440		((cpu_subtype_t) 3)
#define CPU_SUBTYPE_ARM_M4		((cpu_subtype_t) 4)
#define CPU_SUBTYPE_ARM_A680		((cpu_subtype_t) 5)

/*
 *	MC88000 subtypes - Encore doing port.
 */

#define CPU_SUBTYPE_MMAX_JPC	((cpu_subtype_t) 1)

/*
 *	Sun4 subtypes - port done at CMU
 */

#define CPU_SUBTYPE_SUN4_260		((cpu_subtype_t) 1)
#define CPU_SUBTYPE_SUN4_110		((cpu_subtype_t) 2)
#define CPU_SUBTYPE_SUN4_330		((cpu_subtype_t) 3)
#define CPU_SUBTYPE_SUN4C_60		((cpu_subtype_t) 4)
#define CPU_SUBTYPE_SUN4C_65		((cpu_subtype_t) 5)


#endif	_MACH_MACHINE_H_
@EOF@

echo "include/mach/memory_object.defs"
cat >include/mach/memory_object.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	memory_object.defs,v $
 * Revision 2.5  90/07/03  16:38:48  mrt
 * 	Add memory_object_supply_completed, memory_object_data_return.
 * 	[90/06/13            dlb]
 * 
 * Revision 2.4  89/04/08  23:40:45  rpd
 * 	Use internal_memory_pointer_t for memory_object_data_write.
 * 	Import kern/mig_user_hack.h when KERNEL_USER is defined.
 * 	[89/04/08  22:58:02  rpd]
 * 
 * Revision 2.3  89/02/25  18:38:17  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:31:06  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:40:04  rpd]
 * 
 * Revision 2.6  89/01/12  07:58:12  rpd
 * 	Fixed includes.
 * 	[89/01/12  04:52:21  rpd]
 * 
 * Revision 2.5  88/12/19  02:46:15  mwyoung
 * 	Change argument to memory_object_init to avoid lint in the MiG
 * 	output.
 * 	[88/12/18            mwyoung]
 * 	
 * 	Add memory_object_copy.
 * 	[88/11/07            mwyoung]
 * 
 * Revision 2.4  88/08/25  18:16:54  mwyoung
 * 	Add memory_object_terminate.
 * 	[88/08/11  18:46:46  mwyoung]
 * 
 * 29-Jun-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Use new types.
 *
 * 29-Jun-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Moved data type declarations to "mach_types.defs".
 *
 *  9-Dec-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Split that part of the interface applicable only to default
 *	pagers into a separate interface definition.
 *
 *	Documented the interface.
 *	
 *	Purged history.  Contributors so far: jle, mwyoung, bolosky.
 *
 */
/*
 * File:	mach/memory_object.defs
 *
 * Abstract:
 *	Basic Mach external memory management interface declaration.
 */

subsystem memory_object 2200;

#include <:mach:std_types.defs>
#include <:mach:mach_types.defs>

#ifdef	KERNEL_USER
uimport <kern/mig_user_hack.h>;
#endif	KERNEL_USER

/*
 *	Initialize the specified memory object, providing
 *	a reqeust port on which control calls can be made, and
 *	a name port that identifies this object to callers of
 *	vm_regions.
 *	[To allow the mapping of this object to be used, the
 *	memory manager must call memory_object_set_attributes,
 *	specifying the "ready" parameter as TRUE.  To reject
 *	all mappings of this object, the memory manager may
 *	use memory_object_destroy.]
 */
simpleroutine	memory_object_init(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t;
		memory_object_name	: memory_object_name_t;
		memory_object_page_size	: vm_size_t);

/*
 *	Indicates that the specified memory object is no longer
 *	mapped (or cached -- see memory_object_set_attributes),
 *	and that further mappings will cause another memory_object_init
 *	call to be made.  No further calls will be made on
 *	the memory object by this kernel.
 *
 *	[All rights to the control and name ports are included
 *	in this call.  The memory manager should use port_deallocate
 *	to release them once they are no longer needed.]
 */
simpleroutine	memory_object_terminate(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t = port_all_t, dealloc;
		memory_object_name	: memory_object_name_t = port_all_t, dealloc);

/*
 *	Indicates that a copy has been made of the specified range of
 *	the given original memory object.  The kernel will use the new
 *	memory object, control and name ports to refer to the new copy
 *	(once the memory manager has asserted its "ready" attribute).
 *
 *	Cached pages from the original memory object at the time of
 *	the copy operation are handled as follows:
 *		Readable pages may be silently copied to the new
 *		 memory object (with all access permissions).
 *		Pages not copied are locked to prevent write access.
 *
 *	This call includes only the new memory object itself; a
 *	memory_object_init call will be made on the new memory
 *	object after the actions above are completed.
 *
 *	The new memory object is *temporary*, meaning that the
 *	memory manager should not change its contents or allow
 *	the memory object to be mapped in another client.  The
 *	memory manager may use the memory_object_data_unavailable
 *	call to indicate that the appropriate page of the original
 *	memory object may be used to fulfill a data request.
 *
 *	[Reply should be memory_object_set_attributes on the
 *	new memory object control port to indicate readiness.]
 */
simpleroutine	memory_object_copy(
		old_memory_object	: memory_object_t;
		old_memory_control	: memory_object_control_t;
		offset			: vm_offset_t;
		length			: vm_size_t;
		new_memory_object	: memory_object_t = port_all_t, dealloc);

/*
 *	Request data from this memory object.  At least
 *	the specified data should be returned with at
 *	least the specified access permitted.
 *
 *	[Reply should be memory_object_data_provided.]
 */
simpleroutine	memory_object_data_request(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t;
		offset			: vm_offset_t;
		length			: vm_size_t;
		desired_access		: vm_prot_t);

/*
 *	Request that the specified portion of this
 *	memory object be unlocked to allow the specified
 *	forms of access; the kernel already has the data.
 *
 *	[Reply should be memory_object_lock_request.]
 */
simpleroutine	memory_object_data_unlock(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t;
		offset			: vm_offset_t;
		length			: vm_size_t;
		desired_access		: vm_prot_t);

/*
 *	Write back modifications made to this portion of
 *	the memory object while in memory.
 *
 *	Unless explicitly requested by a memory_object_lock_request
 *	(clean, but not flush),	the kernel will not retain
 *	the data.
 *
 *	[Reply should be vm_deallocate to release the data.]
 */
simpleroutine	memory_object_data_write(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t;
		offset			: vm_offset_t;
		data			: internal_memory_pointer_t);

/*
 *	Indicate that a previous memory_object_lock_request has been
 *	completed.  Note that this call is made on whatever
 *	port is specified in the memory_object_lock_request; that port
 *	need not be the memory object port itself.
 *
 *	[No reply expected.]
 */
simpleroutine	memory_object_lock_completed(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t;
		offset			: vm_offset_t;
		length			: vm_size_t);


/*
 *	Indicate that a previous memory_object_data_supply has been
 *	completed.  Note that this call is made on whatever
 *	port is specified in the memory_object_data_supply; that port
 *	need not be the memory object port itself.
 *
 *	The result parameter indicates what happened during the supply.
 *	If it is not KERN_SUCCESS, then error_offset identifies the
 *	first offset at which a problem occurred.  The kernel tried
 *	to pagein the remaining data.
 *
 * XXX	Could abandon things after the first error, so that the
 * XXX  pager knows that everything beyond error_offset did not get
 * XXX  paged in.
 *
 *	[No reply expected.]
 */
simpleroutine	memory_object_supply_completed(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t;
		offset			: vm_offset_t;
		length			: vm_size_t;
		result			: kern_return_t;
		error_offset		: vm_offset_t);


/*
 *	Return precious unmodified data to manager.  This call is used
 *	to return precious data to a manager if it is unmodified; modified
 *	data is returned via memory_object_data_write.   Data is precious
 *	if it was so marked by memory_object_data_supply.
 *
 *	Unless explicitly requested by a memory_object_lock_request
 *	(clean, but not flush),	the kernel will not retain
 *	the data.
 *
 *	[Reply should be vm_deallocate to release the data.]
 */
simpleroutine	memory_object_data_return(
		memory_object		: memory_object_t;
		memory_control		: memory_object_control_t;
		offset			: vm_offset_t;
		data			: internal_memory_pointer_t);
@EOF@

echo "include/mach/memory_object.h"
cat >include/mach/memory_object.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	memory_object.h,v $
 * Revision 2.6  89/03/09  20:21:12  rpd
 * 	More cleanup.
 * 
 * Revision 2.5  89/02/25  18:38:23  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.4  89/02/07  00:54:07  mwyoung
 * Relocated from vm/memory_object.h
 * 
 * Revision 2.3  89/01/30  22:08:42  rpd
 * 	Updated includes to the new style.  Fixed log.
 * 	Made variable declarations use "extern".
 * 	[89/01/25  15:25:20  rpd]
 */
/*
 *	File:	memory_object.h
 *	Author:	Michael Wayne Young
 *
 *	External memory management interface definition.
 */

#ifndef	_MACH_MEMORY_OBJECT_H_
#define _MACH_MEMORY_OBJECT_H_

/*
 *	User-visible types used in the external memory
 *	management interface:
 */

#include <:mach:port.h>

typedef	port_t		memory_object_t;
					/* Represents a memory object ... */
					/*  Used by user programs to specify */
					/*  the object to map; used by the */
					/*  kernel to retrieve or store data */

typedef	port_t		memory_object_control_t;
					/* Provided to a memory manager; ... */
					/*  used to control a memory object */

typedef	port_t		memory_object_name_t;
					/* Used to describe the memory ... */
					/*  object in vm_regions() calls */

typedef	int		memory_object_copy_strategy_t;
					/* How memory manager handles copy: */
#define		MEMORY_OBJECT_COPY_NONE		0
					/* ... No special support */
#define		MEMORY_OBJECT_COPY_CALL		1
					/* ... Make call on memory manager */
#define		MEMORY_OBJECT_COPY_DELAY 	2
					/* ... Memory manager doesn't ... */
					/*     change data externally. */


#define		MEMORY_OBJECT_NULL	PORT_NULL

/* Obsolete forms of the above names: */
#ifndef	KERNEL
typedef	port_t		paging_object_t;
typedef	port_t		vm_pager_request_t;
typedef	port_t		vm_pager_t;
#define vm_pager_null	((vm_pager_t) 0)
#endif	KERNEL

#ifdef	KERNEL
extern memory_object_t	memory_manager_default;
#endif	KERNEL
#endif	_MACH_MEMORY_OBJECT_H_
@EOF@

echo "include/mach/memory_object_default.defs"
cat >include/mach/memory_object_default.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	memory_object_default.defs,v $
 * Revision 2.4  89/04/08  23:40:52  rpd
 * 	Use internal_memory_pointer_t for memory_object_data_initialize.
 * 	Import <kern/mig_user_hack.h> when KERNEL_USER is defined.
 * 	[89/04/08  22:59:11  rpd]
 * 
 * Revision 2.3  89/02/25  18:38:29  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:31:26  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:40:47  rpd]
 * 
 * Revision 2.7  89/01/12  07:58:30  rpd
 * 	Fixed includes.
 * 	[89/01/12  04:52:50  rpd]
 * 
 * Revision 2.6  88/08/25  18:17:23  mwyoung
 * 	Rid the kernel_task of rights to the new memory_object in
 * 	memory_object_create.
 * 	Add size argument to memory_object_create.
 * 	[88/08/11  18:47:16  mwyoung]
 * 
 * Revision 2.5  88/08/06  18:23:00  rpd
 * Added dealloc flag to new_memory_object arg of memory_object_create().
 * Otherwise, kernel_task is left with send right, and this is very bad.
 * 
 * 29-Jun-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Use new types.
 *
 * 29-Jun-88  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Moved data type declarations to "mach_types.defs".
 *
 *  9-Dec-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 */
/*
 * File:	mach/memory_object_default.defs
 *
 * Abstract:
 *	Mach external memory management interface declaration; subset
 *	that is applicable to managers of kernel-created memory objects.
 */

subsystem memory_object_default 2250;

#include <:mach:std_types.defs>
#include <:mach:mach_types.defs>

#ifdef	KERNEL_USER
uimport <kern/mig_user_hack.h>;
#endif	KERNEL_USER

/*
 *	Pass on responsibility for the new kernel-created memory
 *	object.  The port on which this request is that port
 *	(possibly a memory object itself) registered as the "default
 *	pager".  Other arguments are as described for memory_object_init.
 *	[No reply required.]
 */
simpleroutine	memory_object_create(
		old_memory_object	: memory_object_t;
		new_memory_object	: memory_object_t = port_all_t, dealloc;
		new_object_size		: vm_size_t;
		new_control_port	: memory_object_control_t;
		new_name		: memory_object_name_t;
		new_page_size		: vm_size_t);

/*
 *	Provide initial data contents for this region of
 *	the memory object.  If data has already been written
 *	to the object, this value must be discarded; otherwise,
 *	this call acts identically to memory_object_data_write.
 */
simpleroutine	memory_object_data_initialize(
		memory_object		: memory_object_t;
		memory_control_port	: memory_object_control_t;
		offset			: vm_offset_t;
		data			: internal_memory_pointer_t);

#if	0
/*
 *	Indicate that the specified range of data in this memory object
 *	will not be requested again until it is reinitialized with
 *	memory_object_data_write or memory_object_data_initialize.
 */
simpleroutine	memory_object_data_terminate(
		memory_object		: memory_object_t;
		memory_control_port	: memory_object_control_t;
		offset			: vm_offset_t;
		size			: vm_size_t);
#else	0
skip;
#endif	0
@EOF@

echo "include/mach/message.h"
cat >include/mach/message.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	message.h,v $
 * Revision 2.14  90/02/20  19:11:57  mrt
 * 	Removed LINTLIBRARY code since this is now the wrong file
 * 	to include in a lint library and these definitions clash
 * 	with the ones in msg.c. Removed ancient history and content
 * 	free revision comments.
 * 	[90/02/20            mrt]
 * 
 * Revision 2.13  89/05/01  17:02:55  rpd
 * 	Named the unused bits in msg_header_t and msg_type_t.
 * 	[89/05/01  14:10:59  rpd]
 * 
 * Revision 2.12  89/04/08  23:57:26  rpd
 * 	Added MSG_TYPE_POLYMORPHIC.
 * 	[89/04/08  23:56:51  rpd]
 * 
 * Revision 2.11  89/03/15  15:05:28  gm0w
 * 	Removed define of EXPORT_BOOLEAN and include of mach/boolean.h
 * 	[89/03/14            mrt]
 * 
 * Revision 2.9  89/03/05  16:48:39  rpd
 * 	Moved ownership rights under MACH_IPC_XXXHACK (when KERNEL).
 * 	[89/02/16            rpd]
 * 
 * Revision 2.6  88/10/11  10:25:00  rpd
 * 	Made comments fit into 80 column windows.
 * 	Commented out SEND_MSG_SIZE_CHANGE and SEND_KERNEL.
 * 	[88/10/09  08:48:39  rpd]
 * 
 * Revision 2.5  88/09/25  22:16:18  rpd
 * 	Commented out MSG_TYPE_INVALID.
 * 	[88/09/24  18:10:21  rpd]
 * 
 * Revision 2.3  88/07/20  21:05:05  rpd
 * Made MSG_TYPE_PORT_NAME a separate type.
 * 
 *	Mach IPC message and primitive function definitions.
 *
 */

#ifndef	_MACH_MESSAGE_H_
#define _MACH_MESSAGE_H_

#ifdef	KERNEL
#include <mach_ipc_xxxhack.h>
#endif	KERNEL

#include <:mach:port.h>

/*
 *	Message data structures.
 *
 *	Messages consist of two parts: a fixed-size header, immediately
 *	followed by a variable-size array of typed data items.
 *
 */

typedef	unsigned int	msg_size_t;

typedef	struct {
		unsigned int	msg_unused : 24,
				msg_simple : 8;
		msg_size_t	msg_size;
		int		msg_type;
		port_t		msg_local_port;
		port_t		msg_remote_port;
		int		msg_id;
} msg_header_t;

#define MSG_SIZE_MAX	8192

/*
 *	Known values for the msg_type field.
 *	These are Accent holdovers, which should be purged when possible.
 *
 *	Only one bit in the msg_type field is used by the kernel.
 *	Others are available to user applications.  See <msg_type.h>
 *	for system application-assigned values.
 */

#define MSG_TYPE_NORMAL		0
#define MSG_TYPE_EMERGENCY	1

/*
 *	Each data item is preceded by a description of that
 *	item, including what type of data, how big it is, and
 *	how many of them are present.
 *
 *	The actual data will either follow this type
 *	descriptor ("inline") or will be specified by a pointer.
 *
 *	If the type name, size, or number is too large to be encoded
 *	in this structure, the "longform" option may be selected,
 *	and those fields must immediately follow in full integer fields.
 *
 *	For convenience, out-of-line data regions or port rights may
 *	be deallocated when the message is sent by specifying the
 *	"deallocate" field.  Beware: if the data item in question is both
 *	out-of-line and contains port rights, then both will be deallocated.
 */

typedef struct  {
	unsigned int	msg_type_name : 8,		/* What kind of data */
			msg_type_size : 8,		/* How many bits is each item */
			msg_type_number : 12,		/* How many items are there */
			msg_type_inline : 1,		/* If true, data follows; else a pointer */
			msg_type_longform : 1,		/* Name, size, number follow: see above */
			msg_type_deallocate : 1,	/* Deallocate port rights or memory */
			msg_type_unused : 1;
} msg_type_t;

typedef	struct	{
	msg_type_t	msg_type_header;
	unsigned short	msg_type_long_name;
	unsigned short	msg_type_long_size;
	unsigned int	msg_type_long_number;
} msg_type_long_t;

/*
 *	Known values for the msg_type_name field.
 *
 *	The only types known to the Mach kernel are
 *	the port types, and those types used in the
 *	kernel RPC interface.
 */

#define MSG_TYPE_UNSTRUCTURED	0
#define MSG_TYPE_BIT		0
#define MSG_TYPE_BOOLEAN	0
#define MSG_TYPE_INTEGER_16	1
#define MSG_TYPE_INTEGER_32	2
#if	!defined(KERNEL) || MACH_IPC_XXXHACK
#define MSG_TYPE_PORT_OWNERSHIP	3
#define MSG_TYPE_PORT_RECEIVE	4
#endif	!defined(KERNEL) || MACH_IPC_XXXHACK
#define MSG_TYPE_PORT_ALL	5
#define MSG_TYPE_PORT		6
#define MSG_TYPE_CHAR		8
#define MSG_TYPE_BYTE		9
#define MSG_TYPE_INTEGER_8	9
#define MSG_TYPE_REAL		10
#define MSG_TYPE_STRING		12
#define MSG_TYPE_STRING_C	12
/*	MSG_TYPE_INVALID	13	unused */

#ifdef	KERNEL
#define MSG_TYPE_INTERNAL_MEMORY 14
#else	KERNEL
#define MSG_TYPE_INTERNAL_MEMORY MSG_TYPE_INTEGER_8
#endif	KERNEL

#define MSG_TYPE_PORT_NAME	15		/* A capability name */
#define MSG_TYPE_LAST		16		/* Last assigned */

#define MSG_TYPE_POLYMORPHIC	((unsigned int) -1)

/*
 *	Is a given item a port type?
 */

#if	!defined(KERNEL) || MACH_IPC_XXXHACK
#define MSG_TYPE_PORT_ANY(x)	\
	(((x) >= MSG_TYPE_PORT_OWNERSHIP) && ((x) <= MSG_TYPE_PORT))
#else	!defined(KERNEL) || MACH_IPC_XXXHACK
#define MSG_TYPE_PORT_ANY(x)	\
	(((x) == MSG_TYPE_PORT) || ((x) == MSG_TYPE_PORT_ALL))
#endif	!defined(KERNEL) || MACH_IPC_XXXHACK

/*
 *	Other basic types
 */

typedef	unsigned int	msg_timeout_t;

/*
 *	Options to IPC primitives.
 *
 *	These can be combined by or'ing; the combination RPC call
 *	uses both SEND_ and RCV_ options at once.
 */

typedef	int		msg_option_t;

#define MSG_OPTION_NONE	0x0000	/* Terminate only when message op works */

#define SEND_TIMEOUT	0x0001	/* Terminate on timeout elapsed */
#define SEND_NOTIFY	0x0002	/* Terminate with reply message if need be */

#define SEND_INTERRUPT	0x0004	/* Terminate on software interrupt */

#ifdef	KERNEL
#define SEND_USER	(SEND_TIMEOUT|SEND_NOTIFY)
				/* Valid user options */
#define SEND_ALWAYS	0x0008	/* Never block */
/*	SEND_KERNEL	0x0010	   Kernel is originator (not used) */
#define SEND_SWITCH	0x0020	/* Use handoff scheduling */
#endif	KERNEL

#define RCV_TIMEOUT	0x0100	/* Terminate on timeout elapsed */
#define RCV_NO_SENDERS	0x0200	/* Terminate if I'm the only sender left */
#define RCV_INTERRUPT	0x0400	/* Terminate on software interrupt */

#ifdef	KERNEL
#define RCV_USER	(RCV_TIMEOUT|RCV_NO_SENDERS|RCV_INTERRUPT)
#endif	KERNEL

/*
 *	Returns from IPC primitives.
 *
 *	Values are separate in order to allow RPC users to
 *	distinguish which operation failed; for successful completion,
 *	this doesn't matter.
 */

typedef	int		msg_return_t;

#define SEND_SUCCESS		0

#define SEND_ERRORS_START	-100
#ifdef	KERNEL
#define SEND_IN_PROGRESS	-100
#endif	KERNEL
#define SEND_INVALID_MEMORY	-101	/* Message or OOL data invalid */
#define SEND_INVALID_PORT	-102	/* Reference to inacessible port */
#define SEND_TIMED_OUT		-103	/* Terminated due to timeout */
#define SEND_WILL_NOTIFY	-105	/* Msg accepted provisionally */
#define SEND_NOTIFY_IN_PROGRESS	-106	/* Already awaiting a notification */
#define SEND_KERNEL_REFUSED	-107	/* Message to the kernel refused */
#define SEND_INTERRUPTED	-108	/* Software interrupt during send */
#define SEND_MSG_TOO_LARGE	-109	/* Message specified was too large */
#define SEND_MSG_TOO_SMALL	-110	/* Data specified exceeds msg size */
/*	SEND_MSG_SIZE_CHANGE	-111	   Msg size changed during copy */
#define SEND_ERRORS_END		-111

#define msg_return_send(x)	((x) < SEND_ERRORS_START && (x) > SEND_ERRORS_END)

#define RCV_SUCCESS		0

#define RCV_ERRORS_START	-200
#ifdef	KERNEL
#define RCV_IN_PROGRESS		-200
#endif	KERNEL
#define RCV_INVALID_MEMORY	-201
#define RCV_INVALID_PORT	-202
#define RCV_TIMED_OUT		-203
#define RCV_TOO_LARGE		-204	/* Msg structure too small for data */
#define RCV_NOT_ENOUGH_MEMORY	-205	/* Can't find space for OOL data */
#define RCV_ONLY_SENDER		-206	/* Receiver is only sender */
#define RCV_INTERRUPTED		-207
#define RCV_PORT_CHANGE		-208	/* Port was put in a set */
#define RCV_ERRORS_END		-209

#define msg_return_rcv(x)	((x) < RCV_ERRORS_START && (x) > RCV_ERRORS_END)

#define RPC_SUCCESS		0

/*
 *	The IPC primitive functions themselves
 */

msg_return_t	msg_send(
#if	c_plusplus
	msg_header_t	*header,
	msg_option_t	option,
	msg_timeout_t	timeout);
#else	c_plusplus
		);
#endif	c_plusplus

msg_return_t	msg_receive(
#if	c_plusplus
	msg_header_t	*header,
	msg_option_t	option,
	msg_timeout_t	timeout);
#else	c_plusplus
		);
#endif	c_plusplus

msg_return_t	msg_rpc(
#if	c_plusplus
	msg_header_t	*header,	/* in/out */
	msg_option_t	option,
	msg_size_t	rcv_size,
	msg_timeout_t	send_timeout,
	msg_timeout_t	rcv_timeout);
#else	c_plusplus
		);
#endif	c_plusplus

#endif	_MACH_MESSAGE_H_
@EOF@

echo "include/mach/mig_errors.h"
cat >include/mach/mig_errors.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mig_errors.h,v $
 * Revision 2.6  90/07/03  16:39:02  mrt
 * 	Merged mt Xinu 2.6MSD Changes.
 * 	[90/05/17  17:55:56  mrt]
 * 
 * Revision 1.8  89/11/30  17:49:44  mrt
 * 	Changed one more instance of hc to __HC__
 * 	[89/11/30            pds]
 * 
 * Revision 1.7  89/05/20  22:17:01  mrt
 * 	Source in kernel/mach/mig_errors.h
 * 
 * Revision 2.5  89/03/09  20:21:26  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:38:41  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  01:01:21  mwyoung
 * Relocated from sys/mig_errors.h
 * 
 * Revision 2.2  88/07/20  21:05:51  rpd
 * Added definition of mig_symtab_t.
 * 
 *  2-Dec-87  David Golub (dbg) at Carnegie-Mellon University
 *	Added MIG_ARRAY_TOO_LARGE.
 *
 * 25-May-87  Richard Draves (rpd) at Carnegie-Mellon University
 *	Added definition of death_pill_t.
 *
 * 31-Jul-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 * Mach Interface Generator errors
 *
 */

#ifndef	_MACH_MIG_ERRORS_H_
#define _MACH_MIG_ERRORS_H_

#include <:mach:kern_return.h>
#include <:mach:message.h>

#define MIG_TYPE_ERROR		-300		/* Type check failure */
#define MIG_REPLY_MISMATCH	-301		/* Wrong return message ID */
#define MIG_REMOTE_ERROR	-302		/* Server detected error */
#define MIG_BAD_ID		-303		/* Bad message ID */
#define MIG_BAD_ARGUMENTS	-304		/* Server found wrong arguments */
#define MIG_NO_REPLY		-305		/* Server shouldn't reply */
#define MIG_EXCEPTION		-306		/* Server raised exception */
#define MIG_ARRAY_TOO_LARGE	-307		/* User specified array not large enough
						   to hold returned array */

typedef struct {
	msg_header_t	Head;
	msg_type_t	RetCodeType;
	kern_return_t	RetCode;
} death_pill_t;

typedef struct mig_symtab {
	char	*ms_routine_name;
	int	ms_routine_number;
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(__HC__)
	void
#else
	int
#endif
		(*ms_routine)();
} mig_symtab_t;

#endif	_MACH_MIG_ERRORS_H_
@EOF@

echo "include/mach/monitor.defs"
cat >include/mach/monitor.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	monitor.defs,v $
 * Revision 2.5  90/07/20  10:55:14  mrt
 * 	Move monitor types to mach_types.defs.
 * 	[90/06/29            dlb]
 * 
 * Revision 2.4  90/03/27  18:48:39  dlb
 * 	Under KERNEL_SERVER, pass the out argument of monitor_create as a
 * 	port_t.  It's really a monitor_t, but monitor_create has to do
 * 	the conversion internally to prevent the monitor from appearing
 * 	to be garbage.  This isn't pretty.
 * 	[90/02/08            dlb]
 * 
 * Revision 2.3  89/10/15  02:05:45  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.2  89/10/11  14:40:44  dlb
 * 	Add IsLong to buffer in monitor_read for compatibility.
 * 	Remove KERNEL_SERVER define.  Cleanup and update to new MiG.
 * 	[89/08/02            dlb]
 * 
 * 	Modified the parameters to the monitor_read routine.  Added
 * 	kernel_event.h include file.  Added types kern_mon_data_t
 * 	and kern_mon_buffer_t.
 * 	[89/02/16            tfl]
 * 
 * Revision 2.1.1.2  89/08/02  23:56:19  dlb
 * 	Add IsLong to buffer in monitor_read for compatibility.
 * 	Remove KERNEL_SERVER define.  Cleanup and update to new MiG.
 * 	[89/08/02            dlb]
 * 
 * Revision 2.1.1.1  89/07/25  17:24:08  dlb
 * 	Added include files mach_types.defs and std_types.defs.  Removed
 * 	type definitions for task_t, port_t etc.  This update done to 
 * 	be consistent with other .defs files.
 * 	[89/02/20            tfl]
 * 
 * 	Modified the parameters to the monitor_read routine.  Added
 * 	kernel_event.h include file.  Added types kern_mon_data_t
 * 	and kern_mon_buffer_t.
 * 	[89/02/16            tfl]
 * 
 * 	Removed old MiG definitions kernel monitor interface and added
 * 	new ones (the system call definitions).
 * 	[88/04/15            tfl]
 * 
 * 	Added translation definition for monitor_t.
 * 	[88/04/04            dlb]
 * 
 */

subsystem monitor 2800;

/*
 * Abstract:
 *   MiG definitions file for monitor kernel interface.  This file
 *	is preliminary pending an implementation of monitor ports.
 *
 */

#include <:mach:std_types.defs>
#include <:mach:mach_types.defs>

import <mach/kernel_event.h>;

routine	monitor_create(
		this_task	: task_t;
#if	KERNEL_SERVER
	out	new_monitor	: port_t;
#else	KERNEL_SERVER
	out	new_monitor	: monitor_t;
#endif	KERNEL_SERVER
	inout	requested_size	: int);

routine	monitor_terminate(
		this_monitor	: monitor_t); 

routine	monitor_resume(
		this_monitor	: monitor_t); 

routine	monitor_suspend(
		this_monitor	: monitor_t); 


routine thread_monitor(
		this_monitor	: monitor_t;
		monitor_id	: int;
		this_thread	: thread_t);

routine thread_unmonitor(
		this_monitor	: monitor_t;
		this_thread	: thread_t);

routine monitor_read(
		this_monitor	: monitor_t;
	out	buffer		: kern_mon_buffer_t, IsLong);
@EOF@

echo "include/mach/msg_type.h"
cat >include/mach/msg_type.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	msg_type.h,v $
 * Revision 2.4  89/03/09  20:22:18  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:39:26  gm0w
 * 	Changes for cleanup.
 * 
 *  4-Mar-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added MSG_TYPE_RPC.
 *
 *  22-Dec-86 Mary Thompson
 *	defined MSG_TYPE_CAMELOT, and MSG_TYPE_ENCRYPTED
 *
 */
/*
 *    This file defines user msg types that may be ored into
 *    the msg_type field in a msg header. Values 0-5 are reserved
 *    for use by the kernel and are defined in message.h. 
 *
 */

#ifndef	_MACH_MSG_TYPE_H_
#define _MACH_MSG_TYPE_H_

#define MSG_TYPE_CAMELOT	(1 << 6)
#define MSG_TYPE_ENCRYPTED	(1 << 7)
#define MSG_TYPE_RPC		(1 << 8)	/* Reply expected */

#include <:mach:message.h>

#endif	_MACH_MSG_TYPE_H_
@EOF@

echo "include/mach/netport.h"
cat >include/mach/netport.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	netport.h,v $
 * Revision 2.2  89/03/10  13:42:27  rpd
 * 	Created from kern/ipc_netport.h.
 * 
 */

#ifndef	_MACH_NETPORT_H_
#define _MACH_NETPORT_H_

typedef unsigned long	netaddr_t;

/*
 * Network Port structure.
 */
typedef struct {
    long	np_uid_high;
    long	np_uid_low;
} np_uid_t;

typedef struct {
    netaddr_t	np_receiver;
    netaddr_t	np_owner;
    np_uid_t	np_puid;
    np_uid_t	np_sid;
} network_port_t;

#endif	_MACH_NETPORT_H_
@EOF@

echo "include/mach/notify.h"
cat >include/mach/notify.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	notify.h,v $
 * Revision 2.7  89/03/09  20:22:23  rpd
 * 	More cleanup.
 * 
 * Revision 2.6  89/03/05  16:48:54  rpd
 * 	Moved ownership rights under MACH_IPC_XXXHACK (when KERNEL).
 * 	[89/02/16            rpd]
 * 
 * Revision 2.5  89/02/25  18:39:31  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.4  89/02/07  00:52:49  mwyoung
 * Relocated from sys/notify.h
 * 
 * Revision 2.3  88/10/11  10:25:29  rpd
 * 	Added NOTIFY_PORT_DESTROYED.
 * 	[88/10/11  08:05:35  rpd]
 * 
 * Revision 2.2  88/08/24  02:37:53  mwyoung
 * 	Adjusted include file references.
 * 	[88/08/17  02:19:20  mwyoung]
 * 
 *
 * 21-Nov-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added notification message structure definition.
 *
 * 01-Jul-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created, based on Accent values.
 */
/*
 *	Kernel notification message definitions.
 *
 */

#ifndef	_MACH_NOTIFY_H_
#define _MACH_NOTIFY_H_

#ifdef	KERNEL
#include <mach_ipc_xxxhack.h>
#endif	KERNEL

#include <:mach:message.h>


/*
 *	Notifications sent upon interesting system events.
 */

#define NOTIFY_FIRST			0100
#define NOTIFY_PORT_DELETED		( NOTIFY_FIRST + 001 )
#define NOTIFY_MSG_ACCEPTED		( NOTIFY_FIRST + 002 )
#if	!defined(KERNEL) || MACH_IPC_XXXHACK
#define NOTIFY_OWNERSHIP_RIGHTS		( NOTIFY_FIRST + 003 )
#define NOTIFY_RECEIVE_RIGHTS		( NOTIFY_FIRST + 004 )
#endif	!defined(KERNEL) || MACH_IPC_XXXHACK
#define NOTIFY_PORT_DESTROYED		( NOTIFY_FIRST + 005 )
#define NOTIFY_LAST			( NOTIFY_FIRST + 015 )

typedef struct {
	msg_header_t	notify_header;
	msg_type_t	notify_type;
	port_t		notify_port;
} notification_t;

#endif	_MACH_NOTIFY_H_
@EOF@

echo "include/mach/policy.h"
cat >include/mach/policy.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	policy.h,v $
 * Revision 2.3  89/10/15  02:05:50  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.2  89/10/11  14:40:53  dlb
 * 	Cleanup changes.
 * 	[89/08/02            dlb]
 * 
 * Revision 2.1.1.2  89/08/02  23:12:03  dlb
 * 	Cleanup changes.
 * 	[89/08/02            dlb]
 * 
 * Revision 2.1.1.1  89/07/25  18:47:00  dlb
 * 	Created.
 * 
 */

#ifndef	_MACH_POLICY_H_
#define _MACH_POLICY_H_

/*
 *	mach/policy.h
 *
 *	Definitions for scheduing policy.
 */

/*
 *	Policy definitions.  Policies must be powers of 2.
 */
#define	POLICY_TIMESHARE	1
#define POLICY_FIXEDPRI		2
#define POLICY_LAST		2

#define invalid_policy(policy)	(((policy) <= 0) || ((policy) > POLICY_LAST))

#endif _MACH_POLICY_H_
@EOF@

echo "include/mach/port.h"
cat >include/mach/port.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	port.h,v $
 * Revision 2.10  89/03/09  20:22:30  rpd
 * 	More cleanup.
 * 
 * Revision 2.9  89/03/05  16:49:06  rpd
 * 	Moved ownership rights under MACH_IPC_XXXHACK.
 * 	[89/02/16            rpd]
 * 
 * Revision 2.8  89/02/25  18:39:37  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.7  89/02/07  00:52:59  mwyoung
 * Relocated from sys/port.h
 * 
 * Revision 2.6  89/01/10  23:32:30  rpd
 * 	Only define PORT_ENABLED when MACH_IPC_XXXHACK is turned on.
 * 	[89/01/10  23:10:59  rpd]
 * 
 * Revision 2.5  88/09/25  22:16:30  rpd
 * 	Removed PORT_INVALID.  Cast PORT_NULL as port_name_t and
 * 	PORT_ENABLED as port_set_name_t.
 * 	[88/09/24  18:11:43  rpd]
 * 
 * Revision 2.4  88/07/29  03:21:36  rpd
 * When non-KERNEL, don't define PORT_ILLEGAL and define PORT_ENABLED as
 * a global port-set variable.  Compatibility code in libmach will implement
 * port_enable/port_disable using a PORT_ENABLED variable.
 * 
 * Revision 2.3  88/07/20  21:06:54  rpd
 * Added port_set_name_t, port_name_array_t, port_type_t, port_type_array_t.
 * Added PORT_TYPE_* definitions.
 * Add port_name_t type.
 * 
 * Revision 2.2  88/07/17  18:53:32  mwyoung
 * .
 * 
 * Revision 2.1.2.1  88/06/28  20:51:47  mwyoung
 * Pick up rpd's changes.
 * 
 * Revision 2.1.1.1  88/06/23  23:30:39  rpd
 * Add port_name_t type.
 * 
 * 10-Nov-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added PORT_INVALID and some more documentation.
 *
 * 28-Oct-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added port_*_t types; not all are used by the
 *	kernel, but names are exported for consistency.
 *
 * 21-Oct-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added port_rcv_t type; used by the interface generator.
 *
 * 19-Jul-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Documentation change only.
 *
 * 26-Jun-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Added PORT_ENABLED to refer to any enabled port.
 *
 *  8-May-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created
 *
 */
/*
 *	File:	mach/port.h
 *
 *	Definition of a port
 *
 *	[The basic port_t type should probably be machine-dependent,
 *	as it must be represented by a 32-bit integer.]
 */

#ifndef	_MACH_PORT_H_
#define _MACH_PORT_H_

#ifdef	KERNEL
#include <mach_ipc_xxxhack.h>
#endif	KERNEL

typedef int 		port_name_t;		/* A capability's name */
typedef port_name_t	port_set_name_t;	/* Descriptive alias */
typedef port_name_t	*port_name_array_t;

typedef int		port_type_t;		/* What kind of capability? */
typedef port_type_t	*port_type_array_t;

	/* Values for port_type_t */

#define PORT_TYPE_NONE		0		/* No rights */
#define PORT_TYPE_SEND		1		/* Send rights */
#if	!defined(KERNEL) || MACH_IPC_XXXHACK
#define PORT_TYPE_RECEIVE	3		/* Send, receive rights */
#define PORT_TYPE_OWN		5		/* Send, ownership rights */
#endif	!defined(KERNEL) || MACH_IPC_XXXHACK
#define PORT_TYPE_RECEIVE_OWN	7		/* Send, receive, ownership */
#define PORT_TYPE_SET		9		/* Set ownership */
#define PORT_TYPE_LAST		10		/* Last assigned */

typedef	port_name_t	port_t;			/* Port with send rights */
typedef	port_t		port_rcv_t;		/* Port with receive rights */
typedef	port_t		port_own_t;		/* Port with ownership rights */
typedef	port_t		port_all_t;		/* Port with receive and ownership */
typedef	port_t		*port_array_t;

#define PORT_NULL	((port_name_t) 0)	/* Used to denote no port; legal value */
#ifdef	KERNEL
#if	MACH_IPC_XXXHACK
#define PORT_ENABLED	((port_set_name_t) -1)	/* Used in msg_receive */
#endif	MACH_IPC_XXXHACK
#else	KERNEL
extern port_set_name_t PORT_ENABLED;
#endif	KERNEL
#endif	_MACH_PORT_H_
@EOF@

echo "include/mach/processor_info.h"
cat >include/mach/processor_info.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	processor_info.h,v $
 * Revision 2.3  89/10/15  02:05:54  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.2  89/10/11  14:41:03  dlb
 * 	Add scheduling flavor of information.
 * 
 * 	Add load average and mach factor to processor set basic info.
 * 	[89/02/09            dlb]
 * 
 * Revision 2.1.1.4  89/08/02  23:12:21  dlb
 * 	Merge to X96
 * 
 * Revision 2.1.1.3  89/07/25  18:52:18  dlb
 * 	Add scheduling flavor of information.
 * 
 * Revision 2.1.1.2  89/02/13  23:05:49  dlb
 * 	Add load average and mach factor to processor set basic info.
 * 	[89/02/09            dlb]
 * 
 */

/*
 *	File:	mach/processor_info.h
 *	Author:	David L. Black
 *
 *	Copyright (C) 1988 David L. Black
 *
 *	Data structure definitions for processor_info, processor_set_info
 */

#ifndef	_MACH_PROCESSOR_INFO_H_
#define _MACH_PROCESSOR_INFO_H_

#include <:mach:machine.h>

/*
 *	Generic information structure to allow for expansion.
 */
typedef int	*processor_info_t;	/* varying array of int. */

#define PROCESSOR_INFO_MAX	(1024)	/* max array size */
typedef int	processor_info_data_t[PROCESSOR_INFO_MAX];


typedef int	*processor_set_info_t;	/* varying array of int. */

#define PROCESSOR_SET_INFO_MAX	(1024)	/* max array size */
typedef int	processor_set_info_data_t[PROCESSOR_SET_INFO_MAX];

/*
 *	Currently defined information.
 */
#define	PROCESSOR_BASIC_INFO	1		/* basic information */

struct processor_basic_info {
	cpu_type_t	cpu_type;	/* type of cpu */
	cpu_subtype_t	cpu_subtype;	/* subtype of cpu */
	boolean_t	running;	/* is processor running */
	int		slot_num;	/* slot number */
	boolean_t	is_master;	/* is this the master processor */
};

typedef	struct processor_basic_info	processor_basic_info_data_t;
typedef struct processor_basic_info	*processor_basic_info_t;
#define PROCESSOR_BASIC_INFO_COUNT \
		(sizeof(processor_basic_info_data_t)/sizeof(int))


#define	PROCESSOR_SET_BASIC_INFO	1	/* basic information */

struct processor_set_basic_info {
	int		processor_count;	/* How many processors */
	int		task_count;		/* How many tasks */
	int		thread_count;		/* How many threads */
	int		load_average;		/* Scaled */
	int		mach_factor;		/* Scaled */
};

/*
 *	Scaling factor for load_average, mach_factor.
 */
#define	LOAD_SCALE	1000		

typedef	struct processor_set_basic_info	processor_set_basic_info_data_t;
typedef struct processor_set_basic_info	*processor_set_basic_info_t;
#define PROCESSOR_SET_BASIC_INFO_COUNT \
		(sizeof(processor_set_basic_info_data_t)/sizeof(int))

#define PROCESSOR_SET_SCHED_INFO	2	/* scheduling info */

struct processor_set_sched_info {
	int		policies;	/* allowed policies */
	int		max_priority;	/* max priority for new threads */
};

typedef	struct processor_set_sched_info	processor_set_sched_info_data_t;
typedef struct processor_set_sched_info	*processor_set_sched_info_t;
#define PROCESSOR_SET_SCHED_INFO_COUNT \
		(sizeof(processor_set_sched_info_data_t)/sizeof(int))

#endif	_MACH_PROCESSOR_INFO_H_
@EOF@

echo "include/mach/std_types.defs"
cat >include/mach/std_types.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	std_types.defs,v $
 * Revision 2.5  89/05/06  02:58:09  rpd
 * 	Added the type char.
 * 	[89/05/06  02:45:02  rpd]
 * 
 * Revision 2.4  89/03/09  20:23:11  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:40:18  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:31:41  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:33:24  rpd]
 * 
 * Revision 2.2  89/01/12  07:58:48  rpd
 * 	Created.
 * 	[89/01/12  04:15:04  rpd]
 * 
 */
/*
 *	Mach kernel standard interface type declarations
 */

#ifndef	_MACH_STD_TYPES_DEFS_
#define _MACH_STD_TYPES_DEFS_

type char = MSG_TYPE_CHAR;
type short = MSG_TYPE_INTEGER_16;
type int = MSG_TYPE_INTEGER_32;
type boolean_t = MSG_TYPE_BOOLEAN;

type kern_return_t = int;

/* Until MIG & netmsgserver are updated, use integer type */
#define MSG_TYPE_PORT_NAME	MSG_TYPE_INTEGER_32

type port_name_t = MSG_TYPE_PORT_NAME;
type port_name_array_t = ^array[] of port_name_t;
type port_type_t = int;
type port_type_array_t = ^array[] of port_type_t;
type port_set_name_t = port_name_t;

type port_t = MSG_TYPE_PORT;
type port_all_t = MSG_TYPE_PORT_ALL;
type port_rcv_t = MSG_TYPE_PORT_RECEIVE;
type port_array_t = ^array[] of port_t;

type pointer_t = ^array [] of MSG_TYPE_BYTE;

import <mach/std_types.h>;

#endif	_MACH_STD_TYPES_DEFS_
@EOF@

echo "include/mach/std_types.h"
cat >include/mach/std_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	std_types.h,v $
 * Revision 2.4  89/03/09  20:23:16  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:40:23  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/15  16:31:59  rpd
 * 	Moved from kern/ to mach/.
 * 	[89/01/15  14:34:14  rpd]
 * 
 * Revision 2.2  89/01/12  07:59:07  rpd
 * 	Created.
 * 	[89/01/12  04:15:40  rpd]
 * 
 */
/*
 *	Mach standard external interface type definitions.
 *
 */

#ifndef	_MACH_STD_TYPES_H_
#define _MACH_STD_TYPES_H_

#define EXPORT_BOOLEAN

#include <:mach:boolean.h>
#include <:mach:kern_return.h>
#include <:mach:port.h>
#include <:mach:machine:vm_types.h>


typedef	vm_offset_t	pointer_t;

#endif	_MACH_STD_TYPES_H_
@EOF@

echo "include/mach/syscall_sw.h"
cat >include/mach/syscall_sw.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	syscall_sw.h,v $
 * Revision 2.9  89/12/22  16:28:45  rpd
 * 	Added rfs_make_symlink() and mach_swapon() syscalls.
 * 	[89/11/24  15:07:28  rpd]
 * 
 * Revision 2.8  89/10/11  14:41:26  dlb
 * 	Remove thread_restore_priority.
 * 	Add thread_switch.
 * 	Remove kern_timestamp.
 * 	Add host traps.
 * 
 * Revision 2.7.3.1  89/08/04  14:37:47  dlb
 * 	Add thread_restore_priority and thread_switch.
 * 	[89/06/03            dlb]
 * 
 * 	Remove kern_timestamp.
 * 	[89/05/10            dlb]
 * 
 * Revision 2.7  89/05/06  02:58:15  rpd
 * 	Purged task_data and task_by_pid.
 * 	[89/05/05  20:52:13  rpd]
 * 
 * Revision 2.6  89/05/01  17:03:04  rpd
 * 	Added mach_sctimes_port_alloc_dealloc.
 * 	[89/05/01  14:11:38  rpd]
 * 
 * Revision 2.5  89/04/22  15:25:24  gm0w
 * 	Removed old MACH ctimes() system call.
 * 	[89/04/14            gm0w]
 * 
 * Revision 2.4  89/04/08  23:32:13  rpd
 * 	Removed InitPort, SoftEnable, MessagesWaiting, ns_port.
 * 	[89/03/14  14:56:32  rpd]
 * 
 * Revision 2.3  89/03/15  15:05:52  gm0w
 * 	14-Mar-89 Mary Thompson (mrt) at Carnegie-Mellon University
 * 	Removed definition of ns_port. It was not implementated and
 * 	conflicted with a mach_sctimes trap.
 * 
 * Revision 2.2  89/03/10  13:41:58  rpd
 * 	Created from kern/syscall_sw.h.
 * 
 */

#ifndef	_MACH_SYSCALL_SW_H_
#define _MACH_SYSCALL_SW_H_

/*
 *	The machine-dependent "syscall_sw.h" file should
 *	define a macro for
 *		kernel_trap(trap_name, trap_number, arg_count)
 *	which will expand into assembly code for the
 *	trap.
 *
 *	N.B.: When adding calls, do not put spaces in the macros.
 */

#include <:mach:machine:syscall_sw.h>

/*
 *	These trap numbers should be taken from the
 *	table in "../kern/syscall_sw.c".
 */

kernel_trap(task_self,-10,0)
kernel_trap(thread_reply,-11,0)
kernel_trap(task_notify,-12,0)
kernel_trap(thread_self,-13,0)
kernel_trap(msg_send_old,-14,3)
kernel_trap(msg_receive_old,-15,3)
kernel_trap(msg_rpc_old,-16,5)
kernel_trap(msg_send_trap,-20,4)
kernel_trap(msg_receive_trap,-21,5)
kernel_trap(msg_rpc_trap,-22,6)

kernel_trap(htg_unix_syscall,-52,3);

kernel_trap(inode_swap_preference,-40,3)
kernel_trap(init_process,-41,0)
kernel_trap(map_fd,-43,5)
kernel_trap(rfs_make_symlink,-44,3)
kernel_trap(mach_swapon,-45,4)

kernel_trap(host_self,-55,1)
kernel_trap(host_priv_self,-56,1)
kernel_trap(swtch_pri,-59,1)
kernel_trap(swtch,-60,0)
kernel_trap(thread_switch,-61,3)

kernel_trap(mach_sctimes_0,-70,0)
kernel_trap(mach_sctimes_1,-71,1)
kernel_trap(mach_sctimes_2,-72,2)
kernel_trap(mach_sctimes_3,-73,3)
kernel_trap(mach_sctimes_4,-74,4)
kernel_trap(mach_sctimes_5,-75,5)
kernel_trap(mach_sctimes_6,-76,6)

kernel_trap(mach_sctimes_7,-77,0)
kernel_trap(mach_sctimes_8,-78,6)

kernel_trap(mach_sctimes_9,-79,1)
kernel_trap(mach_sctimes_10,-80,2)
kernel_trap(mach_sctimes_11,-81,2)

kernel_trap(mach_sctimes_port_alloc_dealloc,-82,1)

#endif	_MACH_SYSCALL_SW_H_
@EOF@

echo "include/mach/task_info.h"
cat >include/mach/task_info.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	task_info.h,v $
 * Revision 2.4  89/03/09  20:23:59  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:06  gm0w
 * 	Changes for cleanup.
 * 
 * 15-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Created, based on old task_statistics.
 *
 */
/*
 *	Machine-independent task information structures and definitions.
 *
 *	The definitions in this file are exported to the user.  The kernel
 *	will translate its internal data structures to these structures
 *	as appropriate.
 *
 */

#ifndef	_MACH_TASK_INFO_H_
#define _MACH_TASK_INFO_H_

#include <:mach:machine:vm_types.h>
#include <:mach:time_value.h>

/*
 *	Generic information structure to allow for expansion.
 */
typedef	int	*task_info_t;		/* varying array of int */

#define TASK_INFO_MAX	(1024)		/* maximum array size */
typedef	int	task_info_data_t[TASK_INFO_MAX];

/*
 *	Currently defined information structures.
 */
#define TASK_BASIC_INFO		1	/* basic information */

struct task_basic_info {
	int		suspend_count;	/* suspend count for task */
	int		base_priority;	/* base scheduling priority */
	vm_size_t	virtual_size;	/* number of virtual pages */
	vm_size_t	resident_size;	/* number of resident pages */
	time_value_t	user_time;	/* total user run time for
					   terminated threads */
	time_value_t	system_time;	/* total system run time for
					   terminated threads */
};

typedef struct task_basic_info		task_basic_info_data_t;
typedef struct task_basic_info		*task_basic_info_t;
#define TASK_BASIC_INFO_COUNT	\
		(sizeof(task_basic_info_data_t) / sizeof(int))


#define TASK_EVENTS_INFO	2	/* various event counts */

struct task_events_info {
	long		faults;		/* number of page faults */
	long		zero_fills;	/* number of zero fill pages */
	long		reactivations;	/* number of reactivated pages */
	long		pageins;	/* number of actual pageins */
	long		cow_faults;	/* number of copy-on-write faults */
	long		messages_sent;	/* number of messages sent */
	long		messages_received; /* number of messages received */
};
typedef struct task_events_info		task_events_info_data_t;
typedef struct task_events_info		*task_events_info_t;
#define TASK_EVENTS_INFO_COUNT	\
		(sizeof(task_events_info_data_t) / sizeof(int))

#endif	_MACH_TASK_INFO_H_
@EOF@

echo "include/mach/task_special_ports.h"
cat >include/mach/task_special_ports.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	task_special_ports.h,v $
 * Revision 2.5  89/06/27  00:25:33  rpd
 * 	Added task_get_kernel_port, task_set_kernel_port.
 * 	[89/06/27  00:02:52  rpd]
 * 
 * Revision 2.4  89/03/09  20:24:06  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:12  gm0w
 * 	Changes for cleanup.
 * 
 * 17-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/task_special_ports.h
 *
 *	Defines codes for special_purpose task ports.  These are NOT
 *	port identifiers - they are only used for the task_get_special_port
 *	and task_set_special_port routines.
 *	
 */

#ifndef	_MACH_TASK_SPECIAL_PORTS_H_
#define _MACH_TASK_SPECIAL_PORTS_H_

#define TASK_KERNEL_PORT	1	/* Represents task to the outside
					   world.*/
#define TASK_NOTIFY_PORT	2	/* Task receives kernel IPC
					   notifications here. */
#define TASK_EXCEPTION_PORT	3	/* Exception messages for task are
					   sent to this port. */
#define TASK_BOOTSTRAP_PORT	4	/* Bootstrap environment for task. */

/*
 *	Definitions for ease of use
 */

#define task_get_kernel_port(task, port)	\
		(task_get_special_port((task), TASK_KERNEL_PORT, (port)))

#define task_set_kernel_port(task, port)	\
		(task_set_special_port((task), TASK_KERNEL_PORT, (port)))

#define task_get_notify_port(task, port)	\
		(task_get_special_port((task), TASK_NOTIFY_PORT, (port)))

#define task_set_notify_port(task, port)	\
		(task_set_special_port((task), TASK_NOTIFY_PORT, (port)))

#define task_get_exception_port(task, port)	\
		(task_get_special_port((task), TASK_EXCEPTION_PORT, (port)))

#define task_set_exception_port(task, port)	\
		(task_set_special_port((task), TASK_EXCEPTION_PORT, (port)))

#define task_get_bootstrap_port(task, port)	\
		(task_get_special_port((task), TASK_BOOTSTRAP_PORT, (port)))

#define task_set_bootstrap_port(task, port)	\
		(task_set_special_port((task), TASK_BOOTSTRAP_PORT, (port)))

#endif	_MACH_TASK_SPECIAL_PORTS_H_
@EOF@

echo "include/mach/thread_info.h"
cat >include/mach/thread_info.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_info.h,v $
 * Revision 2.6  89/10/11  14:41:37  dlb
 * 	Add scheduling information.
 * 	[89/05/18            dlb]
 * 
 * Revision 2.5  89/03/09  20:24:12  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:41:18  gm0w
 * 	Changes for cleanup.
 * 
 *  4-Mar-88  David Black (dlb) at Carnegie-Mellon University
 *	Added TH_USAGE_SCALE for cpu_usage field.
 *
 * 15-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Changed to generic interface (variable-length array) to allow
 *	for expansion.  Renamed to thread_info.
 *
 *  1-Jun-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/thread_info
 *
 *	Thread information structure and definitions.
 *
 *	The defintions in this file are exported to the user.  The kernel
 *	will translate its internal data structures to these structures
 *	as appropriate.
 *
 */

#ifndef	_MACH_THREAD_INFO_H_
#define _MACH_THREAD_INFO_H_

#include <:mach:policy.h>
#include <:mach:time_value.h>

/*
 *	Generic information structure to allow for expansion.
 */
typedef	int	*thread_info_t;		/* varying array of int */

#define THREAD_INFO_MAX		(1024)	/* maximum array size */
typedef	int	thread_info_data_t[THREAD_INFO_MAX];

/*
 *	Currently defined information.
 */
#define THREAD_BASIC_INFO	1		/* basic information */

struct thread_basic_info {
	time_value_t	user_time;	/* user run time */
	time_value_t	system_time;	/* system run time */
	int		cpu_usage;	/* scaled cpu usage percentage */
	int		base_priority;	/* base scheduling priority */
	int		cur_priority;	/* current scheduling priority */
	int		run_state;	/* run state (see below) */
	int		flags;		/* various flags (see below) */
	int		suspend_count;	/* suspend count for thread */
	long		sleep_time;	/* number of seconds that thread
					   has been sleeping */
};

typedef struct thread_basic_info	thread_basic_info_data_t;
typedef struct thread_basic_info	*thread_basic_info_t;
#define THREAD_BASIC_INFO_COUNT	\
		(sizeof(thread_basic_info_data_t) / sizeof(int))

/*
 *	Scale factor for usage field.
 */

#define TH_USAGE_SCALE	1000

/*
 *	Thread run states (state field).
 */

#define TH_STATE_RUNNING	1	/* thread is running normally */
#define TH_STATE_STOPPED	2	/* thread is stopped */
#define TH_STATE_WAITING	3	/* thread is waiting normally */
#define TH_STATE_UNINTERRUPTIBLE 4	/* thread is in an uninterruptible
					   wait */
#define TH_STATE_HALTED		5	/* thread is halted at a
					   clean point */

/*
 *	Thread flags (flags field).
 */
#define TH_FLAGS_SWAPPED	0x1	/* thread is swapped out */
#define TH_FLAGS_IDLE		0x2	/* thread is an idle thread */

#define THREAD_SCHED_INFO	2

struct thread_sched_info {
	int		policy;		/* scheduling policy */
	int		data;		/* associated data */
	int		base_priority;	/* base priority */
	int		max_priority;   /* max priority */
	int		cur_priority;	/* current priority */
	boolean_t	depressed;	/* depressed ? */
	int		depress_priority; /* priority depressed from */
};

typedef struct thread_sched_info	thread_sched_info_data_t;
typedef struct thread_sched_info	*thread_sched_info_t;
#define	THREAD_SCHED_INFO_COUNT	\
		(sizeof(thread_sched_info_data_t) / sizeof(int))

#endif	_MACH_THREAD_INFO_H_
@EOF@

echo "include/mach/thread_special_ports.h"
cat >include/mach/thread_special_ports.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_special_ports.h,v $
 * Revision 2.5  89/06/27  00:25:37  rpd
 * 	Added thread_get_kernel_port, thread_set_kernel_port.
 * 	[89/06/27  00:03:21  rpd]
 * 
 * Revision 2.4  89/03/09  20:24:17  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:23  gm0w
 * 	Changes for cleanup.
 * 
 * 17-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/thread_special_ports.h
 *
 *	Defines codes for special_purpose thread ports.  These are NOT
 *	port identifiers - they are only used for the thread_get_special_port
 *	and thread_set_special_port routines.
 *	
 */

#ifndef	_MACH_THREAD_SPECIAL_PORTS_H_
#define _MACH_THREAD_SPECIAL_PORTS_H_

#define THREAD_KERNEL_PORT	1	/* Represents the thread to the outside
					   world.*/
#define THREAD_REPLY_PORT	2	/* Default reply port for the thread's
					   use. */
#define THREAD_EXCEPTION_PORT	3	/* Exception messages for the thread
					   are sent to this port. */

/*
 *	Definitions for ease of use
 */

#define thread_get_kernel_port(thread, port)	\
		(thread_get_special_port((thread), THREAD_KERNEL_PORT, (port)))

#define thread_set_kernel_port(thread, port)	\
		(thread_set_special_port((thread), THREAD_KERNEL_PORT, (port)))

#define thread_get_reply_port(thread, port)	\
		(thread_get_special_port((thread), THREAD_REPLY_PORT, (port)))

#define thread_set_reply_port(thread, port)	\
		(thread_set_special_port((thread), THREAD_REPLY_PORT, (port)))

#define thread_get_exception_port(thread, port)	\
		(thread_get_special_port((thread), THREAD_EXCEPTION_PORT, (port)))

#define thread_set_exception_port(thread, port)	\
		(thread_set_special_port((thread), THREAD_EXCEPTION_PORT, (port)))

#endif	_MACH_THREAD_SPECIAL_PORTS_H_
@EOF@

echo "include/mach/thread_status.h"
cat >include/mach/thread_status.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_status.h,v $
 * Revision 2.5  89/03/09  20:24:23  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:41:29  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  00:53:47  mwyoung
 * Relocated from mach/thread_status.h
 * 
 * Revision 2.2  88/08/25  18:21:12  mwyoung
 * 	Adjusted include file references.
 * 	[88/08/16  04:16:13  mwyoung]
 * 	
 * 	Add THREAD_STATE_FLAVOR_LIST; remove old stuff.
 * 	[88/08/11  18:49:48  mwyoung]
 * 
 *
 * 15-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Replaced with variable-length array for flexibile interface.
 *
 * 28-Apr-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Latest hacks to keep MiG happy wrt refarrays.
 *
 * 27-Mar-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/thread_status.h
 *	Author:	Avadis Tevanian, Jr.
 *
 *	This file contains the structure definitions for the user-visible
 *	thread state.  This thread state is examined with the thread_get_state
 *	kernel call and may be changed with the thread_set_state kernel call.
 *
 */

#ifndef	_MACH_THREAD_STATUS_H_
#define _MACH_THREAD_STATUS_H_

/*
 *	The actual structure that comprises the thread state is defined
 *	in the machine dependent module.
 */
#include <:mach:machine:thread_status.h>

/*
 *	Generic definition for machine-dependent thread status.
 */

typedef	int		*thread_state_t;	/* Variable-length array */

#define THREAD_STATE_MAX	(1024)		/* Maximum array size */
typedef	int	thread_state_data_t[THREAD_STATE_MAX];

#define THREAD_STATE_FLAVOR_LIST	0	/* List of valid flavors */

#endif	_MACH_THREAD_STATUS_H_
@EOF@

echo "include/mach/thread_switch.h"
cat >include/mach/thread_switch.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_switch.h,v $
 * Revision 2.3  89/10/15  02:06:04  rpd
 * 	Minor cleanups.
 * 
 * Revision 2.2  89/10/11  14:41:47  dlb
 * 	Merge.
 * 	[89/09/01  17:57:58  dlb]
 * 
 * Revision 2.1.1.2  89/08/02  23:12:52  dlb
 * 	Merge to X96
 * 
 * Revision 2.1.1.1  89/07/25  19:05:41  dlb
 * 	Created.
 * 
 */

#ifndef	_MACH_THREAD_SWITCH_H_
#define	_MACH_THREAD_SWITCH_H_

/*
 *	Constant definitions for thread_switch trap.
 */

#define	SWITCH_OPTION_NONE	0
#define SWITCH_OPTION_DEPRESS	1
#define SWITCH_OPTION_WAIT	2

#define valid_switch_option(opt)	((0 <= (opt)) && ((opt) <= 2))

#endif	_MACH_THREAD_SWITCH_H_
@EOF@

echo "include/mach/time_value.h"
cat >include/mach/time_value.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	time_value.h,v $
 * Revision 2.5  89/03/09  20:24:28  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:41:34  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  00:53:58  mwyoung
 * Relocated from sys/time_value.h
 * 
 * Revision 2.2  89/01/31  01:21:58  rpd
 * 	TIME_MICROS_MAX should be 1 Million, not 10 Million.
 * 	[88/10/12            dlb]
 * 
 *  4-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Created.
 *
 */

#ifndef	_MACH_TIME_VALUE_H_
#define _MACH_TIME_VALUE_H_

/*
 *	Time value returned by kernel.
 */

struct time_value {
	long	seconds;
	long	microseconds;
};
typedef	struct time_value	time_value_t;

/*
 *	Macros to manipulate time values.  Assume that time values
 *	are normalized (microseconds <= 999999).
 */
#define TIME_MICROS_MAX	(1000000)

#define time_value_add_usec(val, micros)	{	\
	if (((val)->microseconds += (micros))		\
		>= TIME_MICROS_MAX) {			\
	    (val)->microseconds -= TIME_MICROS_MAX;	\
	    (val)->seconds++;				\
	}						\
}

#define time_value_add(result, addend)		{		\
	(result)->microseconds += (addend)->microseconds;	\
	(result)->seconds += (addend)->seconds;			\
	if ((result)->microseconds >= TIME_MICROS_MAX) {	\
	    (result)->microseconds -= TIME_MICROS_MAX;		\
	    (result)->seconds++;				\
	}							\
}

#endif	_MACH_TIME_VALUE_H_
@EOF@

echo "include/mach/vm_attributes.h"
cat >include/mach/vm_attributes.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_attributes.h,v $
 * Revision 2.2  90/03/08  23:11:08  af
 * 	.
 * 	[90/01/21  13:05:49  af]
 * 
 * 	Created.
 * 	[89/12/08            af]
 * 
 *
 */
/*
 *	File:	mach/vm_attributes.h
 *	Author:	Alessandro Forin
 *
 *	Virtual memory attributes definitions.
 *
 *	These definitions are in addition to the machine-independent
 *	ones (e.g. protection), and are only selectively supported
 *	on specific machine architectures.
 *
 */

#ifndef	VM_ATTRIBUTES_H_
#define	VM_ATTRIBUTES_H_

/*
 *	Types of machine-dependent attributes
 */
typedef unsigned int	vm_machine_attribute_t;

#define	MATTR_CACHE		1	/* cachability */
#define MATTR_MIGRATE		2	/* migrability */
#define	MATTR_REPLICATE		4	/* replicability */

/*
 *	Values for the above, e.g. operations on attribute
 */
typedef int		vm_machine_attribute_val_t;

#define MATTR_VAL_OFF		0	/* (generic) turn attribute off */
#define MATTR_VAL_ON		1	/* (generic) turn attribute on */
#define MATTR_VAL_GET		2	/* (generic) return current value */

#define MATTR_VAL_CACHE_FLUSH	6	/* flush from all caches */
#define MATTR_VAL_DCACHE_FLUSH	7	/* flush from data caches */
#define MATTR_VAL_ICACHE_FLUSH	8	/* flush from instruction caches */

#endif	VM_ATTRIBUTES_H_
@EOF@

echo "include/mach/vm_inherit.h"
cat >include/mach/vm_inherit.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_inherit.h,v $
 * Revision 2.4  89/03/09  20:25:13  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:42:18  gm0w
 * 	Changes for cleanup.
 * 
 * 16-Sep-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/vm_inherit.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Copyright (C) 1985, Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Virtual memory map inheritance definitions.
 *
 */

#ifndef	_MACH_VM_INHERIT_H_
#define _MACH_VM_INHERIT_H_

/*
 *	Types defined:
 *
 *	vm_inherit_t	inheritance codes.
 */

typedef int		vm_inherit_t;	/* might want to change this */

/*
 *	Enumeration of valid values for vm_inherit_t.
 */

#define VM_INHERIT_SHARE	((vm_inherit_t) 0)	/* share with child */
#define VM_INHERIT_COPY		((vm_inherit_t) 1)	/* copy into child */
#define VM_INHERIT_NONE		((vm_inherit_t) 2)	/* absent from child */
#define VM_INHERIT_DONATE_COPY	((vm_inherit_t) 3)	/* copy and delete */

#define VM_INHERIT_DEFAULT	VM_INHERIT_COPY

#endif	_MACH_VM_INHERIT_H_
@EOF@

echo "include/mach/vm_param.h"
cat >include/mach/vm_param.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_param.h,v $
 * Revision 2.6  89/10/10  13:36:45  mwyoung
 * 	Use PAGE_SIZE_FIXED to permit PAGE_SIZE (and PAGE_SHIFT) to be
 * 	defined to be constants.
 * 
 * 	Add page_aligned.
 * 
 * 	Prevent this file from being used outside the kernel.  It was a
 * 	serious mistake to ever allow it to be put in the <mach/>
 * 	directory.  This is the first step in returning it to <vm/>.
 * 	[89/10/10            mwyoung]
 * 
 * Revision 2.5  89/05/20  11:16:42  mrt
 * 	Moved non-kernel round_page and trunc_page  macros from here to
 * 	mach_init.h
 * 	[89/05/19            mrt]
 */
/*
 *	File:	mach/vm_param.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Copyright (C) 1985, Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Machine independent virtual memory parameters.
 *
 */

#ifndef	_MACH_VM_PARAM_H_
#define _MACH_VM_PARAM_H_

#ifndef	KERNEL

;YOU HAVE MADE A MISTAKE BY INCLUDING THIS FILE;

THIS FILE SHOULD NOT BE VISIBLE TO USER PROGRAMS.

USE <mach/machine/vm_param.h> TO GET MACHINE-DEPENDENT ADDRESS
SPACE AND PAGE SIZE ITEMS.

USE <mach/machine/vm_types.h> TO GET TYPE DECLARATIONS USED IN
THE MACH KERNEL INTERFACE.

IN ALL PROBABILITY, YOU SHOULD GET ALL OF THE TYPES USED IN THE
INTERFACE FROM <mach/mach_types.h>

#endif	KERNEL

#include <:mach:machine:vm_param.h>
#include <:mach:machine:vm_types.h>

/*
 *	The machine independent pages are refered to as PAGES.  A page
 *	is some number of hardware pages, depending on the target machine.
 */

/*
 *	All references to the size of a page should be done with PAGE_SIZE
 *	or PAGE_SHIFT.  The fact they are variables is hidden here so that
 *	we can easily make them constant if we so desire.
 */

/*
 *	Regardless whether it is implemented with a constant or a variable,
 *	the PAGE_SIZE is assumed to be a power of two throughout the
 *	virtual memory system implementation.
 */

#ifndef	PAGE_SIZE_FIXED
#define PAGE_SIZE	page_size	/* size of page in addressible units */
#define PAGE_SHIFT	page_shift	/* number of bits to shift for pages */
#endif	PAGE_SIZE_FIXED

#ifndef	ASSEMBLER
/*
 *	Convert addresses to pages and vice versa.
 *	No rounding is used.
 */

#define atop(x)		(((unsigned)(x)) >> page_shift)
#define ptoa(x)		((vm_offset_t)((x) << page_shift))

/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.
 */

#define round_page(x)	((vm_offset_t)((((vm_offset_t)(x)) + page_mask) & ~page_mask))
#define trunc_page(x)	((vm_offset_t)(((vm_offset_t)(x)) & ~page_mask))

/*
 *	Determine whether an address is page-aligned, or a count is
 *	an exact page multiple.
 */

#define	page_aligned(x)	((((vm_offset_t) (x)) & page_mask) == 0)

#ifndef	PAGE_SIZE_FIXED
extern vm_size_t	page_size;	/* machine independent page size */
extern vm_size_t	page_mask;	/* page_size - 1; mask for
						   offset within page */
extern int		page_shift;	/* shift to use for page size */
#else	PAGE_SIZE_FIXED
#define	page_mask	(PAGE_SIZE-1)
#endif	PAGE_SIZE_FIXED

extern vm_size_t	mem_size;	/* size of physical memory (bytes) */
extern vm_offset_t	first_addr;	/* first physical page */
extern vm_offset_t	last_addr;	/* last physical page */

#endif	ASSEMBLER
#endif	_MACH_VM_PARAM_H_
@EOF@

echo "include/mach/vm_prot.h"
cat >include/mach/vm_prot.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_prot.h,v $
 * Revision 2.4  89/03/09  20:25:24  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:42:29  gm0w
 * 	Changes for cleanup.
 * 
 *  6-Jun-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/vm_prot.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Copyright (C) 1985, Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Virtual memory protection definitions.
 *
 */

#ifndef	_MACH_VM_PROT_H_
#define _MACH_VM_PROT_H_

/*
 *	Types defined:
 *
 *	vm_prot_t		VM protection values.
 */

typedef int		vm_prot_t;

/*
 *	Protection values, defined as bits within the vm_prot_t type
 */

#define VM_PROT_NONE	((vm_prot_t) 0x00)

#define VM_PROT_READ	((vm_prot_t) 0x01)	/* read permission */
#define VM_PROT_WRITE	((vm_prot_t) 0x02)	/* write permission */
#define VM_PROT_EXECUTE	((vm_prot_t) 0x04)	/* execute permission */

/*
 *	The default protection for newly-created virtual memory
 */

#define VM_PROT_DEFAULT	(VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE)

/*
 *	The maximum privileges possible, for parameter checking.
 */

#define VM_PROT_ALL	(VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE)

#endif	_MACH_VM_PROT_H_
@EOF@

echo "include/mach/vm_statistics.h"
cat >include/mach/vm_statistics.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_statistics.h,v $
 * Revision 2.5  89/03/09  20:25:29  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:42:35  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  00:54:39  mwyoung
 * Relocated from sys/vm_statistics.h
 * 
 * Revision 2.2  89/01/30  22:08:54  rpd
 * 	Made variable declarations use "extern".
 * 	[89/01/25  15:26:30  rpd]
 * 
 * 30-Sep-86  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Changed "reclaim" to "inactive."
 *
 * 22-Aug-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Made vm_stat structure kernel-only.
 *
 * 22-May-86  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Defined vm_statistics_data_t as a real typedef so that
 *	MatchMaker can deal with it.
 *
 * 14-Feb-86  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/vm_statistics.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young, David Golub
 *	Copyright (C) 1986, Avadis Tevanian, Jr., Michael Wayne Young,
 *		David Golub
 *
 *	Virtual memory statistics structure.
 *
 */

#ifndef	_MACH_VM_STATISTICS_H_
#define _MACH_VM_STATISTICS_H_

struct vm_statistics {
	long	pagesize;		/* page size in bytes */
	long	free_count;		/* # of pages free */
	long	active_count;		/* # of pages active */
	long	inactive_count;		/* # of pages inactive */
	long	wire_count;		/* # of pages wired down */
	long	zero_fill_count;	/* # of zero fill pages */
	long	reactivations;		/* # of pages reactivated */
	long	pageins;		/* # of pageins */
	long	pageouts;		/* # of pageouts */
	long	faults;			/* # of faults */
	long	cow_faults;		/* # of copy-on-writes */
	long	lookups;		/* object cache lookups */
	long	hits;			/* object cache hits */
};

typedef struct vm_statistics	*vm_statistics_t;
typedef struct vm_statistics	vm_statistics_data_t;

#ifdef	KERNEL
extern vm_statistics_data_t	vm_stat;
#endif	KERNEL

/*
 *	Each machine dependent implementation is expected to
 *	keep certain statistics.  They may do this anyway they
 *	so choose, but are expected to return the statistics
 *	in the following structure.
 */

struct pmap_statistics {
	long		resident_count;	/* # of pages mapped (total)*/
	long		wired_count;	/* # of pages wired */
};

typedef struct pmap_statistics	*pmap_statistics_t;

#endif	_MACH_VM_STATISTICS_H_
@EOF@

echo "include/mach/mac2/boolean.h"
cat >include/mach/mac2/boolean.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	boolean.h,v $
 * Revision 2.2  90/08/30  17:48:42  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/boolean.h
 */

#ifndef	_MACH_MAC2_BOOLEAN_H_
#define	_MACH_MAC2_BOOLEAN_H_

typedef int		boolean_t;

#endif	_MACH_MAC2_BOOLEAN_H_
@EOF@

echo "include/mach/mac2/exception.h"
cat >include/mach/mac2/exception.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exception.h,v $
 * Revision 2.2  90/08/30  17:49:35  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/exeception.h
 */

#ifndef _MACH_MAC2_EXCEPTION_H_
#define _MACH_MAC2_EXCEPTION_H_

/*
 * Machine dependent exception definitions for the Macintosh II.
 */

/*
 * EXC_BAD_INSTRUCTION
 */
#define	EXC_MAC2_ILLEGAL_INSTRUCTION	0x10
#define EXC_MAC2_PRIVILEGE_VIOLATION	0x20
#define EXC_MAC2_COPROCESSOR		0x34
#define EXC_MAC2_TRAP0			0x80
#define EXC_MAC2_TRAP1			0x84
#define EXC_MAC2_TRAP2			0x88
#define EXC_MAC2_TRAP3			0x8c
#define EXC_MAC2_TRAP4			0x90
#define EXC_MAC2_TRAP5			0x94
#define EXC_MAC2_TRAP6			0x98
#define EXC_MAC2_TRAP7			0x9c
#define EXC_MAC2_TRAP8			0xa0
#define EXC_MAC2_TRAP9			0xa4
#define EXC_MAC2_TRAP10			0xa8
#define EXC_MAC2_TRAP11			0xac
#define EXC_MAC2_TRAP12			0xb0
#define EXC_MAC2_TRAP13			0xb4
#define EXC_MAC2_TRAP14			0xb8
#define EXC_MAC2_TRAP15			0xbc
#define EXC_MAC2_FLT_BSUN		0xc0
#define EXC_MAC2_FLT_OPERAND_ERROR	0xd0

/*
 * EXC_ARITHMETIC
 */
#define EXC_MAC2_ZERO_DIVIDE		0x14
#define EXC_MAC2_FLT_INEXACT		0xc4
#define EXC_MAC2_FLT_ZERO_DIVIDE	0xc8
#define EXC_MAC2_FLT_UNDERFLOW		0xcc
#define EXC_MAC2_FLT_OVERFLOW		0xd4
#define EXC_MAC2_FLT_NOT_A_NUMBER	0xd8

/*
 * EXC_EMULATION
 */
#define EXC_MAC2_LINE_1010		0x28
#define EXC_MAC2_LINE_1111		0x2c

/*
 * EXC_SOFTWARE
 */
#define	EXC_MAC2_CHK			0x18
#define EXC_MAC2_TRAPV			0x1c

/*
 * EXC_BREAKPOINT
 */
#define EXC_MAC2_TRACE			0x24
#define EXC_MAC2_BREAKPOINT		0xbc

#endif	_MACH_MAC2_EXCEPTION_H_
@EOF@

echo "include/mach/mac2/frame.h"
cat >include/mach/mac2/frame.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	frame.h,v $
 * Revision 2.2.1.1  90/09/07  00:55:15  bohman
 * 	Final cleanup.
 * 	[90/09/07            bohman]
 * 
 * Revision 2.2  90/08/30  17:50:12  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/frame.h
 *	Author: David E. Bohman II (CMU macmach)
 */

#ifndef _MACH_MAC2_FRAME_H_
#define _MACH_MAC2_FRAME_H_

/*
 * MC68020/30 exception frames
 */

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
} normal_exception_frame_t;
#define STKFMT_NORMAL 0x0
#define NORMAL_EXCEPTION_FRAME_SIZE	sizeof (normal_exception_frame_t)

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned long f_instpc;
} special_exception_frame_t;
#define STKFMT_SPECIAL 0x2
#define SPECIAL_EXCEPTION_FRAME_SIZE	sizeof (special_exception_frame_t)

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned long f_instpc;
    unsigned long f_internal;
    unsigned long f_eea;
} coproc_exception_frame_t;
#define STKFMT_COPROC 0x9
#define COPROC_EXCEPTION_FRAME_SIZE	sizeof (coproc_exception_frame_t)

#define BUSERR_READ  1
#define BUSERR_WRITE 0

#define BUSERR_SIZE_LONG 0
#define BUSERR_SIZE_BYTE 1
#define BUSERR_SIZE_WORD 2

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned short f_internal;
    struct {
	unsigned short ssw_faultc:1,
		       ssw_faultb:1,
		       ssw_rerunc:1,
		       ssw_rerunb:1,
				 :3,
		       ssw_dfault:1,
			  ssw_rmw:1,
			   ssw_rw:1,
			 ssw_size:2,
				 :1,
			ssw_fcode:3;
    } f_ssw;
#define f_faultc f_ssw.ssw_faultc
#define f_faultb f_ssw.ssw_faultb
#define f_rerunc f_ssw.ssw_rerunc
#define f_rerunb f_ssw.ssw_rerunb
#define f_dfault f_ssw.ssw_dfault
#define f_rmw    f_ssw.ssw_rmw
#define f_rw     f_ssw.ssw_rw
#define f_size   f_ssw.ssw_size
#define f_fcode  f_ssw.ssw_fcode
    unsigned short f_ipsc;
    unsigned short f_ipsb;
    unsigned long f_fault;
    unsigned long f_internal2;
    unsigned long f_dob;
    unsigned long f_internal3;
} short_buserr_exception_frame_t;
#define STKFMT_SHORT_BUSERR 0xA
#define SHORT_BUSERR_EXCEPTION_FRAME_SIZE \
	sizeof (short_buserr_exception_frame_t)

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned short f_internal;
    struct {
	unsigned short ssw_faultc:1,
		       ssw_faultb:1,
		       ssw_rerunc:1,
		       ssw_rerunb:1,
				 :3,
		       ssw_dfault:1,
			  ssw_rmw:1,
			   ssw_rw:1,
			 ssw_size:2,
				 :1,
			ssw_fcode:3;
    } f_ssw;
    unsigned short f_ipsc;
    unsigned short f_ipsb;
    unsigned long f_fault;
    unsigned long f_internal2;
    unsigned long f_dob;
    unsigned long f_internal3;
    unsigned long f_internal4;
    unsigned long f_stageb;
    unsigned long f_internal5;
    unsigned long f_dib;
    unsigned long f_internal6[11];
} long_buserr_exception_frame_t;
#define STKFMT_LONG_BUSERR 0xB
#define LONG_BUSERR_EXCEPTION_FRAME_SIZE \
	sizeof (long_buserr_exception_frame_t)

/*
 * Generic exception frame
 */
typedef union {
    normal_exception_frame_t	f_normal;
    special_exception_frame_t	f_special;
    coproc_exception_frame_t	f_coproc;
    short_buserr_exception_frame_t
				f_short_buserr;
    long_buserr_exception_frame_t
				f_long_buserr;
} generic_exception_frame_t;

#endif	_MACH_MAC2_FRAME_H_
@EOF@

echo "include/mach/mac2/kern_return.h"
cat >include/mach/mac2/kern_return.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	kern_return.h,v $
 * Revision 2.2  90/08/30  17:50:36  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/kern_return.h
 */

#ifndef	_MACH_MAC2_KERN_RETURN_H_
#define	_MACH_MAC2_KERN_RETURN_H_

typedef	int		kern_return_t;

#endif	_MACH_MAC2_KERN_RETURN_H_
@EOF@

echo "include/mach/mac2/reg.h"
cat >include/mach/mac2/reg.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	reg.h,v $
 * Revision 2.2.1.1  90/09/07  00:54:19  bohman
 * 	Final cleanup.
 * 	[90/09/07            bohman]
 * 
 * Revision 2.2  90/09/04  17:13:05  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/reg.h
 *	Author: David E. Bohman II (CMU macmach)
 */

#ifndef _MACH_MAC2_REG_H_
#define _MACH_MAC2_REG_H_

/*
 * Format of saved 68020/30
 * processor registers.
 */
typedef struct regs {
    int	r_dreg[8];		/* data registers */
#define r_r0 r_dreg[0]
#define r_r1 r_dreg[1]
    int	r_areg[8];		/* address registers */
#define r_sp	r_areg[7]
} regs_t;

/*
 * Format of 68881/2 floating
 * point register.
 */
typedef	struct {
    unsigned long	fp[3];
} fp_reg_t;

/*
 * Total register state for the FPU.
 */
typedef struct {
    fp_reg_t		fps_regs[8];		/* floating point regs */
    unsigned long	fps_control;		/* control reg */
    unsigned long	fps_status;		/* status reg */
    unsigned long	fps_iaddr;		/* instr address reg */
} fp_state_t;

/*
 * Internal state for the FPU.
 */
#define FPF_NULL_SIZE	0
#define FPF_IDLE_SIZE	0x18
#define FPF_BUSY_SIZE	0xd4

typedef union {
    unsigned long	fpf_format;		/* format word */
    struct {
	unsigned char	fpff_version;		/* version number */
	unsigned char	fpff_size;		/* size of frame */
	unsigned short	fpff_mbz;
	union {
	    struct {
		unsigned short	fpffi_ccr;	/* command/cond register */
		unsigned short	fpffi_mbo;
		unsigned char	fpffi_opnd[12];	/* exceptional operand */
		unsigned long	fpffi_opnd_reg;	/* operand register */
		unsigned long	fpffi_biu_flgs;	/* biu flags */
	    } fpffs_idle_data;
	    unsigned char	fpffs_busy_data[FPF_BUSY_SIZE];
	} fpff_extra;
    } fpf_frame;
} fp_frame_t;
#define fpf_version	fpf_frame.fpff_version
#define fpf_size	fpf_frame.fpff_size
#define fpf_data	fpf_frame.fpff_extra

#endif _MACH_MAC2_REG_H_
@EOF@

echo "include/mach/mac2/syscall_sw.h"
cat >include/mach/mac2/syscall_sw.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	syscall_sw.h,v $
 * Revision 2.2  90/08/30  17:51:32  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/syscall_sw.h
 */

#ifndef	_MACH_MAC2_SYSCALL_SW_H_
#define _MACH_MAC2_SYSCALL_SW_H_

#define kernel_trap(trap_name, trap_number, number_args) \
	.globl	_##trap_name; \
 _##trap_name: \
	pea	trap_number; \
	trap	\#0; \
	rts

#endif	_MACH_MAC2_SYSCALL_SW_H_
@EOF@

echo "include/mach/mac2/thread_status.h"
cat >include/mach/mac2/thread_status.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_status.h,v $
 * Revision 2.2.1.1  90/09/07  00:53:12  bohman
 * 	Final cleanup.
 * 	[90/09/07            bohman]
 * 
 * Revision 2.2  90/08/30  17:51:48  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/thread_status.h
 *	Author: David E. Bohman II (CMU macmach)
 */

/*
 * This file contains the structure definitions for the thread
 * state as applied to Macintosh II computers 68020/30 with 68881/2.
 */

#ifndef	_MACH_MAC2_THREAD_STATUS_H_
#define	_MACH_MAC2_THREAD_STATUS_H_

#include <:mach:mac2:reg.h>
#include <:mach:mac2:frame.h>

/*
 * Thread processor registers.
 */
#define	THREAD_STATE_REGS	1

typedef regs_t	thread_state_regs_t;
#define	THREAD_STATE_REGS_COUNT		\
    (sizeof(thread_state_regs_t)/sizeof (long))

/*
 * Thread fpu registers.
 */
#define THREAD_STATE_FPREGS	2

typedef fp_state_t	thread_state_fpregs_t;
#define THREAD_STATE_FPREGS_COUNT	\
    (sizeof (thread_state_fpregs_t)/sizeof (long))

/*
 * Thread processor state frame.
 */
#define THREAD_STATE_FRAME	3

typedef generic_exception_frame_t	thread_state_frame_t;
#define THREAD_STATE_FRAME_COUNT	\
    (sizeof (thread_state_frame_t)/sizeof (long))

/*
 * Thread fpu state frame.
 */
#define THREAD_STATE_FPFRAME	4

typedef fp_frame_t	thread_state_fpframe_t;
#define THREAD_STATE_FPFRAME_COUNT	\
    (sizeof (thread_state_fpframe_t)/sizeof (long))

#endif	_MACH_MAC2_THREAD_STATUS_H_
@EOF@

echo "include/mach/mac2/vm_param.h"
cat >include/mach/mac2/vm_param.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_param.h,v $
 * Revision 2.2  90/08/30  17:52:05  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/vm_param.h
 *	Author: David E. Bohman II (CMU macmach)
 */

#ifndef _MACH_MAC2_VM_PARAM_H_
#define _MACH_MAC2_VM_PARAM_H_

#include <:mac2:machparam.h>

#define BYTE_SIZE	8	/* byte size in bits */

#define MAC2_PGBYTES	8192	/* bytes per page */
#define MAC2_PGSHIFT	13	/* number of bits to shift for pages */

/*
 *	Convert bytes to pages and convert pages to bytes.
 *	No rounding is used.
 */

#define	mac2_btop(x)		(((unsigned)(x)) >> MAC2_PGSHIFT)
#define	mac2_ptob(x)		(((unsigned)(x)) << MAC2_PGSHIFT)

/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.
 */

#define mac2_round_page(x)	((((unsigned)(x)) + MAC2_PGBYTES - 1) & \
					~(MAC2_PGBYTES-1))
#define mac2_trunc_page(x)	(((unsigned)(x)) & ~(MAC2_PGBYTES-1))

/*
 * Macintosh II implementation
 * uses separate user and
 * kernel address spaces.
 *
 */
#define	VM_MIN_ADDRESS	((vm_offset_t) 0)
#define	VM_MAX_ADDRESS	((vm_offset_t) 0xffffffff)

#define VM_MIN_KERNEL_ADDRESS	((vm_offset_t) 0x0)
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t) 0xffffffff)

#define	KERNEL_STACK_SIZE	MAC2_PGBYTES

#define INTSTACK_SIZE		MAC2_PGBYTES

/*
 *	Conversion between mac2 pages and VM pages
 */

#define trunc_mac2_to_vm(p)	(atop(trunc_page(mac2_ptob(p))))
#define round_mac2_to_vm(p)	(atop(round_page(mac2_ptob(p))))
#define vm_to_mac2(p)		(mac2_btop(ptoa(p)))

#endif	_MACH_MAC2_VM_PARAM_H_
@EOF@

echo "include/mach/mac2/vm_types.h"
cat >include/mach/mac2/vm_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_types.h,v $
 * Revision 2.2  90/08/30  17:52:27  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/vm_types.h
 */

#ifndef	_MACH_MAC2_VM_TYPES_H_
#define	_MACH_MAC2_VM_TYPES_H_

#ifdef	ASSEMBLER
#else	ASSEMBLER
typedef	unsigned int	vm_offset_t;
typedef	unsigned int	vm_size_t;
#endif	ASSEMBLER

#endif	_MACH_MAC2_VM_TYPES_H_
@EOF@

echo "include/mach/sun3/boolean.h"
cat >include/mach/sun3/boolean.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	boolean.h,v $
 * Revision 2.4  89/03/09  20:23:21  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:40:28  gm0w
 * 	Changes for cleanup.
 * 
 * 24-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 *
 *	Boolean type, for Sun.
 *
 */

#ifndef	_MACH_SUN3_BOOLEAN_H_
#define _MACH_SUN3_BOOLEAN_H_

typedef int		boolean_t;

#endif	_MACH_SUN3_BOOLEAN_H_
@EOF@

echo "include/mach/sun3/exception.h"
cat >include/mach/sun3/exception.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exception.h,v $
 * Revision 2.4  89/03/09  20:23:26  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:40:34  gm0w
 * 	Changes for cleanup.
 * 
 * 28-Oct-87  David Black (dlb) at Carnegie-Mellon University
 *	Created.
 *
 */

/*
 *	Machine dependent exception definitions for the Sun3.
 */

#ifndef	_MACH_SUN3_EXCEPTION_H_
#define _MACH_SUN3_EXCEPTION_H_

/*
 *	EXC_BAD_INSTRUCTION
 */

#define EXC_SUN3_ILLEGAL_INSTRUCTION	0x10
#define EXC_SUN3_PRIVILEGE_VIOLATION	0x20
#define EXC_SUN3_COPROCESSOR		0x34
#define EXC_SUN3_TRAP1			0x84
#define EXC_SUN3_TRAP2			0x88
#define EXC_SUN3_TRAP3			0x8c
#define EXC_SUN3_TRAP4			0x90
#define EXC_SUN3_TRAP5			0x94
#define EXC_SUN3_TRAP6			0x98
#define EXC_SUN3_TRAP7			0x9c
#define EXC_SUN3_TRAP8			0xa0
#define EXC_SUN3_TRAP9			0xa4
#define EXC_SUN3_TRAP10			0xa8
#define EXC_SUN3_TRAP11			0xac
#define EXC_SUN3_TRAP12			0xb0
#define EXC_SUN3_TRAP13			0xb4
#define EXC_SUN3_TRAP14			0xb8
#define EXC_SUN3_FLT_BSUN		0xc0
#define EXC_SUN3_FLT_OPERAND_ERROR	0xd0

/*
 *	NOTE: TRAP0 is syscall, TRAP15 is breakpoint.
 */

/*
 *	EXC_ARITHMETIC
 */

#define EXC_SUN3_ZERO_DIVIDE		0x14
#define EXC_SUN3_FLT_INEXACT		0xc4
#define EXC_SUN3_FLT_ZERO_DIVIDE	0xc8
#define EXC_SUN3_FLT_UNDERFLOW		0xcc
#define EXC_SUN3_FLT_OVERFLOW		0xd4
#define EXC_SUN3_FLT_NOT_A_NUMBER	0xd8

/*
 *	EXC_EMULATION
 */

#define EXC_SUN3_LINE_1010		0x28
#define EXC_SUN3_LINE_1111		0x2c

/*
 *	EXC_SOFTWARE
 */

#define EXC_SUN3_CHK	0x18
#define EXC_SUN3_TRAPV	0x1c

/*
 *	EXC_BREAKPOINT
 */

#define EXC_SUN3_TRACE			0x24
#define EXC_SUN3_BREAKPOINT		0xbc

#endif	_MACH_SUN3_EXCEPTION_H_
@EOF@

echo "include/mach/sun3/kern_return.h"
cat >include/mach/sun3/kern_return.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	kern_return.h,v $
 * Revision 2.4  89/03/09  20:23:32  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:40:39  gm0w
 * 	Changes for cleanup.
 * 
 * 14-Oct-85  Michael Wayne Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 */
/*
 *	Machine-dependent kernel return definitions.
 *	Copyright (C) 1985, Avadis Tevanian, Jr., Michael Wayne Young
 */

#ifndef	_MACH_SUN3_KERN_RETURN_H_
#define _MACH_SUN3_KERN_RETURN_H_

typedef	int		kern_return_t;

#endif	_MACH_SUN3_KERN_RETURN_H_
@EOF@

echo "include/mach/sun3/reg.h"
cat >include/mach/sun3/reg.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	reg.h,v $
 * Revision 2.3  90/07/03  16:39:10  mrt
 * 	Removed the special c_plusplus fixes for structure declarations
 * 	as c_plusplus now accepts the normal way of doing things
 * 	and gcc would't deal with the other way.
 * 	[90/05/23            mrt]
 * 
 * Revision 2.2  89/03/10  02:26:13  rpd
 * 	Copied here from sun3/reg.h.
 * 
 * Revision 2.6  89/03/09  21:37:42  rpd
 * 	More cleanup.
 * 
 * Revision 2.5  89/02/26  14:48:20  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.4  88/10/11  12:07:59  rpd
 * 	Remove type definitions of structure types if c_plusplus
 * 	is being used. It didn't like having the extra level of defines
 * 	since it is assumed by c_plusplus. (From mrt.)
 * 	[88/10/11  11:54:00  rpd]
 * 
 *  2-Jan-88  Robert Baron (rvb) at Carnegie-Mellon University
 *	Stack format fields must be unsigned.  Apparently sun cc treats
 *	all (?) bit fields as unsigned.
 */

/*      @(#)reg.h 1.1 86/09/25 SMI      */

/*
 * Copyright (c) 1986 by Sun Microsystems, Inc.
 */

#ifndef	_MACH_SUN3_REG_H_
#define _MACH_SUN3_REG_H_

/*
 * Location of the users' stored
 * registers relative to R0.
 * Usage is u.u_ar0[XX].
 */
#define R0	(0)
#define R1	(1)
#define R2	(2)
#define R3	(3)
#define R4	(4)
#define R5	(5)
#define R6	(6)
#define R7	(7)
#define AR0	(8)
#define AR1	(9)
#define AR2	(10)
#define AR3	(11)
#define AR4	(12)
#define AR5	(13)
#define AR6	(14)
#define AR7	(15)
#define SP	(15)
#define PS	(16)
#define PC	(17)

/*
 * And now for something completely the same...
 */
#ifndef	LOCORE
struct regs {	
	int	r_dreg[8];	/* data registers */
#define r_r0	r_dreg[0]	/* r0 for portability */
	int	r_areg[8];	/* address registers */
#define r_sp	r_areg[7]	/* user stack pointer */
	int	r_sr;		/* status register (actually a short) */
#define r_ps	r_sr
	int	r_pc;		/* program counter */
};

struct stkfmt {
	unsigned int	f_stkfmt : 4;	/* stack format */
	unsigned int		 : 2;
	unsigned int	f_vector : 10;	/* vector offset */
	short	f_beibase;	/* start of bus error info (if any) */
};


/*
 * Struct for floating point registers and general state
 * for the MC68881 (the sky fpp has no user visible state).
 * If fps_flags == FPS_UNUSED, the other 68881 fields have no meaning.
 * fps_code and fps_flags are software implemented fields.
 * fps_flags is not used when set by user level programs,
 * but changing fps_code has the side effect of changing u.u_code.
 */

typedef	struct ext_fp {
	int	fp[3];
} ext_fp;			/* extended 96-bit 68881 fp registers */


struct fp_status {
	ext_fp	fps_regs[8];		/* 68881 floating point regs */
	int	fps_control;		/* 68881 control reg */
	int	fps_status;		/* 68881 status reg */
	int	fps_iaddr;		/* 68881 instruction address reg */
	int	fps_code;		/* additional word for signals */
	int	fps_flags;		/* r/o - unused, idle or busy */
};
#endif	LOCORE

/*
 * Values defined for `fps_flags'.
 */
#define FPS_UNUSED	0		/* 68881 never used yet */
#define FPS_IDLE	1		/* 68881 instruction completed */
#define FPS_BUSY	2		/* 68881 instruction interrupted */

/*
 * The EXT_FPS_FLAGS() macro is used to convert a pointer to an
 * fp_istate into a value to be used for the user visible state
 * found in fps_flags.  As a speed optimization, this convertion
 * is only done is required (e.g.  the PTRACE_GETFPREGS ptrace
 * call or when dumping core) instead of on each context switch.
 * The tests that we base the state on are that a fpis_vers of
 * FPIS_VERSNULL means NULL state, else a fpis_bufsiz of FPIS_IDLESZ
 * means IDLE state, else we assume BUSY state.
 */
#define FPIS_VERSNULL	0x0
#define FPIS_IDLESIZE	0x18

#define EXT_FPS_FLAGS(istatep) \
	((istatep)->fpis_vers == FPIS_VERSNULL ? FPS_UNUSED : \
	    (istatep)->fpis_bufsiz == FPIS_IDLESIZE ? FPS_IDLE : FPS_BUSY)

#ifndef	LOCORE
/*
 * Struct for the internal state of the MC68881
 * Although the MC68881 can have a smaller maximum for
 * internal state, we allow for more to allow for expansion.
 */
#define FPIS_BUFSIZ	0xc0

struct fp_istate {
	unsigned char	fpis_vers;		/* version number */
	unsigned char	fpis_bufsiz;		/* size of info in fpis_buf */
	unsigned short	fpis_reserved;		/* reserved word */
	unsigned char	fpis_buf[FPIS_BUFSIZ];	/* fpp internal state buffer */
};

/* 
 * Structures for the status and data registers are defined here.
 * Struct fpa_status are included in the u area.
 * Struct fpa_regs is included in struct core.
 */

/* struct fpa_status is saved/restored during context switch */
struct fpa_status {
	unsigned int	fpas_state;	/* STATE, supervisor privileged reg */
	unsigned int	fpas_imask;	/* IMASK */
	unsigned int	fpas_load_ptr;	/* LOAD_PTR */
	unsigned int	fpas_ierr;	/* IERR */
	unsigned int	fpas_act_instr; /* pipe active instruction halves */
	unsigned int	fpas_nxt_instr; /* pipe next instruction halves */
	unsigned int	fpas_act_d1half;/* pipe active data first half */
	unsigned int	fpas_act_d2half;/* pipe active data second half */
	unsigned int	fpas_nxt_d1half;/* pipe next data first half */
	unsigned int	fpas_nxt_d2half;/* pipe next data second half */
	unsigned int	fpas_mode3_0;	/* FPA MODE3_0 register */
	unsigned int	fpas_wstatus;	/* FPA WSTATUS register */
};

/* 
 * Since there are 32 contexts supported by the FPA hardware,
 * when we do context switch on the FPA, we don't save/restore
 * the data registers between the FPA and the u area.
 * If there are already 32 processes using the fpa concurrently,
 * we give an error message to the 33rd process trying to use the fpa.
 * (Hopefully there will not be this many processes using FPA concurrently.)
 */

#define FPA_NCONTEXTS		32
#define FPA_NDATA_REGS		32

typedef struct fpa_long {
	int     fpl_data[2];
} fpa_long;		 /* 64 bit double precision registers */

/* Struct fpa_regs is included in struct core. */
struct fpa_regs {
	unsigned int	fpar_flags; /* if zero, other fields are meaningless */
        struct fpa_status	fpar_status;
        fpa_long	fpar_data[FPA_NDATA_REGS];
};

#endif	LOCORE
#endif	_MACH_SUN3_REG_H_
@EOF@

echo "include/mach/sun3/syscall_sw.h"
cat >include/mach/sun3/syscall_sw.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	syscall_sw.h,v $
 * Revision 2.4  89/03/09  20:23:37  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:40:44  gm0w
 * 	Changes for cleanup.
 * 
 * 15-Feb-87  Jonathan J. Chew (jjc) at Carnegie-Mellon University
 *	Modified for Sun (again).
 *
 *  1-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created from mach_syscalls.h in the user library sources.
 *
 */

#ifndef	_MACH_SUN3_SYSCALL_SW_H_
#define _MACH_SUN3_SYSCALL_SW_H_

#define kernel_trap(trap_name, trap_number, number_args) \
	.globl	_/**/trap_name; \
_/**/trap_name: \
	pea	trap_number; \
	trap	#0; \
	rts

#endif	_MACH_SUN3_SYSCALL_SW_H_
@EOF@

echo "include/mach/sun3/thread_status.h"
cat >include/mach/sun3/thread_status.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_status.h,v $
 * Revision 2.6  89/03/10  02:24:31  rpd
 * 	Get FP stuff from mach/sun3/reg.h instead of sun3/reg.h.
 * 
 * Revision 2.5  89/03/09  20:23:42  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:40:50  gm0w
 * 	Changes for cleanup.
 * 
 *  2-Jan-88  Robert Baron (rvb) at Carnegie-Mellon University
 *	Stack format fields must be unsigned.  Apparently sun cc treats
 *	all (?) bit fields as unsigned.
 *
 * 28-Dec-87  David Golub (dbg) at Carnegie-Mellon University
 *	Added floating-point registers.  Broke into several pieces for
 *	new thread-status interface.
 *
 * 21-Apr-87  David Golub (dbg) at Carnegie-Mellon University
 *	Cloned from Vax version.
 *
 * 27-Mar-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 */
/*
 *	File:	mach/sun3/thread_status.h
 *	Author:	Avadis Tevanian, Jr.
 *	Copyright (C) 1985, Avadis Tevanian, Jr.
 *
 *	This file contains the structure definitions for the thread
 *	state as applied to SUN processors (mc68020).
 *
 */

#ifndef	_MACH_SUN3_THREAD_STATUS_H_
#define _MACH_SUN3_THREAD_STATUS_H_

#include <:mach:sun3:reg.h>		/* FP declarations */

/*
 *	Two structures are defined:
 *
 *	sun_thread_state	this is the structure that is exported
 *				to user threads for use in status/mutate
 *				calls.  This structure should never
 *				change.
 *
 *	sun_saved_state		this structure corresponds to the state
 *				of the user registers as saved on the
 *				stack upon kernel entry.  This structure
 *				is used internally only.  Since this
 *				structure may change from version to
 *				version, it is hidden from the user.
 */

#define SUN_THREAD_STATE_REGS	1

struct sun_thread_state {
	int	d0;		/* data registers */
	int	d1;
	int	d2;
	int	d3;
	int	d4;
	int	d5;
	int	d6;
	int	d7;
	int	a0;		/* address registers */
	int	a1;
	int	a2;
	int	a3;
	int	a4;
	int	a5;
	int	a6;
	int	sp;		/* user's stack pointer */
	int	pc;		/* user's program counter */
	int	sr;		/* user's status register */
	struct fp_status fp;	/* floating point registers/status */
};
#define SUN_THREAD_STATE_REGS_COUNT \
			(sizeof(struct sun_thread_state) / sizeof(int))

/*
 *	Floating-point accelerator registers
 */
#define SUN_THREAD_STATE_FPA	2
/*
 *	structure is 'struct fpa_regs' in sun3/reg.h
 */
#define SUN_THREAD_STATE_FPA_COUNT \
			(sizeof(struct fpa_regs) / sizeof(int))

#ifdef	KERNEL
struct sun_saved_state {
	int	d0;		/* data registers */
	int	d1;
	int	d2;
	int	d3;
	int	d4;
	int	d5;
	int	d6;
	int	d7;
	int	a0;		/* address registers */
	int	a1;
	int	a2;
	int	a3;
	int	a4;
	int	a5;
	int	a6;
	int	sp;		/* user's stack pointer */
	int	sr;		/* user's status register */
	int	pc;		/* user's program counter */
	unsigned int	stkfmt	: 4;	/* rte stack frame format */
	unsigned int		: 2;
	unsigned int	vector	: 10;	/* vector number */
};

#define USER_REGS(thread)	((thread)->pcb->user_regs)

#endif	KERNEL
/*
 *	The saved floating-point registers are found in the PCB.
 */

#endif	_MACH_SUN3_THREAD_STATUS_H_
@EOF@

echo "include/mach/sun3/vm_param.h"
cat >include/mach/sun3/vm_param.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_param.h,v $
 * Revision 2.5  89/03/09  20:23:48  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:40:56  gm0w
 * 	Changes for cleanup.
 * 
 * 05-Apr-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Added sun_trunc_page, fixed up includes.
 *
 * 23-Feb-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Don't allocate VM over the PROM monitor.
 *
 * 31-Jan-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Define INTSTACK_SIZE.
 *
 * 23-Oct-86  David Golub (dbg) at Carnegie-Mellon University
 *	Added KERNEL_STACK_SIZE in anticipation of MACH.
 *
 *  4-Aug-86  Jonathan J. Chew (jjc) at Carnegie-Mellon University
 *	Created.
 *
 */

#ifndef	_MACH_SUN3_VM_PARAM_H_
#define _MACH_SUN3_VM_PARAM_H_

#define BYTE_SIZE	8	/* byte size in bits */

#define SUN3_PGBYTES	8192	/* bytes per sun3 page */
#define SUN3_PGSHIFT	13	/* number of bits to shift for pages */

/*
 * KERNELBASE is the virtual address which
 * the kernel mapping starts in all contexts.
 */
#define KERNELBASE	0x0E000000

#define VM_MIN_ADDRESS	((vm_offset_t)0)
#define VM_MAX_ADDRESS	((vm_offset_t)KERNELBASE)

/*
 * The value of VM_MAX_KERNEL_ADDRESS should equal
 * MONSTART, defined in <mon/sunromvec.h>.
 */
#define VM_MIN_KERNEL_ADDRESS	((vm_offset_t)KERNELBASE)
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t)0x0FE00000)

#define sun_round_page(x) (((unsigned)(x)+SUN3_PGBYTES-1) & ~(SUN3_PGBYTES-1))
#define sun_trunc_page(x) ((unsigned)(x) & ~(SUN3_PGBYTES-1))

#define KERNEL_STACK_SIZE	(SUN3_PGBYTES)	/* must be at least one page */
#define INTSTACK_SIZE		(3*512)

#endif	_MACH_SUN3_VM_PARAM_H_
@EOF@

echo "include/mach/sun3/vm_types.h"
cat >include/mach/sun3/vm_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_types.h,v $
 * Revision 2.4  89/03/09  20:23:54  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:01  gm0w
 * 	Changes for cleanup.
 * 
 * 13-Jun-86  Jonathan J. Chew (jjc) at Carnegie-Mellon University
 *	Copied RT version for Sun 3.
 * 13-Jun-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 *	Header file for VM data types.  Sun version.
 */

#ifndef	_MACH_SUN3_VM_TYPES_H_
#define _MACH_SUN3_VM_TYPES_H_

#ifndef	ASSEMBLER
#ifndef	MACHINE_VM_TYPES_H_
#define MACHINE_VM_TYPES_H_

typedef	unsigned long	vm_offset_t;
typedef	unsigned long	vm_size_t;

#endif	MACHNE_VM_TYPES_H_
#endif	ASSEMBLER
#endif	_MACH_SUN3_VM_TYPES_H_
@EOF@

echo "include/mach/vax/boolean.h"
cat >include/mach/vax/boolean.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	boolean.h,v $
 * Revision 2.4  89/03/09  20:24:35  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:40  gm0w
 * 	Changes for cleanup.
 * 
 * 24-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	vax/boolean.h
 *
 *	Boolean type, for Vax.
 */

#ifndef	_MACH_VAX_BOOLEAN_H_
#define _MACH_VAX_BOOLEAN_H_

typedef int		boolean_t;

#endif	_MACH_VAX_BOOLEAN_H_
@EOF@

echo "include/mach/vax/exception.h"
cat >include/mach/vax/exception.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exception.h,v $
 * Revision 2.4  89/03/09  20:24:40  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:46  gm0w
 * 	Changes for cleanup.
 * 
 *  2-Nov-87  David Golub (dbg) at Carnegie-Mellon University
 *	Created.
 *
 */

/*
 *	Codes and subcodes for vax exceptions.
 */

/*
 *	EXC_BAD_INSTRUCTION
 */

#ifndef	_MACH_VAX_EXCEPTION_H_
#define _MACH_VAX_EXCEPTION_H_

#define EXC_VAX_PRIVINST		1
#define EXC_VAX_RESOPND			2
#define EXC_VAX_RESADDR			3
#define EXC_VAX_COMPAT			4

/*
 *	COMPAT subcodes
 */
#define EXC_VAX_COMPAT_RESINST		0
#define EXC_VAX_COMPAT_BPT		1
#define EXC_VAX_COMPAT_IOT		2
#define EXC_VAX_COMPAT_EMT		3
#define EXC_VAX_COMPAT_TRAP		4
#define EXC_VAX_COMPAT_RESOP		5
#define EXC_VAX_COMPAT_ODDADDR		6

/*
 *	EXC_ARITHMETIC
 */

#define EXC_VAX_INT_OVF			1
#define EXC_VAX_INT_DIV			2
#define EXC_VAX_FLT_OVF_T		3
#define EXC_VAX_FLT_DIV_T		4
#define EXC_VAX_FLT_UND_T		5
#define EXC_VAX_DEC_OVF			6

#define EXC_VAX_FLT_OVF_F		8
#define EXC_VAX_FLT_DIV_F		9
#define EXC_VAX_FLT_UND_F		10

/*
 *	EXC_SOFTWARE
 */

#define EXC_VAX_SUB_RNG			7

/*
 *	EXC_BREAKPOINT
 */

#define EXC_VAX_BPT			1
#define EXC_VAX_TRACE			2

#endif	_MACH_VAX_EXCEPTION_H_
@EOF@

echo "include/mach/vax/kern_return.h"
cat >include/mach/vax/kern_return.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	kern_return.h,v $
 * Revision 2.4  89/03/09  20:24:45  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:51  gm0w
 * 	Changes for cleanup.
 * 
 *  3-Mar-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Allow inclusion in assembler input.
 *
 * 14-Oct-85  Michael Wayne Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	h/kern_error.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Copyright (C) 1985, Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Machine-dependent kernel return definitions.
 */

#ifndef	_MACH_VAX_KERN_RETURN_H_
#define _MACH_VAX_KERN_RETURN_H_

#ifndef	ASSEMBLER
typedef	int		kern_return_t;
#endif	ASSEMBLER
#endif	_MACH_VAX_KERN_RETURN_H_
@EOF@

echo "include/mach/vax/syscall_sw.h"
cat >include/mach/vax/syscall_sw.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	syscall_sw.h,v $
 * Revision 2.4  89/03/09  20:24:50  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:41:56  gm0w
 * 	Changes for cleanup.
 * 
 *  1-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created from mach_syscalls.h in the user library sources.
 *
 */

#ifndef	_MACH_VAX_SYSCALL_SW_H_
#define _MACH_VAX_SYSCALL_SW_H_

#define kernel_trap(trap_name, trap_number, number_args) \
	.globl	_/**/trap_name; \
	.align	2; \
_/**/trap_name: \
	.word	0; \
	chmk	$trap_number; \
	ret

#endif	_MACH_VAX_SYSCALL_SW_H_
@EOF@

echo "include/mach/vax/thread_status.h"
cat >include/mach/vax/thread_status.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_status.h,v $
 * Revision 2.4  89/03/09  20:24:55  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:42:01  gm0w
 * 	Changes for cleanup.
 * 
 * 28-Dec-87  David Golub (dbg) at Carnegie-Mellon University
 *	Added flavor code for new thread_status interface.
 *
 * 27-Mar-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	vax/thread_status.h
 *	Author:	Avadis Tevanian, Jr.
 *
 *	Copyright (C) 1985, Avadis Tevanian, Jr.
 *
 *	This file contains the structure definitions for the thread
 *	state as applied to VAX processors.
 */

#ifndef	_MACH_VAX_THREAD_STATUS_H_
#define _MACH_VAX_THREAD_STATUS_H_

/*
 *	Two structures are defined:
 *
 *	vax_thread_state	this is the structure that is exported
 *				to user threads for use in status/mutate
 *				calls.  This structure should never
 *				change.
 *
 *	vax_saved_state		this structure corresponds to the state
 *				of the user registers as saved on the
 *				stack upon kernel entry.  This structure
 *				is used internally only.  Since this
 *				structure may change from version to
 *				version, it is hidden from the user.
 */

#define VAX_THREAD_STATE	(1)
				/* only one set of registers */

struct vax_thread_state {
	int	r0;		/* general registers */
	int	r1;
	int	r2;
	int	r3;
	int	r4;
	int	r5;
	int	r6;
	int	r7;
	int	r8;
	int	r9;
	int	r10;
	int	r11;
	int	ap;		/* user's arg pointer */
	int	fp;		/* user's frame pointer */
	int	sp;		/* user's stack pointer */
	int	pc;		/* user's program counter */
	int	ps;		/* user's processor status longword */
};

#define VAX_THREAD_STATE_COUNT	(sizeof(struct vax_thread_state)/sizeof(int))

#ifdef	KERNEL
struct vax_saved_state {
	int	ap;		/* user's arg pointer */
	int	fp;		/* user's frame pointer */
	int	pad0;		/* saved pc after calls */
	int	r0;		/* general registers */
	int	r1;
	int	r2;
	int	r3;
	int	r4;
	int	r5;
	int	r6;
	int	r7;
	int	r8;
	int	r9;
	int	r10;
	int	r11;
	int	nargs;		/* calls saves nargs here */
	int	sp;		/* user's stack pointer */
	int	pad1;
	int	pad2;
	int	pc;		/* user's program counter */
	int	ps;		/* user's processor status longword */
};

#define USER_REGS(thread)	(((struct vax_saved_state *)	\
					((thread)->kernel_stack	\
					 + KERNEL_STACK_SIZE)	\
					) - 1)
#endif	KERNEL
#endif	_MACH_VAX_THREAD_STATUS_H_
@EOF@

echo "include/mach/vax/vm_param.h"
cat >include/mach/vax/vm_param.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_param.h,v $
 * Revision 2.4  89/03/09  20:25:02  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:42:06  gm0w
 * 	Changes for cleanup.
 * 
 * 16-Jan-87  David Golub (dbg) at Carnegie-Mellon University
 *	Made vax_ptob return 'unsigned' instead of caddr_t.
 *
 * 20-Jun-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	vax/vm_param.h
 *	Author:	Avadis Tevanian, Jr.
 *
 *	Copyright (C) 1985, Avadis Tevanian, Jr.
 *
 *	VAX machine dependent virtual memory parameters.
 *	Most of the declarations are preceeded by VAX_ (or vax_)
 *	which is OK because only Vax specific code will be using
 *	them.
 */

#ifndef	_MACH_VAX_VM_PARAM_H_
#define _MACH_VAX_VM_PARAM_H_

#define BYTE_SIZE	8	/* byte size in bits */

#define VAX_PGBYTES	512	/* bytes per vax page */
#define VAX_PGSHIFT	9	/* number of bits to shift for pages */

/*
 *	Convert bytes to pages and convert pages to bytes.
 *	No rounding is used.
 */

#define vax_btop(x)		(((unsigned)(x)) >> VAX_PGSHIFT)
#define vax_ptob(x)		(((unsigned)(x)) << VAX_PGSHIFT)

/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.
 */

#define vax_round_page(x)	((((unsigned)(x)) + VAX_PGBYTES - 1) & \
					~(VAX_PGBYTES-1))
#define vax_trunc_page(x)	(((unsigned)(x)) & ~(VAX_PGBYTES-1))

#define VM_MIN_ADDRESS	((vm_offset_t) 0)
#define VM_MAX_ADDRESS	((vm_offset_t) 0x80000000)

#define VM_MIN_KERNEL_ADDRESS	((vm_offset_t) 0x80000000)
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t) 0xffffffff)

#define KERNEL_STACK_SIZE	(8*512)	/* XXX we don't use the stack yet */
#define INTSTACK_SIZE		(3*512)		/* interrupt stack size */

/*
 *	Conversion between VAX pages and VM pages
 */

#define trunc_vax_to_vm(p)	(atop(trunc_page(vax_ptob(p))))
#define round_vax_to_vm(p)	(atop(round_page(vax_ptob(p))))
#define vm_to_vax(p)		(vax_btop(ptoa(p)))

#endif	_MACH_VAX_VM_PARAM_H_
@EOF@

echo "include/mach/vax/vm_types.h"
cat >include/mach/vax/vm_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_types.h,v $
 * Revision 2.4  89/03/09  20:25:08  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:42:11  gm0w
 * 	Changes for cleanup.
 * 
 * 23-Apr-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Changed things to "unsigned int" to appease the user community :-).
 *
 * 13-Jun-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	vm_types.h
 *	Author:	Avadis Tevanian, Jr.
 *
 *	Copyright (C) 1985, Avadis Tevanian, Jr.
 *
 *	Header file for VM data types.  VAX version.
 */

#ifndef	_MACH_VAX_VM_TYPES_H_
#define _MACH_VAX_VM_TYPES_H_

#ifdef	ASSEMBLER
#else	ASSEMBLER
typedef	unsigned int	vm_offset_t;
typedef	unsigned int	vm_size_t;
#endif	ASSEMBLER
#endif	_MACH_VAX_VM_TYPES_H_
@EOF@

echo "include/mach/ca/boolean.h"
cat >include/mach/ca/boolean.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	boolean.h,v $
 * Revision 2.4  89/03/09  20:18:25  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:12:14  gm0w
 * 	Changes for cleanup.
 * 
 * 15-Oct-86  Bill Bolosky (bolosky) at Carnegie-Mellon University
 *	Created from Vax version.
 *
 */
/*
 *	File:	mach/ca/boolean.h
 *
 *	Boolean type, for RT.
 *
 */

#ifndef	_MACH_CA_BOOLEAN_H_
#define _MACH_CA_BOOLEAN_H_

typedef int		boolean_t;

#endif	_MACH_CA_BOOLEAN_H_
@EOF@

echo "include/mach/ca/exception.h"
cat >include/mach/ca/exception.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exception.h,v $
 * Revision 2.5  89/06/30  22:33:38  rpd
 * 	Work-around for APC FP hardware bug.
 * 	[89/06/30  16:18:08  rpd]
 * 
 * Revision 2.4  89/03/09  20:18:31  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:12:20  gm0w
 * 	Changes for cleanup.
 * 
 * 15-Feb-88  David Black (dlb) at Carnegie-Mellon University
 *	Move MCHECK to bad access, and change code.
 *
 * 29-Jan-88  Richard Sanzi (sanzi) at Carnegie-Mellon University
 *	Created.
 *
 */

#ifndef	_MACH_CA_EXCEPTION_H_
#define _MACH_CA_EXCEPTION_H_

#include <:mach:kern_return.h>

/*
 *	EXC_BAD_ACCESS
 */
/*
 *	Romp has machine-dependent failure modes.  The codes
 *	are negative so as not to conflict with kern_return_t's.
 */
#define EXC_ROMP_MCHECK		((kern_return_t)-1) /* machine check */
#define EXC_ROMP_APC_BUG	((kern_return_t)-2) /* APC hardware bug */

/*
 * EXC_BAD_INSTRUCTION
 */
#define EXC_ROMP_PRIV_INST 	0x01
#define EXC_ROMP_ILLEGAL_INST	0x02

/*
 * EXC_BREAKPOINT
 */
#define EXC_ROMP_TRAP_INST 	0x01
#define EXC_ROMP_INST_STEP  	0x02

/*
 * EXC_ARITHMETIC
 *
 */

/*							   
 * Values for code when type == EXC_ARITHMETIC
 */							    

#define EXC_ROMP_FPA_EMUL	0x01
#define EXC_ROMP_68881		0x02
#define EXC_ROMP_68881_TIMEOUT	0x04
#define EXC_ROMP_FLOAT_SPEC	0x08

#endif	_MACH_CA_EXCEPTION_H_
@EOF@

echo "include/mach/ca/float.h"
cat >include/mach/ca/float.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	float.h,v $
 * Revision 2.6  89/03/09  20:18:37  rpd
 * 	More cleanup.
 * 
 * Revision 2.5  89/02/25  18:12:26  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.4  89/02/08  17:54:32  mwyoung
 * Relocated from ca/float.h.  This file should be pared down to
 * reflect only the Mach interface.
 * 
 * Revision 2.3  88/11/23  16:19:17  rpd
 * 	More Acis merge.
 * 	[88/11/13  22:18:24  rpd]
 * 	
 * 	Merged with Acis.
 * 	[88/11/04  16:58:08  rpd]
 * 
 * 25-Apr-88  Richard Sanzi (sanzi) at Carnegie-Mellon University
 *	Added AFPA support.  
 *
 * 28-Aug-87  Richard Sanzi (sanzi) at Carnegie-Mellon University
 *	Added #ifndef ASSEMBLER around C defintions in order for this
 *	file to be included into locore.c.
 *
 * 26-Aug-87  Richard Sanzi (sanzi) at Carnegie-Mellon University
 *	Merged in latest ACIS changes.  
 *
 */
/*
 * 5799-WZQ (C) COPYRIGHT IBM CORPORATION 1987,1988
 * LICENSED MATERIALS - PROPERTY OF IBM
 * REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER G120-2083
 */
/* $ Header:float.h 11.1$ */
/* $ ACIS:float.h 11.1$ */
/* $ Source: /ibm/acis/usr/sys/ca/RCS/float.h,v $ */

#ifndef	_MACH_CA_FLOAT_H_
#define _MACH_CA_FLOAT_H_

#if	!defined(lint) && !defined(LOCORE) && defined(RCS_HDRS)
static char *rcsidfloat = "$Header: float.h,v 2.6 89/03/09 20:18:37 rpd Exp $";
#endif

#ifndef	FLOAT_H_
#define FLOAT_H_

/*
 * this file contains those defines and declarations required 
 * for the floating point accelerator 
 */
#ifndef	_FLOATSAVE_

/* 
 * floatsave is the save area for the floating point registers
 * used when it is necessary to take back a register set from
 * a process. these are kept in kernel memory so that it is
 * easy to do so. The space is allocated only when the FPA is 
 * present.
 * the current register set is given in the proc structure.
 *
 */

#define _FLOATSAVE_

#ifndef	LOCORE
/* saved float register sets are indexed by p-proc. */

/*
 * For each type of register set, we define the number of words necessary to
 * save the state of that type of hardware.
 */
#define FPA_SAVE_WORDS		(64+3)		/* FPA1 or 2 */
#define MC881_SAVE_WORDS	(300/4)
#define EMUL_SAVE_WORDS		34

/*
 * For each type of register set, we define the number of legal registers
 * which may be set/fetched via ptrace.
 */
#define FPA_NUM_REG	16
#define MC881_NUM_REG	(3*8)	/* 8 registers, each extended precision */
#define EMUL_NUM_REG	16

/* saved float register sets are stored in the pcb in the thread structure. */

struct floatsave 
{
	union {
		int fpa_int[FPA_SAVE_WORDS];
		double fpa_double[FPA_SAVE_WORDS/2];
		float fpa_float[FPA_SAVE_WORDS];
		int mc881_int[MC881_SAVE_WORDS];
		int emul_int[EMUL_SAVE_WORDS];
	} float_un;
#define fpa_intreg float_un.fpa_int
#define fpa_doublereg float_un.fpa_double
#define fpa_floatreg float_un.fpa_float
#define mc881_intreg	float_un.mc881_int
#define emul_intreg	float_un.emul_int
};

#ifdef	KERNEL
extern struct floatsave *floatsave;	/* NPROC of these allocated */
extern int	float_hardware;		/* What hardware is on the system */
#endif	KERNEL

/*
 * The following structure is what the kernel and user process use
 * to pass back and forth the state of the system and process
 * floating point structures.
 */

struct floatstate {
    int
	hardware_state,		/* What exists on the system */
	process_state;		/* What is allocated to this process */
    void
	(*emulator)(),		/* Address of floating point emulator */
	(*code_generator)();	/* Address of floating point code generator */
    int
	fpa_registerset;	/* (At this time) which fpa register set */
};

#define float_has_881(x)	((x)&FLOAT_MC881)
#define float_has_fpa(x)	((x)&FLOAT_FPA)
#define float_has_afpa(x)	((x)&FLOAT_AFPA)
#define float_has_fpa_or_afpa(x)	((x)&(FLOAT_FPA|FLOAT_AFPA))
#define float_has_any(x)	((x)&(FLOAT_FPA|FLOAT_AFPA|FLOAT_MC881))
#define float_has_emul(x)	((x)&FLOAT_EMUL)
#define float_has_afpa_hardware(x)	((x)&FLOAT_AFPA_HARDWARE)
#define float_has_e_afpa_hardware(x)	(((x)&FLOAT_AFPA_HARDWARE) && \
					((x)&FLOAT_AFPA_PASS_D))

/*
 * These are the values which exist in current_thread()->pcb->floatmask,
 * and in float_hardware.
 */
#define FLOAT_MC881			0x01	/* Using mc881/mc881 exists */
#define FLOAT_FPA			0x02	/* Using fpa/afpa exists */
#define FLOAT_AFPA			0x04	/* Using afpa/afpa operational*/
#define FLOAT_EMUL			0x08	/* Using emulator */
#define FLOAT_AFPA_HARDWARE		0x10	/* Afpa hardware exists */
	/*
	 * Control store accesses to afpa enabled.
	 * In this state, the only legal afpa commands are
	 * those to load the microcode.
	 */
#define FLOAT_AFPA_CONTROL_STORE_ENABLE	0x20
#define FLOAT_AFPA_DMA			0x40	/* Afpa with DMA hardware */
#define FLOAT_AFPA_PASS_D		0x80	/* hardware type is E_AFPA */

#define FLOAT_FMT "\20\1MC881\2FPA\3AFPA_UP\4EMUL\5AFPA_HW\6AFPA_CTL\7AFPA_DMA"

/*
 * This constant is used in the current_thread()->pcb->pcb_floatinfo to
 * indicate that the fpa requires an exception.
 */
#define	 SOWEFPA	0x01

#endif	LOCORE

#endif	/* endef _FLOATSAVE_ */
#endif	FLOAT_H_

#endif	_MACH_CA_FLOAT_H_
@EOF@

echo "include/mach/ca/kern_return.h"
cat >include/mach/ca/kern_return.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	kern_return.h,v $
 * Revision 2.4  89/03/09  20:18:43  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:12:34  gm0w
 * 	Changes for cleanup.
 * 
 * 14-Oct-85  Michael Wayne Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 */
/*
 *	Machine-dependent kernel return definitions.
 *	Copyright (C) 1985, Avadis Tevanian, Jr., Michael Wayne Young
 */

#ifndef	_MACH_CA_KERN_RETURN_H_
#define _MACH_CA_KERN_RETURN_H_

typedef	int		kern_return_t;

#endif	_MACH_CA_KERN_RETURN_H_
@EOF@

echo "include/mach/ca/syscall_sw.h"
cat >include/mach/ca/syscall_sw.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	syscall_sw.h,v $
 * Revision 2.5  89/03/09  20:18:48  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:12:39  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  00:55:30  mwyoung
 * Relocated from ca/syscall_sw.h
 * 
 * Revision 2.2  88/10/11  10:07:49  rpd
 * 	Major modifications to kernel_trap:
 * 	  The _trap_name symbol is defined correctly now,
 * 	  so pointers to system calls should work.
 * 	
 * 	  Now traps pass 6 arguments in registers.
 * 	
 * 	  errno processing is no longer done.
 * 	[88/10/06  12:14:43  rpd]
 * 
 *  1-Apr-87  William Bolosky (bolosky) at Carnegie-Mellon University
 *	Fixed to always pass in 5 parameters (in r2-r6).
 *	If you need to send in more than 5, then you must fix
 *	kernel_trap and also fix ../ca/trap.c.
 *
 *  1-Sep-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created from mach_syscalls.h in the user library sources.
 */

#ifndef	_MACH_CA_SYSCALL_SW_H_
#define _MACH_CA_SYSCALL_SW_H_

#define kernel_trap(trap_name, trap_number, number_args)	\
	.set	.oVpcc, 0					\
	.set	.oVncs, 0					\
	.globl	_/**/trap_name;					\
	.globl	_./**/trap_name;				\
								\
	.data;							\
_/**/trap_name:							\
	.long _./**/trap_name;					\
								\
	.text;							\
_./**/trap_name:						\
	ai	r1,r1,-8;					\
	st	r6,0(r1);					\
	st	r7,4(r1);					\
	l	r6,8(r1);					\
	l	r7,12(r1);					\
	svc	trap_number(r0);				\
	l	r6,0(r1);					\
	l	r7,4(r1);					\
	brx	r15;						\
	ai	r1,r1,8;					\
								\
	.ltorg;							\
	.align	2

#endif	_MACH_CA_SYSCALL_SW_H_
@EOF@

echo "include/mach/ca/thread_status.h"
cat >include/mach/ca/thread_status.h <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_status.h,v $
 * Revision 2.4  89/03/09  20:18:54  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:12:45  gm0w
 * 	Changes for cleanup.
 * 
 * 29-Jan-88  Richard Sanzi (sanzi) at Carnegie-Mellon University
 *	Further modifications for the new thread status interface.
 *
 *  8-Jan-88  David Golub (dbg) at Carnegie-Mellon University
 *	Added flavor code for new thread status interface.
 *
 * 29-Sep-87  Richard Sanzi (sanzi) at Carnegie-Mellon University
 *	Updated register layout for APC/SGP compatibility.
 *
 * 01-Apr-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/ca/thread_status.h
 *	Author:	Avadis Tevanian, Jr.
 *	Copyright (C) 1985, Avadis Tevanian, Jr.
 *
 *	This file contains the structure definitions for the thread
 *	state as applied to ROMP processors.
 *
 */

#ifndef	_MACH_CA_THREAD_STATUS_H_
#define _MACH_CA_THREAD_STATUS_H_

/*
 *	Two structures are defined:
 *
 *	romp_thread_state	this is the structure that is exported
 *				to user threads for use in status/mutate
 *				calls.  This structure should never
 *				change.
 *
 *	romp_saved_state	this structure corresponds to the state
 *				of the user registers as saved on the
 *				stack upon kernel entry.  This structure
 *				is used internally only.  Since this
 *				structure may change from version to
 *				version, it is hidden from the user.
 */

#define ROMP_THREAD_STATE	1
#define ROMP_EXCEPT_STATE	2
#define ROMP_FLOAT_STATE	3

struct romp_thread_state {
	int	r0;		/* general registers */
	int	r1;
	int	r2;
	int	r3;
	int	r4;
	int	r5;
	int	r6;
	int	r7;
	int	r8;
	int	r9;
	int	r10;
	int	r11;
	int	r12;
	int	r13;
	int	r14;
	int	r15;
	int	iar;		/* user's instruction address register */
	int	icscs;		/* user's ICSCS*/
	int	mq;
};

/*
 *	We also export the hardware generated exception packets
 *	which occur on various types of exceptions for the RT.
 *
 *	Consult the IBMRT Technical Reference Manual for full
 *	documentation about the uses of these fields.
 */

struct romp_except_state {
	int	ecr_count;	/* exception count */
	int 	ex1_ctl;	/* exception 1 control */
	int	ex1_addr;	/* exception 1 address */
	int 	ex1_data;	/* exception 1 data (valid if store) */
	int	ex1_rsv;	/* reserved */	
	int	ex2_ctl;	/* exception 2 control */
	int	ex2_addr;	/* exception 2 address */
	int	ex2_data;	/* exception 2 data (valid if store) */
	int	ex2_rsv;	/* reserved */
	int	mcspcs;		/* machine-check status/program-check status*/
	int	info;		/* valid for certain machine-dependent */
				/* values of mcspcs */
};

/*
 *	Rather than define yet another floating point
 *	union, we will use the one defined in "float.h".  We
 *	add the float_type field to allow the kernel to specify to the
 *	user what floating point register type is contained in the
 *	floatsave structure.  The values for float_type are
 *	one of (FLOAT_MC881 | FLOAT_FPA | FLOAT_AFPA | FLOAT_EMUL) which
 *	are defined in "machine/float.h".  
 */

#include <:mach:ca:float.h>

struct romp_float_state {
    	int 	float_type;	/* what type of floating point the following*/
				/* structure contains. */
	struct  floatsave fpregs;
				/* this is a union of the various types */
				/* of floating point used on the APC/RT. */
};

#define ROMP_THREAD_STATE_COUNT	(sizeof(struct romp_thread_state)/sizeof(int))
#define ROMP_EXCEPT_STATE_COUNT (sizeof(struct romp_except_state)/sizeof(int))
#define ROMP_FLOAT_STATE_COUNT 	(sizeof(struct romp_float_state)/sizeof(int))

#ifdef	KERNEL
struct romp_saved_state {
	int	r0;
	int	r1;
	int	r2;
	int	r3;
	int	r4;
	int	r5;
	int	r6;
	int	r7;
	int	r8;
	int	r9;
	int	r10;
	int	r11;
	int	r12;
	int	r13;
	int	r14;
	int	r15;
	int	iar;
	int	mq;
	int	ecr_count;	/* exception count */
	int 	ex1_ctl;	/* exception 1 control */
	int	ex1_addr;	
	int 	ex1_data;
	int	ex1_rsv;	
	int	ex2_ctl;
	int	ex2_addr;
	int	ex2_data;
	int	ex2_rsv;
	int	ex_gsr1;
	int	ex_rep1;
	int	ex_gsr2;
	int	ex_rep2;
	int	mcspcs;
	int	info;
	int	icscs;		/* user's ICSCS*/
};
#define USER_REGS(thread)	(((struct romp_saved_state *)	\
					((thread)->kernel_stack	\
					 + KERNEL_STACK_SIZE)	\
					) - 1)
#endif	KERNEL
#endif	_MACH_CA_THREAD_STATUS_H_
@EOF@

echo "include/mach/ca/vm_param.h"
cat >include/mach/ca/vm_param.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_param.h,v $
 * Revision 2.4  89/03/09  20:19:01  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:12:51  gm0w
 * 	Changes for cleanup.
 * 
 * 23-May-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	KERNEL_STACK_SIZE -> 8K.
 *
 * 11-Jun-86  Bill Bolosky (bolosky) at Carnegie-Mellon University
 *	Created (a while ago) from Avie's vax version.
 *
 */
/*
 *	File:	mach/ca/vm_param.h
 *	Author:	William J. Bolosky
 *	Copyright (C) 1986, William J. Bolosky
 *
 *	imbrt machine dependent virtual memory parameters.
 *
 */

#ifndef	_MACH_CA_VM_PARAM_H_
#define _MACH_CA_VM_PARAM_H_

#define BYTE_SIZE	8	/* byte size in bits */

#define INTSTACK_SIZE	512 * 3	/* This is not used anywhere, since there is
				   no interrupt stack.  But there might be 
				   someday.
				 */

#define VM_MIN_ADDRESS	((vm_offset_t) 0)
#define VM_MAX_ADDRESS	((vm_offset_t) 0xe0000000)

#define VM_MIN_KERNEL_ADDRESS	((vm_offset_t) 0xe0000000)
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t) 0xf0000000)

#define KERNEL_STACK_SIZE	(8*1024)

#endif	_MACH_CA_VM_PARAM_H_
@EOF@

echo "include/mach/ca/vm_types.h"
cat >include/mach/ca/vm_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_types.h,v $
 * Revision 2.4  89/03/09  20:19:06  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:12:56  gm0w
 * 	Changes for cleanup.
 * 
 * 23-Apr-87  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Changed things to "unsigned int" to appease the user community :-).
 *
 * 13-Jun-85  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	mach/ca/vm_types.h
 *	Author:	Avadis Tevanian, Jr.
 *	Copyright (C) 1985, Avadis Tevanian, Jr.
 *
 *	Header file for VM data types.  Ibmrt version.
 *
 */

#ifndef	_MACH_CA_VM_TYPES_H_
#define _MACH_CA_VM_TYPES_H_

#ifdef	ASSEMBLER
#else	ASSEMBLER
typedef	unsigned int	vm_offset_t;
typedef	unsigned int	vm_size_t;
#endif	ASSEMBLER
#endif	_MACH_CA_VM_TYPES_H_
@EOF@

echo "include/mach/machine/boolean.h"
cat >include/mach/machine/boolean.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	boolean.h,v $
 * Revision 2.2  90/08/30  17:48:42  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/boolean.h
 */

#ifndef	_MACH_MAC2_BOOLEAN_H_
#define	_MACH_MAC2_BOOLEAN_H_

typedef int		boolean_t;

#endif	_MACH_MAC2_BOOLEAN_H_
@EOF@

echo "include/mach/machine/exception.h"
cat >include/mach/machine/exception.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exception.h,v $
 * Revision 2.2  90/08/30  17:49:35  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/exeception.h
 */

#ifndef _MACH_MAC2_EXCEPTION_H_
#define _MACH_MAC2_EXCEPTION_H_

/*
 * Machine dependent exception definitions for the Macintosh II.
 */

/*
 * EXC_BAD_INSTRUCTION
 */
#define	EXC_MAC2_ILLEGAL_INSTRUCTION	0x10
#define EXC_MAC2_PRIVILEGE_VIOLATION	0x20
#define EXC_MAC2_COPROCESSOR		0x34
#define EXC_MAC2_TRAP0			0x80
#define EXC_MAC2_TRAP1			0x84
#define EXC_MAC2_TRAP2			0x88
#define EXC_MAC2_TRAP3			0x8c
#define EXC_MAC2_TRAP4			0x90
#define EXC_MAC2_TRAP5			0x94
#define EXC_MAC2_TRAP6			0x98
#define EXC_MAC2_TRAP7			0x9c
#define EXC_MAC2_TRAP8			0xa0
#define EXC_MAC2_TRAP9			0xa4
#define EXC_MAC2_TRAP10			0xa8
#define EXC_MAC2_TRAP11			0xac
#define EXC_MAC2_TRAP12			0xb0
#define EXC_MAC2_TRAP13			0xb4
#define EXC_MAC2_TRAP14			0xb8
#define EXC_MAC2_TRAP15			0xbc
#define EXC_MAC2_FLT_BSUN		0xc0
#define EXC_MAC2_FLT_OPERAND_ERROR	0xd0

/*
 * EXC_ARITHMETIC
 */
#define EXC_MAC2_ZERO_DIVIDE		0x14
#define EXC_MAC2_FLT_INEXACT		0xc4
#define EXC_MAC2_FLT_ZERO_DIVIDE	0xc8
#define EXC_MAC2_FLT_UNDERFLOW		0xcc
#define EXC_MAC2_FLT_OVERFLOW		0xd4
#define EXC_MAC2_FLT_NOT_A_NUMBER	0xd8

/*
 * EXC_EMULATION
 */
#define EXC_MAC2_LINE_1010		0x28
#define EXC_MAC2_LINE_1111		0x2c

/*
 * EXC_SOFTWARE
 */
#define	EXC_MAC2_CHK			0x18
#define EXC_MAC2_TRAPV			0x1c

/*
 * EXC_BREAKPOINT
 */
#define EXC_MAC2_TRACE			0x24
#define EXC_MAC2_BREAKPOINT		0xbc

#endif	_MACH_MAC2_EXCEPTION_H_
@EOF@

echo "include/mach/machine/frame.h"
cat >include/mach/machine/frame.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	frame.h,v $
 * Revision 2.2.1.1  90/09/07  00:55:15  bohman
 * 	Final cleanup.
 * 	[90/09/07            bohman]
 * 
 * Revision 2.2  90/08/30  17:50:12  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/frame.h
 *	Author: David E. Bohman II (CMU macmach)
 */

#ifndef _MACH_MAC2_FRAME_H_
#define _MACH_MAC2_FRAME_H_

/*
 * MC68020/30 exception frames
 */

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
} normal_exception_frame_t;
#define STKFMT_NORMAL 0x0
#define NORMAL_EXCEPTION_FRAME_SIZE	sizeof (normal_exception_frame_t)

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned long f_instpc;
} special_exception_frame_t;
#define STKFMT_SPECIAL 0x2
#define SPECIAL_EXCEPTION_FRAME_SIZE	sizeof (special_exception_frame_t)

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned long f_instpc;
    unsigned long f_internal;
    unsigned long f_eea;
} coproc_exception_frame_t;
#define STKFMT_COPROC 0x9
#define COPROC_EXCEPTION_FRAME_SIZE	sizeof (coproc_exception_frame_t)

#define BUSERR_READ  1
#define BUSERR_WRITE 0

#define BUSERR_SIZE_LONG 0
#define BUSERR_SIZE_BYTE 1
#define BUSERR_SIZE_WORD 2

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned short f_internal;
    struct {
	unsigned short ssw_faultc:1,
		       ssw_faultb:1,
		       ssw_rerunc:1,
		       ssw_rerunb:1,
				 :3,
		       ssw_dfault:1,
			  ssw_rmw:1,
			   ssw_rw:1,
			 ssw_size:2,
				 :1,
			ssw_fcode:3;
    } f_ssw;
#define f_faultc f_ssw.ssw_faultc
#define f_faultb f_ssw.ssw_faultb
#define f_rerunc f_ssw.ssw_rerunc
#define f_rerunb f_ssw.ssw_rerunb
#define f_dfault f_ssw.ssw_dfault
#define f_rmw    f_ssw.ssw_rmw
#define f_rw     f_ssw.ssw_rw
#define f_size   f_ssw.ssw_size
#define f_fcode  f_ssw.ssw_fcode
    unsigned short f_ipsc;
    unsigned short f_ipsb;
    unsigned long f_fault;
    unsigned long f_internal2;
    unsigned long f_dob;
    unsigned long f_internal3;
} short_buserr_exception_frame_t;
#define STKFMT_SHORT_BUSERR 0xA
#define SHORT_BUSERR_EXCEPTION_FRAME_SIZE \
	sizeof (short_buserr_exception_frame_t)

typedef struct {
    unsigned short f_sr;
    unsigned long f_pc;
    unsigned short f_fmt:4,
		f_vector:12;
    unsigned short f_internal;
    struct {
	unsigned short ssw_faultc:1,
		       ssw_faultb:1,
		       ssw_rerunc:1,
		       ssw_rerunb:1,
				 :3,
		       ssw_dfault:1,
			  ssw_rmw:1,
			   ssw_rw:1,
			 ssw_size:2,
				 :1,
			ssw_fcode:3;
    } f_ssw;
    unsigned short f_ipsc;
    unsigned short f_ipsb;
    unsigned long f_fault;
    unsigned long f_internal2;
    unsigned long f_dob;
    unsigned long f_internal3;
    unsigned long f_internal4;
    unsigned long f_stageb;
    unsigned long f_internal5;
    unsigned long f_dib;
    unsigned long f_internal6[11];
} long_buserr_exception_frame_t;
#define STKFMT_LONG_BUSERR 0xB
#define LONG_BUSERR_EXCEPTION_FRAME_SIZE \
	sizeof (long_buserr_exception_frame_t)

/*
 * Generic exception frame
 */
typedef union {
    normal_exception_frame_t	f_normal;
    special_exception_frame_t	f_special;
    coproc_exception_frame_t	f_coproc;
    short_buserr_exception_frame_t
				f_short_buserr;
    long_buserr_exception_frame_t
				f_long_buserr;
} generic_exception_frame_t;

#endif	_MACH_MAC2_FRAME_H_
@EOF@

echo "include/mach/machine/kern_return.h"
cat >include/mach/machine/kern_return.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	kern_return.h,v $
 * Revision 2.2  90/08/30  17:50:36  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/kern_return.h
 */

#ifndef	_MACH_MAC2_KERN_RETURN_H_
#define	_MACH_MAC2_KERN_RETURN_H_

typedef	int		kern_return_t;

#endif	_MACH_MAC2_KERN_RETURN_H_
@EOF@

echo "include/mach/machine/reg.h"
cat >include/mach/machine/reg.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	reg.h,v $
 * Revision 2.2.1.1  90/09/07  00:54:19  bohman
 * 	Final cleanup.
 * 	[90/09/07            bohman]
 * 
 * Revision 2.2  90/09/04  17:13:05  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/reg.h
 *	Author: David E. Bohman II (CMU macmach)
 */

#ifndef _MACH_MAC2_REG_H_
#define _MACH_MAC2_REG_H_

/*
 * Format of saved 68020/30
 * processor registers.
 */
typedef struct regs {
    int	r_dreg[8];		/* data registers */
#define r_r0 r_dreg[0]
#define r_r1 r_dreg[1]
    int	r_areg[8];		/* address registers */
#define r_sp	r_areg[7]
} regs_t;

/*
 * Format of 68881/2 floating
 * point register.
 */
typedef	struct {
    unsigned long	fp[3];
} fp_reg_t;

/*
 * Total register state for the FPU.
 */
typedef struct {
    fp_reg_t		fps_regs[8];		/* floating point regs */
    unsigned long	fps_control;		/* control reg */
    unsigned long	fps_status;		/* status reg */
    unsigned long	fps_iaddr;		/* instr address reg */
} fp_state_t;

/*
 * Internal state for the FPU.
 */
#define FPF_NULL_SIZE	0
#define FPF_IDLE_SIZE	0x18
#define FPF_BUSY_SIZE	0xd4

typedef union {
    unsigned long	fpf_format;		/* format word */
    struct {
	unsigned char	fpff_version;		/* version number */
	unsigned char	fpff_size;		/* size of frame */
	unsigned short	fpff_mbz;
	union {
	    struct {
		unsigned short	fpffi_ccr;	/* command/cond register */
		unsigned short	fpffi_mbo;
		unsigned char	fpffi_opnd[12];	/* exceptional operand */
		unsigned long	fpffi_opnd_reg;	/* operand register */
		unsigned long	fpffi_biu_flgs;	/* biu flags */
	    } fpffs_idle_data;
	    unsigned char	fpffs_busy_data[FPF_BUSY_SIZE];
	} fpff_extra;
    } fpf_frame;
} fp_frame_t;
#define fpf_version	fpf_frame.fpff_version
#define fpf_size	fpf_frame.fpff_size
#define fpf_data	fpf_frame.fpff_extra

#endif _MACH_MAC2_REG_H_
@EOF@

echo "include/mach/machine/syscall_sw.h"
cat >include/mach/machine/syscall_sw.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	syscall_sw.h,v $
 * Revision 2.2  90/08/30  17:51:32  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/syscall_sw.h
 */

#ifndef	_MACH_MAC2_SYSCALL_SW_H_
#define _MACH_MAC2_SYSCALL_SW_H_

#define kernel_trap(trap_name, trap_number, number_args) \
	.globl	_##trap_name; \
 _##trap_name: \
	pea	trap_number; \
	trap	\#0; \
	rts

#endif	_MACH_MAC2_SYSCALL_SW_H_
@EOF@

echo "include/mach/machine/thread_status.h"
cat >include/mach/machine/thread_status.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	thread_status.h,v $
 * Revision 2.2.1.1  90/09/07  00:53:12  bohman
 * 	Final cleanup.
 * 	[90/09/07            bohman]
 * 
 * Revision 2.2  90/08/30  17:51:48  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/thread_status.h
 *	Author: David E. Bohman II (CMU macmach)
 */

/*
 * This file contains the structure definitions for the thread
 * state as applied to Macintosh II computers 68020/30 with 68881/2.
 */

#ifndef	_MACH_MAC2_THREAD_STATUS_H_
#define	_MACH_MAC2_THREAD_STATUS_H_

#include <:mach:mac2:reg.h>
#include <:mach:mac2:frame.h>

/*
 * Thread processor registers.
 */
#define	THREAD_STATE_REGS	1

typedef regs_t	thread_state_regs_t;
#define	THREAD_STATE_REGS_COUNT		\
    (sizeof(thread_state_regs_t)/sizeof (long))

/*
 * Thread fpu registers.
 */
#define THREAD_STATE_FPREGS	2

typedef fp_state_t	thread_state_fpregs_t;
#define THREAD_STATE_FPREGS_COUNT	\
    (sizeof (thread_state_fpregs_t)/sizeof (long))

/*
 * Thread processor state frame.
 */
#define THREAD_STATE_FRAME	3

typedef generic_exception_frame_t	thread_state_frame_t;
#define THREAD_STATE_FRAME_COUNT	\
    (sizeof (thread_state_frame_t)/sizeof (long))

/*
 * Thread fpu state frame.
 */
#define THREAD_STATE_FPFRAME	4

typedef fp_frame_t	thread_state_fpframe_t;
#define THREAD_STATE_FPFRAME_COUNT	\
    (sizeof (thread_state_fpframe_t)/sizeof (long))

#endif	_MACH_MAC2_THREAD_STATUS_H_
@EOF@

echo "include/mach/machine/vm_param.h"
cat >include/mach/machine/vm_param.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_param.h,v $
 * Revision 2.2  90/08/30  17:52:05  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/vm_param.h
 *	Author: David E. Bohman II (CMU macmach)
 */

#ifndef _MACH_MAC2_VM_PARAM_H_
#define _MACH_MAC2_VM_PARAM_H_

#include <:mac2:machparam.h>

#define BYTE_SIZE	8	/* byte size in bits */

#define MAC2_PGBYTES	8192	/* bytes per page */
#define MAC2_PGSHIFT	13	/* number of bits to shift for pages */

/*
 *	Convert bytes to pages and convert pages to bytes.
 *	No rounding is used.
 */

#define	mac2_btop(x)		(((unsigned)(x)) >> MAC2_PGSHIFT)
#define	mac2_ptob(x)		(((unsigned)(x)) << MAC2_PGSHIFT)

/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.
 */

#define mac2_round_page(x)	((((unsigned)(x)) + MAC2_PGBYTES - 1) & \
					~(MAC2_PGBYTES-1))
#define mac2_trunc_page(x)	(((unsigned)(x)) & ~(MAC2_PGBYTES-1))

/*
 * Macintosh II implementation
 * uses separate user and
 * kernel address spaces.
 *
 */
#define	VM_MIN_ADDRESS	((vm_offset_t) 0)
#define	VM_MAX_ADDRESS	((vm_offset_t) 0xffffffff)

#define VM_MIN_KERNEL_ADDRESS	((vm_offset_t) 0x0)
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t) 0xffffffff)

#define	KERNEL_STACK_SIZE	MAC2_PGBYTES

#define INTSTACK_SIZE		MAC2_PGBYTES

/*
 *	Conversion between mac2 pages and VM pages
 */

#define trunc_mac2_to_vm(p)	(atop(trunc_page(mac2_ptob(p))))
#define round_mac2_to_vm(p)	(atop(round_page(mac2_ptob(p))))
#define vm_to_mac2(p)		(mac2_btop(ptoa(p)))

#endif	_MACH_MAC2_VM_PARAM_H_
@EOF@

echo "include/mach/machine/vm_types.h"
cat >include/mach/machine/vm_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1990 Carnegie-Mellon University
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	vm_types.h,v $
 * Revision 2.2  90/08/30  17:52:27  bohman
 * 	Created.
 * 
 */

/*
 *	Apple Macintosh II Mach (macmach)
 *
 *	File: mach/mac2/vm_types.h
 */

#ifndef	_MACH_MAC2_VM_TYPES_H_
#define	_MACH_MAC2_VM_TYPES_H_

#ifdef	ASSEMBLER
#else	ASSEMBLER
typedef	unsigned int	vm_offset_t;
typedef	unsigned int	vm_size_t;
#endif	ASSEMBLER

#endif	_MACH_MAC2_VM_TYPES_H_
@EOF@

echo "include/mach_debug/callout_statistics.h"
cat >include/mach_debug/callout_statistics.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	callout_statistics.h,v $
 * Revision 2.4  89/03/09  20:26:02  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:43:24  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/12  07:59:40  rpd
 * 	Created.
 * 	[89/01/12  04:22:24  rpd]
 * 
 */ 

#ifndef	_MACH_DEBUG_CALLOUT_STATISTICS_H_
#define _MACH_DEBUG_CALLOUT_STATISTICS_H_

/*
 *	Remember to update the mig type definition
 *	in mach_debug_types.defs when adding/removing fields.
 */

typedef struct callout_info {
	int	coi_time;
	char	*coi_arg;
	int	(*coi_func)();
} callout_info_t;

typedef callout_info_t *callout_info_array_t;


/*
 *	Remember to update the mig type definition
 *	in mach_debug_types.defs when adding/removing fields.
 */

typedef struct callout_statistics {
	int	cos_current_size;	/* current length of the queue */

	int	cos_num_timeout;	/* number of times timeout called */
	int	cos_cum_timeout_size;	/* cum. size when timeout called */
	int	cos_cum_timeout_pos;	/* cum. position of new event */

	int	cos_num_untimeout;	/* number of times untimeout called */
	int	cos_num_untimeout_hit;	/* num. times found an event */
	int	cos_cum_untimeout_size;	/* cum. size when untimeout called */
	int	cos_cum_untimeout_pos;	/* cum. position of old event */

	int	cos_num_softclock;	/* num. of events softclock removed */
	int	cos_cum_softclock_size;	/* cum. size when event removed */
} callout_statistics_t;

#ifdef	KERNEL
#include <mach_co_stats.h>

#if	MACH_CO_STATS
extern callout_statistics_t callout_statistics;
extern int callout_statistics_fudge;

#define callout_statistics_invariant()			\
((callout_statistics.cos_num_timeout -			\
  (callout_statistics.cos_num_softclock +		\
   callout_statistics.cos_num_untimeout_hit)) ==	\
 (callout_statistics.cos_current_size +			\
  callout_statistics_fudge))
#endif	MACH_CO_STATS

#endif	KERNEL
#endif	_MACH_DEBUG_CALLOUT_STATISTICS_H_
@EOF@

echo "include/mach_debug/ipc_statistics.h"
cat >include/mach_debug/ipc_statistics.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	ipc_statistics.h,v $
 * Revision 2.7  89/05/11  14:41:42  gm0w
 * 	Added ipc_bucket_info_t, ipc_bucket_info_array_t.
 * 	[89/05/07  20:12:10  rpd]
 * 
 * Revision 2.6  89/05/01  17:03:24  rpd
 * 	Renamed port_copyout_hits to port_copyin_miss.
 * 	[89/05/01  14:12:32  rpd]
 * 
 * Revision 2.5  89/03/09  20:26:08  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:43:30  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/01/15  16:32:13  rpd
 * 	Use decl_simple_lock_data.
 * 	[89/01/15  15:10:25  rpd]
 * 
 * Revision 2.2  89/01/12  07:59:55  rpd
 * 	Created.
 * 	[89/01/12  04:23:06  rpd]
 * 
 */ 

#ifndef	_MACH_DEBUG_IPC_STATISTICS_H_
#define _MACH_DEBUG_IPC_STATISTICS_H_

/*
 *	Remember to update the mig type definition
 *	in mach_debug_types.defs when adding/removing fields.
 */

typedef struct ipc_statistics {
	int		version;
	int		messages;
	int		complex;
	int		kernel;
	int		large;
	int		current;
	int		emergency;
	int		notifications;
	int		port_copyins;
	int		port_copyouts;
	int		port_copyin_hits;
	int		port_copyin_miss;
	int		port_allocations;
	int		bucket_misses;
	int		ip_data_grams;
} ipc_statistics_t;

typedef struct ipc_bucket_info {
	int		count;		/* number of records in bucket */
} ipc_bucket_info_t;

typedef ipc_bucket_info_t *ipc_bucket_info_array_t;

#ifdef	KERNEL
#include <mach_ipc_stats.h>

#include <:kern:lock.h>
#include <:kern:macro_help.h>

decl_simple_lock_data(extern,ipc_statistics_lock_data)
extern ipc_statistics_t ipc_statistics;

extern void ipc_stats_init();

#define ipc_statistics_lock()	simple_lock(&ipc_statistics_lock_data)
#define ipc_statistics_unlock()	simple_unlock(&ipc_statistics_lock_data)

#if	MACH_IPC_STATS
#define ipc_event_count(field, count)		\
MACRO_BEGIN					\
	ipc_statistics_lock();			\
	ipc_statistics.field += count;		\
	ipc_statistics_unlock();		\
MACRO_END
#else	MACH_IPC_STATS
#define ipc_event_count(field, count)
#endif	MACH_IPC_STATS

#define ipc_event(field)		ipc_event_count(field, 1)

#endif	KERNEL
#endif	_MACH_DEBUG_IPC_STATISTICS_H_
@EOF@

echo "include/mach_debug/mach_debug.defs"
cat >include/mach_debug/mach_debug.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_debug.defs,v $
 * Revision 2.8  89/05/11  14:41:47  gm0w
 * 	Added host_ipc_bucket_info.
 * 	[89/05/07  20:12:30  rpd]
 * 
 * Revision 2.7  89/05/06  02:58:21  rpd
 * 	Added host_zone_info.
 * 	[89/05/06  02:45:24  rpd]
 * 
 * Revision 2.6  89/05/01  18:09:49  rpd
 * 	Don't define KERNEL_SERVER here; it's passed in now.
 * 
 * Revision 2.5  89/03/09  20:26:14  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:43:35  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/01/15  16:32:28  rpd
 * 	Updated includes for the new mach/ directory.
 * 	[89/01/15  15:11:01  rpd]
 * 
 * Revision 2.2  89/01/12  08:00:17  rpd
 * 	Created.
 * 	[89/01/12  04:20:38  rpd]
 * 
 */
/*
 *	Matchmaker definitions file for Mach kernel debugging interface.
 */

#ifdef	KERNEL
#include <mach_ipc_stats.h>
#include <mach_co_info.h>
#include <mach_co_stats.h>
#else
#define MACH_IPC_STATS		1
#define MACH_CO_INFO		1
#define MACH_CO_STATS		1
#endif	KERNEL

subsystem mach_debug 3000;


#include <:mach:mach_types.defs>
#include <:mach_debug:mach_debug_types.defs>

#if	MACH_IPC_STATS
/*
 *	Returns the accumulated Mach IPC statistics.
 */
routine host_ipc_statistics(
		task		: task_t;	/* should be a host port */
	out	statistics	: ipc_statistics_t);

/*
 *
 *	Resets the Mach IPC statistics counters.
 */
routine host_ipc_statistics_reset(
		task		: task_t);	/* should be a host port */

#else	MACH_IPC_STATS
skip;	/* host_ipc_statistics */
skip;	/* host_ipc_statistics_reset */
#endif	MACH_IPC_STATS

#if	MACH_CO_INFO
/*
 *	Returns the current call-out queue.
 */
routine host_callout_info(
		task		: task_t;	/* should be a host port */
	out	info		: callout_info_array_t);

#else	MACH_CO_INFO
skip;	/* host_callout_info */
#endif	MACH_CO_INFO

#if	MACH_CO_STATS
/*
 *	Returns the accumulated Mach call-out statistics.
 */
routine host_callout_statistics(
		task		: task_t;	/* should be a host port */
	out	statistics	: callout_statistics_t);

/*
 *
 *	Resets the Mach call-out statistics counters.
 */
routine host_callout_statistics_reset(
		task		: task_t);	/* should be a host port */

#else	MACH_CO_STATS
skip;	/* host_callout_statistics */
skip;	/* host_callout_statistics_reset */
#endif	MACH_CO_STATS

/*
 *	Returns information about the memory allocation zones.
 */
routine host_zone_info(
		task		: task_t;	/* should be a host port */
	out	names		: zone_name_array_t;
	out	info		: zone_info_array_t);

#if	MACH_IPC_STATS
/*
 *	Returns information about the buckets in the IPC hash tables.
 */
routine host_ipc_bucket_info(
		task		: task_t;	/* should be a host port */
	out	TLinfo		: ipc_bucket_info_array_t;
	out	TPinfo		: ipc_bucket_info_array_t);

#else	MACH_IPC_STATS
skip;	/* host_ipc_bucket_info */
#endif	MACH_IPC_STATS
@EOF@

echo "include/mach_debug/mach_debug_types.defs"
cat >include/mach_debug/mach_debug_types.defs <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_debug_types.defs,v $
 * Revision 2.7  89/05/11  14:41:55  gm0w
 * 	Added ipc_bucket_info_t, ipc_bucket_info_array_t.
 * 	[89/05/07  20:12:59  rpd]
 * 
 * Revision 2.6  89/05/06  02:58:32  rpd
 * 	Added zone_{name,info}{,_array}_t.
 * 	[89/05/06  02:46:20  rpd]
 * 
 * Revision 2.5  89/03/09  20:26:20  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:43:41  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/01/15  16:32:43  rpd
 * 	Updated includes for the new mach/ directory.
 * 	[89/01/15  15:11:33  rpd]
 * 
 * Revision 2.2  89/01/12  08:00:34  rpd
 * 	Created.
 * 	[89/01/12  04:21:37  rpd]
 * 
 */
/*
 *	Mach kernel debugging interface type declarations
 */

#ifndef	_MACH_DEBUG_MACH_DEBUG_TYPES_DEFS_
#define _MACH_DEBUG_MACH_DEBUG_TYPES_DEFS_

#include <:mach:std_types.defs>

type ipc_statistics_t = struct[15] of int;

type ipc_bucket_info_t = struct[1] of int;
type ipc_bucket_info_array_t = ^array[] of ipc_bucket_info_t;

type callout_info_t = struct[3] of int;
type callout_info_array_t = ^array[] of callout_info_t;

type callout_statistics_t = struct[10] of int;

type zone_name_t = struct[80] of char;
type zone_name_array_t = ^array[] of zone_name_t;

type zone_info_t = struct[8] of int;
type zone_info_array_t = ^array[] of zone_info_t;

import <mach_debug/mach_debug_types.h>;

#endif	_MACH_DEBUG_MACH_DEBUG_TYPES_DEFS_
@EOF@

echo "include/mach_debug/mach_debug_types.h"
cat >include/mach_debug/mach_debug_types.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_debug_types.h,v $
 * Revision 2.5  89/05/06  02:58:37  rpd
 * 	Include <mach_debug/zone_info.h>.
 * 	[89/05/06  02:46:43  rpd]
 * 
 * Revision 2.4  89/03/09  20:26:26  rpd
 * 	More cleanup.
 * 
 * Revision 2.3  89/02/25  18:43:46  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.2  89/01/12  08:00:53  rpd
 * 	Created.
 * 	[89/01/12  04:23:42  rpd]
 * 
 */
/*
 *	Mach kernel debugging interface type declarations
 */

#ifndef	_MACH_DEBUG_MACH_DEBUG_TYPES_H_
#define _MACH_DEBUG_MACH_DEBUG_TYPES_H_

#include <:mach_debug:ipc_statistics.h>
#include <:mach_debug:callout_statistics.h>
#include <:mach_debug:zone_info.h>

#endif	_MACH_DEBUG_MACH_DEBUG_TYPES_H_
@EOF@

echo "include/mach_debug/zone_info.h"
cat >include/mach_debug/zone_info.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	zone_info.h,v $
 * Revision 2.2  89/05/06  12:36:08  rpd
 * 	Created.
 * 	[89/05/06  12:35:19  rpd]
 * 
 */ 

#ifndef	_MACH_DEBUG_ZONE_INFO_H_
#define _MACH_DEBUG_ZONE_INFO_H_

#include <:mach:boolean.h>
#include <:mach:machine:vm_types.h>

/*
 *	Remember to update the mig type definition
 *	in mach_debug_types.defs when adding/removing fields.
 */

#define ZONE_NAME_MAX_LEN		80

typedef struct zone_name {
	char		name[ZONE_NAME_MAX_LEN];
} zone_name_t;

typedef zone_name_t *zone_name_array_t;


typedef struct zone_info {
	int		count;		/* Number of elements used now */
	vm_size_t	cur_size;	/* current memory utilization */
	vm_size_t	max_size;	/* how large can this zone grow */
	vm_size_t	elem_size;	/* size of an element */
	vm_size_t	alloc_size;	/* size used for more memory */
	boolean_t	pageable;	/* zone pageable? */
	boolean_t	sleepable;	/* sleep if empty? */
	boolean_t	exhaustible;	/* merely return if empty? */
} zone_info_t;

typedef zone_info_t *zone_info_array_t;

#endif	_MACH_DEBUG_ZONE_INFO_H_
@EOF@

echo "include/mig_errors.h"
cat >include/mig_errors.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mig_errors.h,v $
 * Revision 2.6  90/07/03  16:39:02  mrt
 * 	Merged mt Xinu 2.6MSD Changes.
 * 	[90/05/17  17:55:56  mrt]
 * 
 * Revision 1.8  89/11/30  17:49:44  mrt
 * 	Changed one more instance of hc to __HC__
 * 	[89/11/30            pds]
 * 
 * Revision 1.7  89/05/20  22:17:01  mrt
 * 	Source in kernel/mach/mig_errors.h
 * 
 * Revision 2.5  89/03/09  20:21:26  rpd
 * 	More cleanup.
 * 
 * Revision 2.4  89/02/25  18:38:41  gm0w
 * 	Changes for cleanup.
 * 
 * Revision 2.3  89/02/07  01:01:21  mwyoung
 * Relocated from sys/mig_errors.h
 * 
 * Revision 2.2  88/07/20  21:05:51  rpd
 * Added definition of mig_symtab_t.
 * 
 *  2-Dec-87  David Golub (dbg) at Carnegie-Mellon University
 *	Added MIG_ARRAY_TOO_LARGE.
 *
 * 25-May-87  Richard Draves (rpd) at Carnegie-Mellon University
 *	Added definition of death_pill_t.
 *
 * 31-Jul-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 * Mach Interface Generator errors
 *
 */

#ifndef	_MACH_MIG_ERRORS_H_
#define _MACH_MIG_ERRORS_H_

#include <:mach:kern_return.h>
#include <:mach:message.h>

#define MIG_TYPE_ERROR		-300		/* Type check failure */
#define MIG_REPLY_MISMATCH	-301		/* Wrong return message ID */
#define MIG_REMOTE_ERROR	-302		/* Server detected error */
#define MIG_BAD_ID		-303		/* Bad message ID */
#define MIG_BAD_ARGUMENTS	-304		/* Server found wrong arguments */
#define MIG_NO_REPLY		-305		/* Server shouldn't reply */
#define MIG_EXCEPTION		-306		/* Server raised exception */
#define MIG_ARRAY_TOO_LARGE	-307		/* User specified array not large enough
						   to hold returned array */

typedef struct {
	msg_header_t	Head;
	msg_type_t	RetCodeType;
	kern_return_t	RetCode;
} death_pill_t;

typedef struct mig_symtab {
	char	*ms_routine_name;
	int	ms_routine_number;
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(__HC__)
	void
#else
	int
#endif
		(*ms_routine)();
} mig_symtab_t;

#endif	_MACH_MIG_ERRORS_H_
@EOF@

echo "include/exception_all.h"
cat >include/exception_all.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	exception_all.h,v $
 * Revision 2.4  90/03/21  15:11:32  mrt
 * 	Added contents of mach/i386/exception.h
 * 	[90/03/21            mrt]
 * 
 * 	Added contents of mach/mmax/exception.h
 * 	[90/03/16            dlb]
 * 
 * Revision 2.3  90/03/07  16:00:31  mrt
 * 	Added contents of mach/mips/exception.h
 * 	[90/03/07            af]
 * 
 * 	Added contents mach/sun4/exception.h.
 * 	[90/02/21            jjc]
 * 
 * Revision 2.2  89/10/31  23:43:04  mrt
 * 	Combined mach/exception, mach/ca/exeption.h, 
 * 	mach/sun3/exception, mach/vax/exception.h
 * 	[89/10/29            mrt]
 * 
 *
 */

#ifndef	_EXCEPTION_ALL_H_
#define _EXCEPTION_ALL_H_

#ifndef _MACH_EXCEPTION_H_
#define _MACH_EXCEPTION_H_

/*
 *	Machine-independent exception definitions.
 */

#define EXC_BAD_ACCESS		1	/* Could not access memory */
		/* Code contains kern_return_t describing error. */
		/* Subcode contains bad memory address. */

#define EXC_BAD_INSTRUCTION	2	/* Instruction failed */
		/* Illegal or undefined instruction or operand */

#define EXC_ARITHMETIC		3	/* Arithmetic exception */
		/* Exact nature of exception is in code field */

#define EXC_EMULATION		4	/* Emulation instruction */
		/* Emulation support instruction encountered */
		/* Details in code and subcode fields	*/

#define EXC_SOFTWARE		5	/* Software generated exception */
		/* Exact exception is in code field. */
		/* Codes 0 - 0xFFFF reserved to hardware */
		/* Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) */

#define EXC_BREAKPOINT		6	/* Trace, breakpoint, etc. */
		/* Details in code field. */

#endif /* _MACH_EXCEPTION_H_ */

/* 	Machine dependent exceptions for the ibm_rt
 * 	Revision 2.5  89/06/30  22:33:38  rpd
 */

#ifndef	_MACH_CA_EXCEPTION_H_
#define _MACH_CA_EXCEPTION_H_

#include <:mach:kern_return.h>

/*
 *	EXC_BAD_ACCESS
 */
/*
 *	Romp has machine-dependent failure modes.  The codes
 *	are negative so as not to conflict with kern_return_t's.
 */
#define EXC_ROMP_MCHECK		((kern_return_t)-1) /* machine check */
#define EXC_ROMP_APC_BUG	((kern_return_t)-2) /* APC hardware bug */

/*
 * EXC_BAD_INSTRUCTION
 */
#define EXC_ROMP_PRIV_INST 	0x01
#define EXC_ROMP_ILLEGAL_INST	0x02

/*
 * EXC_BREAKPOINT
 */
#define EXC_ROMP_TRAP_INST 	0x01
#define EXC_ROMP_INST_STEP  	0x02

/*
 * EXC_ARITHMETIC
 *
 */

/*							   
 * Values for code when type == EXC_ARITHMETIC
 */							    

#define EXC_ROMP_FPA_EMUL	0x01
#define EXC_ROMP_68881		0x02
#define EXC_ROMP_68881_TIMEOUT	0x04
#define EXC_ROMP_FLOAT_SPEC	0x08

#endif	/* _MACH_CA_EXCEPTION_H_ */


/*
 *	Machine dependent exception definitions for the Sun3.
 * 	Revision 2.4  89/03/09  20:23:26  rpd
 */

#ifndef	_MACH_SUN3_EXCEPTION_H_
#define _MACH_SUN3_EXCEPTION_H_

/*
 *	EXC_BAD_INSTRUCTION
 */

#define EXC_SUN3_ILLEGAL_INSTRUCTION	0x10
#define EXC_SUN3_PRIVILEGE_VIOLATION	0x20
#define EXC_SUN3_COPROCESSOR		0x34
#define EXC_SUN3_TRAP1			0x84
#define EXC_SUN3_TRAP2			0x88
#define EXC_SUN3_TRAP3			0x8c
#define EXC_SUN3_TRAP4			0x90
#define EXC_SUN3_TRAP5			0x94
#define EXC_SUN3_TRAP6			0x98
#define EXC_SUN3_TRAP7			0x9c
#define EXC_SUN3_TRAP8			0xa0
#define EXC_SUN3_TRAP9			0xa4
#define EXC_SUN3_TRAP10			0xa8
#define EXC_SUN3_TRAP11			0xac
#define EXC_SUN3_TRAP12			0xb0
#define EXC_SUN3_TRAP13			0xb4
#define EXC_SUN3_TRAP14			0xb8
#define EXC_SUN3_FLT_BSUN		0xc0
#define EXC_SUN3_FLT_OPERAND_ERROR	0xd0

/*
 *	NOTE: TRAP0 is syscall, TRAP15 is breakpoint.
 */

/*
 *	EXC_ARITHMETIC
 */

#define EXC_SUN3_ZERO_DIVIDE		0x14
#define EXC_SUN3_FLT_INEXACT		0xc4
#define EXC_SUN3_FLT_ZERO_DIVIDE	0xc8
#define EXC_SUN3_FLT_UNDERFLOW		0xcc
#define EXC_SUN3_FLT_OVERFLOW		0xd4
#define EXC_SUN3_FLT_NOT_A_NUMBER	0xd8

/*
 *	EXC_EMULATION
 */

#define EXC_SUN3_LINE_1010		0x28
#define EXC_SUN3_LINE_1111		0x2c

/*
 *	EXC_SOFTWARE
 */

#define EXC_SUN3_CHK	0x18
#define EXC_SUN3_TRAPV	0x1c

/*
 *	EXC_BREAKPOINT
 */

#define EXC_SUN3_TRACE			0x24
#define EXC_SUN3_BREAKPOINT		0xbc

#endif	/* _MACH_SUN3_EXCEPTION_H_ */


/*
 *	Machine dependent exceptions for the vax
 * 	Revision 2.4  89/03/09  20:24:40  rpd
 */

/*
 *	EXC_BAD_INSTRUCTION
 */

#ifndef	_MACH_VAX_EXCEPTION_H_
#define _MACH_VAX_EXCEPTION_H_

#define EXC_VAX_PRIVINST		1
#define EXC_VAX_RESOPND			2
#define EXC_VAX_RESADDR			3
#define EXC_VAX_COMPAT			4

/*
 *	COMPAT subcodes
 */
#define EXC_VAX_COMPAT_RESINST		0
#define EXC_VAX_COMPAT_BPT		1
#define EXC_VAX_COMPAT_IOT		2
#define EXC_VAX_COMPAT_EMT		3
#define EXC_VAX_COMPAT_TRAP		4
#define EXC_VAX_COMPAT_RESOP		5
#define EXC_VAX_COMPAT_ODDADDR		6

/*
 *	EXC_ARITHMETIC
 */

#define EXC_VAX_INT_OVF			1
#define EXC_VAX_INT_DIV			2
#define EXC_VAX_FLT_OVF_T		3
#define EXC_VAX_FLT_DIV_T		4
#define EXC_VAX_FLT_UND_T		5
#define EXC_VAX_DEC_OVF			6

#define EXC_VAX_FLT_OVF_F		8
#define EXC_VAX_FLT_DIV_F		9
#define EXC_VAX_FLT_UND_F		10

/*
 *	EXC_SOFTWARE
 */

#define EXC_VAX_SUB_RNG			7

/*
 *	EXC_BREAKPOINT
 */

#define EXC_VAX_BPT			1
#define EXC_VAX_TRACE			2

#endif	/* _MACH_VAX_EXCEPTION_H_ */

/*
 *	Machine dependent exception definitions for Sun 4
 *	Revision 2.2.1.1  89/10/23  14:03:18  jjc
 */
#ifndef	_MACH_SUN4_EXCEPTION_H_
#define _MACH_SUN4_EXCEPTION_H_

/*
 *	EXC_BAD_INSTRUCTION
 */
#define	EXC_SUN4_UNIMPLEMENTED		0x2
#define	EXC_SUN4_PRIVILEGE_VIOLATION	0x3
#define	EXC_SUN4_WINDOW_OVERFLOW	0x5
#define	EXC_SUN4_ALIGNMENT		0x7

/*
 *	EXC_ARITHMETIC
 */
#define EXC_SUN4_FLT_EXCEPTION		0x8
#define EXC_SUN4_ZERO_DIVIDE		0x82

/*
 *	EXC_EMULATION
 */
#define	EXC_SUN4_TAG_OVERFLOW		0xa

/*
 *	EXC_BREAKPOINT
 */
#define	EXC_SUN4_BREAKPOINT	0x81	/* T_BREAKPOINT from sun4/trap.h */

#endif	/* _MACH_SUN4_EXCEPTION_H_ */


/*
 *	Machine dependent exceptions for mips
 * 	Revision 2.1  89/05/30  16:55:45  rvb
 */

#ifndef	_MACH_MIPS_EXCEPTION_H_
#define	_MACH_MIPS_EXCEPTION_H_

/*
 *	Codes and subcodes for Mips exceptions.
 */


/*
 *	Hardware level exceptions
 */

#define	EXC_MIPS_INT		0	/* interrupt */
#define	EXC_MIPS_MOD		1	/* TLB mod */
#define	EXC_MIPS_RMISS		2	/* Read TLB Miss */
#define	EXC_MIPS_WMISS		3	/* Write TLB Miss */
#define	EXC_MIPS_RADE		4	/* Read Address Error */
#define	EXC_MIPS_WADE		5	/* Write Address Error */
#define	EXC_MIPS_IBE		6	/* Instruction Bus Error */
#define	EXC_MIPS_DBE		7	/* Data Bus Error */
#define	EXC_MIPS_SYSCALL	8	/* SYSCALL */
#define	EXC_MIPS_BREAK		9	/* BREAKpoint */
#define	EXC_MIPS_II		10	/* Illegal Instruction */
#define	EXC_MIPS_CPU		11	/* CoProcessor Unusable */
#define	EXC_MIPS_OV		12	/* OVerflow */

/*
 *	Software exception codes
 */
#define	EXC_MIPS_SOFT_SEGV	16	/* Software detected seg viol */
#define	EXC_MIPS_SOFT_CPU	19	/* coprocessor unusable */


/*
 *	Bad instruction subcodes
 */

#define	EXC_MIPS_PRIVINST		1
#define	EXC_MIPS_RESOPND		2
#define	EXC_MIPS_RESADDR		3

/*
 *	EXC_ARITHMETIC subcodes
 */

#define	EXC_MIPS_FLT_UNIMP	1
#define	EXC_MIPS_FLT_INVALID	2
#define	EXC_MIPS_FLT_DIVIDE0	3
#define	EXC_MIPS_FLT_OVERFLOW	4
#define	EXC_MIPS_FLT_UNDERFLOW	5
#define	EXC_MIPS_FLT_INEXACT	6

/*
 *	EXC_BREAKPOINT subcodes
 */

#define	EXC_MIPS_BPT			1
#define EXC_MIPS_TRACE			2


#endif	/* _MACH_MIPS_EXCEPTION_H_ */

/*
 *	Codes and subcodes for ns32000 exceptions.
 *	Revision 2.5  89/03/09  20:21:39  rpd
 */

#ifndef	_MACH_MMAX_EXCEPTION_H_
#define _MACH_MMAX_EXCEPTION_H_

/*
 *	EXC_BAD_INSTRUCTION
 */

#define EXC_NS32K_FPU			3
#define EXC_NS32K_ILL			4
#define EXC_NS32K_UND			10

/*
 *	EXC_ARITHMETIC
 */

#define EXC_NS32K_FPU			3
#define EXC_NS32K_DVZ			6

/*
 *	FPU subcodes
 */

#define EXC_NS32K_FPU_UNDERFLOW 	1
#define EXC_NS32K_FPU_OVERFLOW		2
#define EXC_NS32K_FPU_DVZ		3
#define EXC_NS32K_FPU_ILLEGAL 		4
#define EXC_NS32K_FPU_INVALID		5
#define EXC_NS32K_FPU_INEXACT		6
#define EXC_NS32K_FPU_OPERAND		7

/*
 *	EXC_SOFTWARE
 */

#define EXC_NS32K_FLG			7

/*
 *	EXC_BREAKPOINT
 */

#define EXC_NS32K_BPT			8
#define EXC_NS32K_TRC			9

#endif	/* _MACH_MMAX_EXCEPTION_H_ */


#ifndef	_MACH_I386_EXCEPTION_H_
#define _MACH_I386_EXCEPTION_H_

#define EXC_I386_INVOP			1

/*
 *	EXC_ARITHMETIC
 */

#define EXC_I386_DIV			1
#define EXC_I386_INTO			2
#define EXC_I386_NOEXT			3
#define EXC_I386_EXTOVR			4
#define EXC_I386_EXTERR			5
#define EXC_I386_EMERR			6
#define EXC_I386_BOUND			7

/*
 *	EXC_SOFTWARE
 */

/*
 *	EXC_BAD_ACCESS
 */

/*
 *	EXC_BREAKPOINT
 */

#define EXC_I386_SGL			1
#define EXC_I386_BPT			2

#define EXC_I386_DIVERR		0	/* divide by 0 eprror		*/
#define EXC_I386_SGLSTP		1	/* single step			*/
#define EXC_I386_NMIFLT		2	/* NMI				*/
#define EXC_I386_BPTFLT		3	/* breakpoint fault		*/
#define EXC_I386_INTOFLT	4	/* INTO overflow fault		*/
#define EXC_I386_BOUNDFLT	5	/* BOUND instruction fault	*/
#define EXC_I386_INVOPFLT	6	/* invalid opcode fault		*/
#define EXC_I386_NOEXTFLT	7	/* extension not available fault*/
#define EXC_I386_DBLFLT		8	/* double fault			*/
#define EXC_I386_EXTOVRFLT	9	/* extension overrun fault	*/
#define EXC_I386_INVTSSFLT	10	/* invalid TSS fault		*/
#define EXC_I386_SEGNPFLT	11	/* segment not present fault	*/
#define EXC_I386_STKFLT		12	/* stack fault			*/
#define EXC_I386_GPFLT		13	/* general protection fault	*/
#define EXC_I386_PGFLT		14	/* page fault			*/
#define EXC_I386_EXTERRFLT	16	/* extension error fault	*/
#define EXC_I386_ENDPERR	33	/* emulated extension error flt	*/
#define EXC_I386_ENOEXTFLT	32	/* emulated ext not present	*/

#endif	/* _MACH_I386_EXCEPTION_H_ */

#ifndef _MACH_MAC2_EXCEPTION_H
#define _MACH_MAC2_EXCEPTION_H

/*
 * Machine dependent exception definitions for the Macintosh II.
 * This should agree with /usr/include/mac2/exception.h
 */

/*
 * EXC_BAD_INSTRUCTION
 */
#define	EXC_MAC2_ILLEGAL_INSTRUCTION	0x10
#define EXC_MAC2_PRIVILEGE_VIOLATION	0x20
#define EXC_MAC2_COPROCESSOR		0x34
#define EXC_MAC2_TRAP0			0x80
#define EXC_MAC2_TRAP1			0x84
#define EXC_MAC2_TRAP2			0x88
#define EXC_MAC2_TRAP3			0x8c
#define EXC_MAC2_TRAP4			0x90
#define EXC_MAC2_TRAP5			0x94
#define EXC_MAC2_TRAP6			0x98
#define EXC_MAC2_TRAP7			0x9c
#define EXC_MAC2_TRAP8			0xa0
#define EXC_MAC2_TRAP9			0xa4
#define EXC_MAC2_TRAP10			0xa8
#define EXC_MAC2_TRAP11			0xac
#define EXC_MAC2_TRAP12			0xb0
#define EXC_MAC2_TRAP13			0xb4
#define EXC_MAC2_TRAP14			0xb8
#define EXC_MAC2_TRAP15			0xbc
#define EXC_MAC2_FLT_BSUN		0xc0
#define EXC_MAC2_FLT_OPERAND_ERROR	0xd0

/*
 * EXC_ARITHMETIC
 */
#define EXC_MAC2_ZERO_DIVIDE		0x14
#define EXC_MAC2_FLT_INEXACT		0xc4
#define EXC_MAC2_FLT_ZERO_DIVIDE	0xc8
#define EXC_MAC2_FLT_UNDERFLOW		0xcc
#define EXC_MAC2_FLT_OVERFLOW		0xd4
#define EXC_MAC2_FLT_NOT_A_NUMBER	0xd8

/*
 * EXC_EMULATION
 */
#define EXC_MAC2_LINE_1010		0x28
#define EXC_MAC2_LINE_1111		0x2c

/*
 * EXC_SOFTWARE
 */
#define	EXC_MAC2_CHK			0x18
#define EXC_MAC2_TRAPV			0x1c

/*
 * EXC_BREAKPOINT
 */
#define EXC_MAC2_TRACE			0x24
#define EXC_MAC2_BREAKPOINT		0xbc

#endif	/* _MACH_MAC2_EXCEPTION_H */

#endif	/* _EXCEPTION_ALL_H_ */
@EOF@

echo "libmach/bcopy.c"
cat >libmach/bcopy.c <<'@EOF@'
/*
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@(#)bcopy.c	5.1 (Berkeley) 1/27/87";
#endif LIBC_SCCS and not lint

/*
 * bcopy -- vax movc3 instruction
 */
bcopy(src, dst, length)
	register char *src, *dst;
	register int length;
{
	if (length && src != dst)
		if ((unsigned int)dst < (unsigned int)src)
			if (((int)src | (int)dst | length) & 3)
				do	/* copy by bytes */
					*dst++ = *src++;
				while (--length);
			else {
				length >>= 2;
				do	/* copy by longs */
					*((long *)dst)++ = *((long *)src)++;
				while (--length);
			}
		else {			/* copy backwards */
			src += length;
			dst += length;
			if (((int)src | (int)dst | length) & 3)
				do	/* copy by bytes */
					*--dst = *--src;
				while (--length);
			else {
				length >>= 2;
				do	/* copy by shorts */
					*--((long *)dst) = *--((long *)src);
				while (--length);
			}
		}
	return(0);
}
@EOF@

echo "libmach/mach_init.c"
cat >libmach/mach_init.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_init.c,v $
 * Revision 1.1  90/02/19  18:08:20  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.3  89/06/13  16:07:25  mrt
 * 	Changed references to task_data to thread_reply as task_data() is
 * 	no longer exported from the kernel. Removed setting of
 * 	NameServerPort, the correct name is name_server_port.
 * 	[89/05/28            mrt]
 * 
 * Revision 1.2  89/05/05  18:45:30  mrt
 * 	Cleanup for Mach 2.5
 * 
 * 23-Nov-87  Mary Thompson (mrt) at Carnegie Mellon
 *	removed includes of <servers/msgn.h> and <servers/netname.h>
 *	as they are no longer used.
 *
 * 5-Oct-87   Mary Thompson (mrt) at Carnegie Mellon
 *	Added an extern void definition of mig_init to keep
 *	lint happy
 *
 * 30-Jul-87  Mary Thompson (mrt) at Carnegie Mellon
 *	Changed the intialization of the mig_reply_port to be
 *	a call to mig_init instead init_mach.
 *
 */

#define	MACH_INIT_SLOTS		1
#include <mach_init.h>
#include <mach.h>

extern void init_reply_port();
extern void mig_init();

#ifndef mac2_mpw_drvr
port_t		task_self_ =  PORT_NULL;
port_t		task_notify_ =  PORT_NULL;
port_t		thread_reply_ = PORT_NULL;

port_t		name_server_port = PORT_NULL;
port_t		environment_port = PORT_NULL;
port_t		service_port = PORT_NULL;

vm_size_t	vm_page_size;


port_array_t	mach_init_ports;
unsigned int	mach_init_ports_count;

#endif /* mac2_mpw_drvr */

int		mach_init()
{
#ifndef mac2_mpw_drvr
	vm_statistics_data_t vm_stat;

	/*
	 * undefine the macros defined in mach_init.h so that we
	 * can make the real kernel calls
	 */

#undef task_self()
#undef thread_reply()
#undef task_notify()

	/*
	 *	Get the important ports into the cached values,
	 *	as required by "mach_init.h".
	 */
	 
	task_self_ = task_self();
	thread_reply_ = thread_reply();
	task_notify_ = task_notify();

	/*
	 *	Initialize the single mig reply port
	 */

	mig_init(0);

	/*
	 *	Cache some other valuable system constants
	 */

	vm_statistics(task_self_, &vm_stat);
	vm_page_size = vm_stat.pagesize;
	
	/*
	 *	Find those ports important to every task.
	 */
	 
	if (mach_ports_lookup(task_self_, &mach_init_ports, &mach_init_ports_count) != KERN_SUCCESS)
		mach_init_ports_count = 0;

	name_server_port = mach_init_ports_count > (unsigned int)NAME_SERVER_SLOT 
			? mach_init_ports[NAME_SERVER_SLOT] : PORT_NULL;
	environment_port = mach_init_ports_count > ENVIRONMENT_SLOT ? mach_init_ports[ENVIRONMENT_SLOT] : PORT_NULL;
	service_port     = mach_init_ports_count > SERVICE_SLOT ? mach_init_ports[SERVICE_SLOT] : PORT_NULL;
	

	/* get rid of out-of-line data so brk has a chance of working */
	(void) vm_deallocate(task_self(),(vm_address_t)mach_init_ports,
				vm_page_size);


#endif /* mac2_mpw_drvr */
	return(0);
}

#ifndef mac2_mpw_drvr
int		(*mach_init_routine)() = mach_init;
#endif /* mac2_mpw_drvr */

#ifndef	lint
/*
 *	Routines which our library must suck in, to avoid
 *	a later library from referencing them and getting
 *	the wrong version.
 */
static replacements()
{
	sbrk(0);
	fork();
}
#endif	lint
@EOF@

echo "libmach/sbrk.c"
cat >libmach/sbrk.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * 10-Apr-90  Mary Thompson (mrt) at Carnegie-Mellon University
 *	Added asm(".data") for all assembly cases
 *
 * $Log:	sbrk.c,v $
 * Revision 1.4  90/01/25  15:34:43  mrt
 * 	Delinted call to vm_allocate
 * 	[90/01/25            mrt]
 * 
 * Revision 1.3  89/08/01  18:08:41  mrt
 * 	Mips support.
 * 	[89/07/12            af]
 * 
 * Revision 1.2  89/05/05  18:46:50  mrt
 * 	Changes to use new include files and general cleanup.
 * 	[89/04/25            mrt]
 * 
 * 20-Oct-87  Mary Thompson (mrt) at Carnegie Mellon
 *	Changed sbrk to vm_allocate at curbrk if possible
 *	to be compatible with the Unix sbrk on rts.
 *
 *  6-Apr-87  Mary Thompson (mrt) at Carnegie Mellon
 *	Added conditional defintions of curbrk and minbrk for
 *	lint.
 *
 *
 *  1-Dec-86  David L. Black (dlb) at Carnegie-Mellon University
 *	Multimax bug fix; put minbrk and curbrk in .data section.
 *
 *
 * 16-Oct-86  Michael Young (mwyoung) at Carnegie-Mellon University
 *	Fixed case where sbrk(0) was being mishandled; put in
 *	initialization to get break value right before first call.
 *
 *  2-Jun-86  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	sbrk.c
 *
 *	Unix compatibility for sbrk system call.
 */

#define  EXPORT_BOOLEAN
#include <mach.h>		/* for vm_allocate, vm_offset_t */
#include <stdio.h>		/* for stderr */
#include <:sys:types.h>		/* for caddr_t */
#include <mach_init.h>		/* for vm_page_size */

#if	(defined(vax) || defined(ibmrt) || defined(ns32000) || defined(sun) || defined(i386)) || defined(mac2)
#if	multimax
DEF_FUNC()
{
#endif	multimax
asm(".data");
asm(".globl	curbrk");
asm(".globl	minbrk");
asm(".globl	_curbrk");
asm(".globl	_minbrk");
asm(".globl	_end");
#if	multimax
asm("_minbrk:");
asm("minbrk:	.double	_end");
asm("_curbrk:");
asm("curbrk:	.double	_end");
asm(".text");
}
#else	multimax
asm("_minbrk:");
asm("minbrk:	.long	_end");
asm("_curbrk:");
asm("curbrk:	.long	_end");
asm(".text");
#endif	multimax
#else	(defined(vax) || defined(ibmrt) || defined(ns32000) || defined(sun) || defined (i386))

/* Will not find get "assembler" forms of cubrk, minbrk. */

#ifdef	mips
extern char end;
#define curbrk _curbrk
#define minbrk _minbrk
caddr_t curbrk = &end;
caddr_t minbrk = &end;
#endif	mips

#endif	(defined(vax) || defined(ibmrt) || defined(ns32000) || defined(sun) || defined(i386))

#ifdef lint
   /* lint doesn't see asm stuff */
caddr_t	curbrk;
caddr_t	minbrk;
#else lint
extern caddr_t curbrk;
extern caddr_t minbrk;
#endif lint

#define	roundup(a,b)	((((a) + (b) - 1) / (b)) * (b))

static int sbrk_needs_init = FALSE;

caddr_t sbrk(size)
	int	size;
{
	vm_offset_t	addr;
	kern_return_t	ret;
	caddr_t		ocurbrk;

	if (sbrk_needs_init) {
		sbrk_needs_init = FALSE;
		/*
		 *	Get "curbrk"
		 */

	}
	
	if (size <= 0)
		return(curbrk);
	addr = (vm_offset_t) roundup((int)curbrk,vm_page_size);
	ocurbrk = curbrk;
	if (((int)curbrk+size) > addr)
	{	ret = vm_allocate(task_self(), &addr, 
			    (vm_size_t) size -((int)addr-(int)curbrk), FALSE);
		if (ret == KERN_NO_SPACE) {
			ret = vm_allocate(task_self(), &addr, (vm_size_t) size, TRUE);
			ocurbrk = (caddr_t)addr;
		}
		if (ret != KERN_SUCCESS) 
			return((caddr_t) -1);
	}

	curbrk = (caddr_t)ocurbrk + size;
	return(ocurbrk);

}

void brk(x)
	caddr_t x;
{
	fprintf(stderr, "brk: not implemented\n");
}
@EOF@

echo "libmach/error_codes.c"
cat >libmach/error_codes.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	error_codes.c,v $
 * Revision 1.1  90/02/19  18:07:51  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.2  89/05/05  18:41:18  mrt
 * 	09-Mar-88	Douglas Orr (dorr) at Carnegie-Mellon University
 * 
 *	created.
 */
/*
 * File:	errr_codes.c
 * Purpose:
 *	Generic error code interface
 */

#include <:mach:error.h>
#include <:servers:errorlib.h>
#include "err_kern.sub"
#include "err_us.sub"
#include "err_server.sub"
#include "err_ipc.sub"


struct error_system errors[err_max_system+1] = {
	/* 0; err_kern */
	{
		errlib_count(err_os_sub),
		"(operating system/?) unknown subsystem error",
		err_os_sub,
	},
	/* 1; err_us */
	{
		errlib_count(err_us_sub),
		"(user space/?) unknown subsystem error",
		err_us_sub,
	},
	/* 2; err_server */
	{
		errlib_count(err_server_sub),
		"(server/?) unknown subsystem error",
		err_server_sub,
	},
	/* 3 (& 3f); err_ipc */
	{
		errlib_count(err_ipc_sub),
		"(ipc/?) unknown subsystem error",
		err_ipc_sub,
	},
};


int error_system_count = errlib_count(errors);


@EOF@

echo "libmach/mach_error.c"
cat >libmach/mach_error.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_error.c,v $
 * Revision 1.1  90/02/19  18:08:13  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.4  89/06/13  16:07:14  mrt
 * 	Changed to use zeroth error number. Changed map code for old
 * 	env_mgr errors to use 1600 instead of SERV_ENV_MOD which is noe
 * 	defined to be new value.
 * 	[89/05/24            mrt]
 * 
 * Revision 1.3  89/05/05  18:44:45  mrt
 * 	Cleanup for Mach 2.5
 * 
 *  12-May-88  Mary R. Thompson (mrt) at Carnegie Mellon
 *	Removed mach_error_print entry and added include
 *	 of mach_error.h	
 *
 *  09-Mar-88  Douglas Orr (dorr) at Carnegie Mellon
 *	Rewrote to deal with new structured error code.
 *	Added mach_error_type function and removed mach_errormsg
 *	which was the same as mach_error_string.
 */
/*
 *   mach_error.c
 *	interprets structured mach error codes and prints
 *	or returns a descriptive string. Will map old style
 *	unstructured error codes to new style if necessary.
 */

#ifndef mac2_mpw_drvr

#include <stdio.h>
#include <:mach:error.h>
#include <:mach:message.h>	/* compatibility */
#include <mig_errors.h>		/* compatibility */
#include <:servers:netname.h>	/* compatibility */
#include <:servers:env_mgr.h>	/* compatibility */
#include <:servers:ipcx_types.h>	/* compatibility */
#include <:servers:errorlib.h>
#include <mach_error.h>

static
do_compat( org_err )
	mach_error_t		* org_err;
{
	mach_error_t		err = *org_err;

	/* 
	 * map old error numbers to 
	 * to new error sys & subsystem 
	 */
	/* -100 */
	if( (err <= SEND_ERRORS_START) && (err > SEND_ERRORS_START-100) ) {
		err = -(err - SEND_ERRORS_START) | IPC_SEND_MOD;
	} else	/* -200 */
	if( (err <= RCV_ERRORS_START) && (err > RCV_ERRORS_START-100) ) {
		err = -(err - RCV_ERRORS_START) | IPC_RCV_MOD;
	} else	/* -300 */
	if( (err <= MIG_TYPE_ERROR) && (err > MIG_TYPE_ERROR-100) ) {
		err = -(err - MIG_TYPE_ERROR) | IPC_MIG_MOD;
	} else	/* 1000 */
	if( (err >= NAME_NOT_YOURS) && (err < NAME_NOT_YOURS+100) ) {
		err = (err - NAME_NOT_YOURS) | SERV_NETNAME_MOD;
	} else  /* 1600  used to be environment manager codes */
	if( (err >= 1600) && (err < 1700) ) {
		err = (err - 1600) | SERV_ENV_MOD;
	} else	/* 27600 */
	if( (err >= IPC_ERROR_BASE) && (err < IPC_ERROR_BASE+100) ) {
		err = (err - IPC_ERROR_BASE) | SERV_EXECD_MOD;
	};
	   

	*org_err = err;
}


void
mach_error( str, err )	
	char	*str;
	mach_error_t		err;
{
	char * err_str;
	char buf[1024];

	fputs( str, stderr );
	putc( ' ', stderr );

	do_compat( &err );

	if ( strcmp( err_str=mach_error_string(err), NO_SUCH_ERROR ) == 0 ) {
		sprintf( buf, "%s %s (%x)", mach_error_type(err), err_str, err );
		err_str = buf;
	}

	fputs( err_str, stderr );
	putc( '\n', stderr );
	
}


char *
mach_error_type( err )
	mach_error_t		err;
{
	int sub, system;

	do_compat( &err );

	sub = err_get_sub(err);
	system = err_get_system(err);

	if (system > err_max_system) return( "(?/?)" );
	if (sub >= errors[system].max_sub) return( errors[system].bad_sub );
	return( errors[system].subsystem[sub].subsys_name );
}

char *
mach_error_string( err )
	mach_error_t		err;
{
	int sub, system, code;

	do_compat( &err );

	sub = err_get_sub(err);
	system = err_get_system(err);
	code = err_get_code(err);

	if (system > err_max_system) return( "(?/?) unknown error system" );
	if (sub >= errors[system].max_sub) return( errors[system].bad_sub );
	if (code >= errors[system].subsystem[sub].max_code) return ( NO_SUCH_ERROR );
	return( errors[system].subsystem[sub].codes[code] );
}

#endif /* mac2_mpw_drvr */
@EOF@

echo "libmach/Ovfork.c"
cat >libmach/Ovfork.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	Ovfork.c,v $
 * Revision 1.1  90/02/19  18:07:12  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.2  89/05/05  18:38:10  mrt
 * 	Cleanup for Mach 2.5
 * 
 *
 *    Jan-15-87	Mary R. Thompson
 *	Started
 */
/*
 *  Abstract:
 *	Just calls fork, as the vfork kernel call no longer
 *	does anything different from fork.  The fork program calls
 *	mach_init for the child.
 */

  int vfork()
  {  return( fork());
  }
@EOF@

echo "libmach/slot_name.c"
cat >libmach/slot_name.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	slot_name.c,v $
 * Revision 1.6  90/03/05  18:31:24  mrt
 * 	Added changes for SPARC and Sun 4/{260,110}.
 * 	[90/02/21            jjc]
 * 
 * Revision 1.5  89/08/01  18:04:12  mrt
 * 	Added i386 and Mips boxes.
 * 	[89/05/24            af]
 * 
 * Revision 1.4  89/04/25  17:37:37  mrt
 * 	Added translations for RT_135 and SUN3_110 and SUN3_60.
 * 	[89/04/25            mrt]
 * 
 * 21-Oct-88  Alessandro Forin (af) at Carnegie-Mellon University
 *	Added Microvax III.
 * 12-May-88  David Black (dlb) at Carnegie Mellon
 *	added new MMAX types
 * 26-Jan-88  Mary Thompson (mrt) at Carnegie Mellon
 *	added case for CPU_SUBTYPE_RT_APC
 *
 * 28-Feb-87  Avadis Tevanian (avie) at Carnegie-Mellon University
 *	Created.
 *
 */
/*
 *	File:	slot_name.c
 *	Author:	Avadis Tevanian, Jr.
 *
 *	Convert machine slot values to human readable strings.
 */

#include <mach.h>

/*
 *	Convert the specified cpu_type/cpu_subtype pair to their
 *	human readable form.
 */
slot_name(cpu_type, cpu_subtype, cpu_name, cpu_subname)
	cpu_type_t	cpu_type;
	cpu_subtype_t	cpu_subtype;
	char		**cpu_name, **cpu_subname;
{
	register char	*name, *subname;

	switch (cpu_type) {
	case CPU_TYPE_VAX:
		name = "VAX";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_VAX780:	subname = "780"; break;
		case CPU_SUBTYPE_VAX785:	subname = "785"; break;
		case CPU_SUBTYPE_VAX750:	subname = "750"; break;
		case CPU_SUBTYPE_VAX730:	subname = "730"; break;
		case CPU_SUBTYPE_UVAXI:		subname = "MicroVax I"; break;
		case CPU_SUBTYPE_UVAXII:	subname = "MicroVax II"; break;
		case CPU_SUBTYPE_VAX8200:	subname = "8200"; break;
		case CPU_SUBTYPE_VAX8500:	subname = "8500"; break;
		case CPU_SUBTYPE_VAX8600:	subname = "8600"; break;
		case CPU_SUBTYPE_VAX8650:	subname = "8650"; break;
		case CPU_SUBTYPE_VAX8800:	subname = "8800"; break;
		case CPU_SUBTYPE_UVAXIII:	subname = "MicroVax III"; break;
		}
		break;
	case CPU_TYPE_ROMP:
		name = "ROMP";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_RT_PC:		subname = "RT/PC"; break;
		case CPU_SUBTYPE_RT_APC:	subname = "RT/APC"; break;
		case CPU_SUBTYPE_RT_135:	subname = "RT/135"; break;
		}
		break;
	case CPU_TYPE_MC68020:
		name = "MC68020";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_SUN3_50:	subname = "Sun-3/50"; break;
		case CPU_SUBTYPE_SUN3_160:	subname = "Sun-3/160"; break;
		case CPU_SUBTYPE_SUN3_260:	subname = "Sun-3/260"; break;
		case CPU_SUBTYPE_SUN3_110:	subname = "Sun-3/110"; break;
		case CPU_SUBTYPE_SUN3_60:	subname = "Sun-3/60"; break;
		}
		break;
	case CPU_TYPE_NS32032:
		name = "NS32032";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_MMAX_DPC: subname = "Multimax [DPC]"; break;
		case CPU_SUBTYPE_SQT:	subname = "Balance 21000"; break;
		}
		break;
	case CPU_TYPE_NS32332:
		name = "NS32332";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_MMAX_APC_FPU: subname = "Multimax [APC]";
							break;
		case CPU_SUBTYPE_MMAX_APC_FPA:
			subname = "Multimax [APC] with FPA"; break;
		}
		break;
	case CPU_TYPE_NS32532:
		name = "NS32532";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_MMAX_XPC: subname = "Multimax [XPC]"; break;
		}
		break;
	case CPU_TYPE_I386:
		name = "I386";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_AT386: subname = "i386 [AT]"; break;
		case CPU_SUBTYPE_EXL: subname = "i386 [EXL]"; break;
		}
		break;
	case CPU_TYPE_MIPS:
		name = "MIPS";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_MIPS_R2300: subname = "R2300"; break;
		case CPU_SUBTYPE_MIPS_R2600: subname = "R2600"; break;
		case CPU_SUBTYPE_MIPS_R2800: subname = "R2800"; break;
		case CPU_SUBTYPE_MIPS_R2000a: subname = "R2000a"; break;
		}
		break;
	case CPU_TYPE_SPARC:
		name = "SPARC";
		switch (cpu_subtype) {
		case CPU_SUBTYPE_SUN4_260:	subname = "Sun-4/260"; break;
		case CPU_SUBTYPE_SUN4_110:	subname = "Sun-4/110"; break;
		}
		break;
	default:
		name = "Unknown CPU";
		subname = "";
		break;
	}
	*cpu_name = name;
	*cpu_subname = subname;
}

@EOF@

echo "libmach/mig_support.c"
cat >libmach/mig_support.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mig_support.c,v $
 * Revision 1.1  90/02/19  18:08:34  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.4  89/06/13  16:07:33  mrt
 * 	Replaced instances of task_data with thread_reply.
 * 	[89/05/28            mrt]
 * 
 * Revision 1.3  89/05/05  18:46:11  mrt
 * 	Cleanup for Mach 2.5
 * 
 *
 *  12-May-88	Mary Thompson (mrt) at Carnegie Mellon
 *	included mach_error.h to remove lint
 *  30-Jul-87	Mary Thompson (mrt) at Carnegie Mellon
 *	started
 */
/*
 *  Abstract:
 *	Routines to set and deallocate the mig reply port.
 *	They are called from mig generated interfaces.
 */

#include <mach.h>
#include <stdio.h>
#include <mach_error.h>

#ifndef mac2
static port_t	mig_reply_port;
#endif

void mig_init(first)
/*****************************************************
 *  Called by mach_init. This is necessary after
 *  a fork to get rid of bogus port  number.
 ****************************************************/
    int	first;
{
#ifdef mac2
	/* do nothing */
#else
	if (first == 0)
		mig_reply_port = PORT_NULL;
	else
	{   fprintf(stderr,"Calling non-threads version of mig_int\n");
	    fflush(stderr);
	}
#endif
}


port_t mig_get_reply_port()
/********************************************************
 *  Called by mig interfaces whenever they  need a reply port.
 *  Used to provide the same interface as multi-threaded tasks need.
 ********************************************************/
{
#ifdef mac2
	/* just return the thread reply port */
	return thread_reply();
#else
   kern_return_t	retcode;

 	if (mig_reply_port == PORT_NULL)
	{	mig_reply_port = thread_reply();
		retcode = port_allocate(task_self(), &mig_reply_port);
		if (retcode != KERN_SUCCESS)
		     mach_error("get_reply_port: failed allocating new reply port.",
				retcode);
	}
	return(mig_reply_port);
#endif
}

void mig_dealloc_reply_port()
/*************************************************************
 *  Called by mig interfaces after a timeout on the port.
 *  Could be called by user.
 ***********************************************************/
{
#ifdef mac2
	/* do nothing */
#else
   port_t		tmp_port;

	if (mig_reply_port != PORT_NULL)
	{	tmp_port = mig_reply_port;
		mig_reply_port = thread_reply();
		(void) port_deallocate(task_self(), tmp_port);
		mig_reply_port = PORT_NULL;
	}
#endif
}

@EOF@

echo "libmach/mig_strncpy.c"
cat >libmach/mig_strncpy.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mig_strncpy.c,v $
 * Revision 1.1  90/02/19  18:08:29  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 2.1  89/05/09  22:06:06  mrt
 * Created.
 * 
 */
/*
 * mig_strncpy.c - by Joshua Block
 *
 * mig_strncp -- Bounded string copy.  Does what the library routine strncpy
 * OUGHT to do:  Copies the (null terminated) string in src into dest, a 
 * buffer of length len.  Assures that the copy is still null terminated
 * and doesn't overflow the buffer, truncating the copy if necessary.
 *
 * Parameters:
 * 
 *     dest - Pointer to destination buffer.
 * 
 *     src - Pointer to source string.
 * 
 *     len - Length of destination buffer.
 */
void mig_strncpy(dest, src, len)
char *dest, *src;
int len;
{
    int i;

    if (len <= 0)
	return;

    for (i=1; i<len; i++)
	if (! (*dest++ = *src++))
	    return;

    *dest = '\0';
    return;
}
@EOF@

echo "libmach/msg.c"
cat >libmach/msg.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	msg.c,v $
 * Revision 1.4  90/02/23  18:46:23  mrt
 * 	Changed types of timeout args to msg_timeout_t and size
 * 	to msg_size_t
 * 	[90/02/08            mrt]
 * 
 * Revision 1.3  89/05/05  18:46:21  mrt
 * 	Cleanup for Mach 2.5
 * 
 *
 *  1-Feb-89  Bennet Yee (bsy) at Carnegie-Mellon University
 *	Fixed msg_{receive,send} if-if-else bug.
 *
 * 21-Oct-88  Richard Draves (rpd) at Carnegie-Mellon University
 *	Added msg_send wrapper, which handles SEND_INTERRUPT.
 *	Fixed bug in msg_rpc wrapper; it gave the wrong size to	msg_receive_.
 *	Converted to first try the new *_trap calls and fall back on
 *	the (renamed) *_old calls if they don't work.
 *
 * 19-May-87  Mary Thompson (mrt) at Carnegie-Mellon University
 *	Fixed the test for interupts in msg_rpc_.
 *	(Copied from mwyoung's version.)
 */

#include <:mach:kern_return.h>
#include <:mach:message.h>

extern msg_return_t msg_send_trap();
extern msg_return_t msg_receive_trap();
extern msg_return_t msg_rpc_trap();

msg_return_t	msg_send(header, option, timeout)
	msg_header_t	*header;
	msg_option_t	option;
	msg_timeout_t	timeout;
{
	register
	msg_return_t	result;


	result = msg_send_trap(header, option, header->msg_size, timeout);
	if (result == SEND_SUCCESS)
		return result;

	if (result == KERN_INVALID_ARGUMENT) {
		while ((result = msg_send_old(header, option, timeout))
		       			== SEND_INTERRUPTED)
			if (option & SEND_INTERRUPT)
				break;
	} else if ((result == SEND_INTERRUPTED) &&
		 !(option & SEND_INTERRUPT))
		do
			result = msg_send_trap(header, option,
					       header->msg_size, timeout);
		while (result == SEND_INTERRUPTED);

	return result;
}

msg_return_t	msg_receive(header, option, timeout)
	msg_header_t	*header;
	msg_option_t	option;
	msg_timeout_t	timeout;
{
	register
	msg_return_t	result;

	result = msg_receive_trap(header, option, header->msg_size,
				  header->msg_local_port, timeout);
	if (result == RCV_SUCCESS)
		return result;

	if (result == KERN_INVALID_ARGUMENT) {
		while ((result = msg_receive_old(header, option, timeout))
					== RCV_INTERRUPTED)
			if (option & RCV_INTERRUPT)
				break;
	} else if ((result == RCV_INTERRUPTED) &&
		 !(option & RCV_INTERRUPT))
		do
			result = msg_receive_trap(header, option,
						  header->msg_size,
						  header->msg_local_port,
						  timeout);
		while (result == RCV_INTERRUPTED);

	return result;
}

msg_return_t	msg_rpc(header, option, rcv_size, send_timeout, rcv_timeout)
	msg_header_t	*header;
	msg_option_t	option;
	msg_size_t	rcv_size;
	msg_timeout_t	send_timeout;
	msg_timeout_t	rcv_timeout;
{
	register
	msg_return_t	result;
	
	result = msg_rpc_trap(header, option, header->msg_size,
			      rcv_size, send_timeout, rcv_timeout);
	if (result == RPC_SUCCESS)
		return result;

	if (result == KERN_INVALID_ARGUMENT) {
		while ((result = msg_rpc_old(header, option, rcv_size,
					      send_timeout, rcv_timeout))
					== SEND_INTERRUPTED)
			if (option & SEND_INTERRUPT)
				return result;
		if ((result == RCV_INTERRUPTED) &&
		    !(option & RCV_INTERRUPT)) {
			header->msg_size = rcv_size;
			do
				result = msg_receive_old(header, option,
							 rcv_timeout);
			while (result == RCV_INTERRUPTED);
		}

		return result;
	} else if ((result == SEND_INTERRUPTED) &&
		   !(option & SEND_INTERRUPT)) {
		do
			result = msg_rpc_trap(header, option,
					      header->msg_size, rcv_size,
					      send_timeout, rcv_timeout);
		while (result == SEND_INTERRUPT);
	}

	if ((result == RCV_INTERRUPTED) &&
	    !(option & RCV_INTERRUPT))
		do
			result = msg_receive_trap(header, option, rcv_size,
						  header->msg_local_port,
						  rcv_timeout);
		while (result == RCV_INTERRUPTED);

	return result;
}
@EOF@

echo "libmach/XXX_pdp.c"
cat >libmach/XXX_pdp.c <<'@EOF@'
/*
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	XXX_pdp.c,v $
 * Revision 1.1  90/02/19  18:07:21  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.2  89/05/05  18:38:56  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*  
 * Abstract:
 *	Write around for the obsolete call pager_data_provided
 */

#include <mach.h>

#undef pager_data_provided

kern_return_t pager_data_provided(
	paging_request, offset, data, dataCnt, lock_value)
		vm_pager_request_t paging_request;
		vm_offset_t offset;
		pointer_t data;
		unsigned int dataCnt;
		vm_prot_t lock_value;
{
	return(memory_object_data_provided(
	paging_request, offset, data, dataCnt, lock_value));
}
@EOF@

echo "libmach/XXX_pds.c"
cat >libmach/XXX_pds.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	XXX_pds.c,v $
 * Revision 1.2  90/02/24  16:57:38  bww
 * 	Changed obsolete uses of "hc" symbol to "__HC__".
 * 	[90/02/24  16:57:05  bww]
 * 
 * Revision 1.1  90/02/19  18:07:24  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.2  89/05/05  18:39:08  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*  
 * Abstract:
 *	Write around for the obsolete calls to the default pager
 */

#include <:mach:message.h>
#include <mig_errors.h>

#ifndef	mig_internal
#define	mig_internal	static
#endif	mig_internal

#ifndef	TypeCheck
#define	TypeCheck 1
#endif	TypeCheck

#ifndef	UseExternRCSId
#if	__HC__
#define	UseExternRCSId		1
#endif	/* __HC__ */
#endif	UseExternRCSId

#ifndef	UseStaticMsgType
#if	!__HC__
#define	UseStaticMsgType	1
#endif	/* __HC__ */
#endif	UseStaticMsgType

/* Due to C compiler bug, cannot use void */
#if	__HC__ || defined(c_plusplus)
#define novalue void
#else	/* __HC__ */
#define novalue int
#endif	/* __HC__ */

#define EXPORT_BOOLEAN
#include <:mach:mach_types.h>

/* SimpleRoutine pager_create */
mig_internal novalue _Xpager_create(
#ifdef c_plusplus
	msg_header_t* InHeadP, msg_header_t* OutHeadP)
#else
	InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t new_paging_objectType;
		port_all_t new_paging_object;
		msg_type_t new_request_portType;
		port_t new_request_port;
		msg_type_t new_nameType;
		port_t new_name;
		msg_type_t new_page_sizeType;
		vm_size_t new_page_size;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *InP = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t pager_create(
#ifdef c_plusplus
		paging_object_t old_paging_object,
		port_all_t new_paging_object,
		port_t new_request_port,
		port_t new_name,
		vm_size_t new_page_size
#endif
	);

#if	TypeCheck
	if (InP->Head.msg_size != sizeof(Request))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
	if (InP->new_paging_objectType.msg_type_name != MSG_TYPE_PORT_ALL)
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
	if (InP->new_request_portType.msg_type_name != MSG_TYPE_PORT)
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
	if (InP->new_nameType.msg_type_name != MSG_TYPE_PORT)
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
	if (InP->new_page_sizeType.msg_type_name != MSG_TYPE_INTEGER_32)
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

	(void) pager_create(InP->Head.msg_local_port, InP->new_paging_object, InP->new_request_port, InP->new_name, InP->new_page_size);

	OutP->RetCode = MIG_NO_REPLY;
}

/* SimpleRoutine pager_data_initialize */
mig_internal novalue _Xpager_data_initialize(
#ifdef c_plusplus
	msg_header_t* InHeadP, msg_header_t* OutHeadP)
#else
	InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t pager_request_portType;
		port_t pager_request_port;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_long_t dataType;
		pointer_t data;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *InP = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t pager_data_initialize(
#ifdef c_plusplus
		paging_object_t paging_object,
		port_t pager_request_port,
		vm_offset_t offset,
		pointer_t data,
		unsigned int dataCnt
#endif
	);

#if	TypeCheck
	if (InP->Head.msg_size != sizeof(Request))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
	if (InP->pager_request_portType.msg_type_name != MSG_TYPE_PORT)
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
	if (InP->offsetType.msg_type_name != MSG_TYPE_INTEGER_32)
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
	if (InP->dataType.msg_type_long_name != MSG_TYPE_INTEGER_8)
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

	(void) pager_data_initialize(InP->Head.msg_local_port, InP->pager_request_port, InP->offset, InP->data, InP->dataType.msg_type_long_number);

	OutP->RetCode = MIG_NO_REPLY;
}

boolean_t pager_default_server(
#ifdef c_plusplus
	msg_header_t* InHeadP, msg_header_t* OutHeadP)
#else
	InHeadP, OutHeadP)
		msg_header_t *InHeadP, *OutHeadP;
#endif
{
	register msg_header_t *InP =  InHeadP;
	register death_pill_t *OutP = (death_pill_t *) OutHeadP;

#if	UseStaticMsgType
	static msg_type_t RetCodeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
	};
#endif	UseStaticMsgType

	OutP->Head.msg_local_port = InP->msg_local_port;
	OutP->Head.msg_remote_port = InP->msg_remote_port;
	OutP->Head.msg_id = InP->msg_id + 100;
	OutP->Head.msg_type = InP->msg_type;
	OutP->Head.msg_size = sizeof *OutP;

#if	UseStaticMsgType
	OutP->RetCodeType = RetCodeType;
#else	UseStaticMsgType
	OutP->RetCodeType.msg_type_name = MSG_TYPE_INTEGER_32;
	OutP->RetCodeType.msg_type_size = 32;
	OutP->RetCodeType.msg_type_number = 1;
	OutP->RetCodeType.msg_type_inline = TRUE;
	OutP->RetCodeType.msg_type_longform = FALSE;
	OutP->RetCodeType.msg_type_deallocate = FALSE;
#endif	UseStaticMsgType
	OutP->RetCode = MIG_BAD_ID;

	if ((InP->msg_id > 2251) || (InP->msg_id < 2250))
		return FALSE;
	 else {
		typedef novalue (*SERVER_STUB_PROC)(
#ifdef c_plusplus
		msg_header_t*, msg_header_t*
#endif
		);
		static SERVER_STUB_PROC routines[] = {
			_Xpager_create,
			_Xpager_data_initialize,
		};

		if (routines[InP->msg_id - 2250])
			(routines[InP->msg_id - 2250]) (InP, &OutP->Head);
		 else
			return FALSE;
	}
	return TRUE;
}
@EOF@

echo "libmach/XXX_pdu.c"
cat >libmach/XXX_pdu.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	XXX_pdu.c,v $
 * Revision 1.1  90/02/19  18:07:29  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.2  89/05/05  18:39:20  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*  
 * Abstract:
 *	Write around for the obsolete call pager_data_unavailable
 */

#include <mach.h>

#undef pager_data_unavailable

kern_return_t pager_data_unavailable(
	paging_request, offset, size)
		vm_pager_request_t paging_request;
		vm_offset_t offset;
		vm_size_t size;
{
	return(memory_object_data_unavailable(paging_request, offset, size));
}
@EOF@

echo "libmach/XXX_plr.c"
cat >libmach/XXX_plr.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	XXX_plr.c,v $
 * Revision 1.1  90/02/19  18:07:33  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.2  89/05/05  18:39:27  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*  
 * Abstract:
 *	Write around for the obsolete pager lock calls
 */

#include <mach.h>


#undef pager_lock_request

kern_return_t pager_lock_request(
	paging_request, offset, size, should_clean, should_flush, lock_value, reply_to)
		vm_pager_request_t paging_request;
		vm_offset_t offset;
		vm_size_t size;
		boolean_t should_clean;
		boolean_t should_flush;
		vm_prot_t lock_value;
		port_t reply_to;
{
	return(memory_object_lock_request(
	paging_request, offset, size, should_clean, should_flush, lock_value, reply_to));
}
@EOF@

echo "libmach/mach_exception.c"
cat >libmach/mach_exception.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	mach_exception.c,v $
 * Revision 1.7  90/03/21  16:12:00  mrt
 * 		Picked up i386 stuff
 * 		Add mach_mmax_exception() and mach_mmax_exception_string().
 * 	[90/03/21            mrt]
 * 
 * Revision 1.6  90/03/08  11:14:22  mrt
 * 	Added mach_mips_exception() and mach_mips_exception_string().
 * 	Corrected the returned string to be in malloc'ed memory instead
 * 	of on the stack.
 * 	[90/03/07            af]
 * 
 * Revision 1.5  90/03/05  18:30:49  mrt
 * 	Added mach_sun4_exception() and mach_sun4_exception_string().
 * 	[90/02/20            jjc]
 * 
 * Revision 1.4  89/10/31  23:45:43  mrt
 * 	Included <exeption_all.h> instead of
 * 	mach/exception.h, mach/ca/exception.h, mach/sun3/exception.h
 * 	and mach/vax/exception.h.
 * 	[89/10/28            mrt]
 * 
 * Revision 1.3  89/05/05  18:45:05  mrt
 * 	Cleanup for Mach 2.5
 * 
 * 12-May-88  Mary R. Thompson (mrt) at Carnegie Mellon
 *	added inlcude of <mach_error.h> for mach_error_string.
 * 29-Mar-88  Karl Hauth (hauth) at Carnegie-Mellon University
 *	Created from mach_error.c
 */
/*
 *	File:	mach_exception.c
 *	Author:	Karl Hauth
 *
 *	Standard error printing routines for Mach errors.
 */

#ifndef mac2_mpw_drvr

#include <stdio.h>
#include <mach.h>
#include <:mach:message.h>
#include <mig_errors.h>
#include <:servers:netname.h>
#include <:servers:env_mgr.h>
#include <:servers:ipcx_types.h>
#include <exception_all.h>
#include <mach_exception.h>
#include <mach_error.h>

char *mach_exception_string(exception)
	int exception;
{
	switch (exception) {
	case EXC_BAD_ACCESS:
		return("Memory Access");

	case EXC_BAD_INSTRUCTION:
		return("Illegal Instruction");

	case EXC_ARITHMETIC:
		return("Arithmetic");

	case EXC_EMULATION:
		return("Emulation");

	case EXC_SOFTWARE:
		return("Software");

	case EXC_BREAKPOINT:
		return("Breakpoint");

	default:
		return("Unknown exception");
	}
}

void mach_exception(str, exception)
	char *str;
	int exception;
{
	char	*msg;

	msg = mach_exception_string(exception);
	fprintf(stderr, "%s: %s(%d)\n", str, msg, exception);
}

char *mach_sun3_exception_string(exception, code, subcode)
	int exception, code, subcode;
{
	char	*buf;

	switch (exception) {
	case EXC_BAD_ACCESS:
		buf = (char*)malloc(100);
		sprintf(buf,
			"Memory access exception on address 0x%x (%s)",
			subcode, mach_error_string(code));
		return(buf);

	case EXC_BAD_INSTRUCTION:
		switch (code) {
		case EXC_SUN3_ILLEGAL_INSTRUCTION:
			return("Illegal or undefined instruction or operand");

		case EXC_SUN3_PRIVILEGE_VIOLATION:
			return("Illegal instruction, privilege violation");

		case EXC_SUN3_COPROCESSOR:
			return("Illegal instruction, coprocessor");

		case EXC_SUN3_TRAP1:
			return("Illegal instruction, trap 1");

		case EXC_SUN3_TRAP2:
			return("Illegal instruction, trap 2");

		case EXC_SUN3_TRAP3:
			return("Illegal instruction, trap 3");

		case EXC_SUN3_TRAP4:
			return("Illegal instruction, trap 4");

		case EXC_SUN3_TRAP5:
			return("Illegal instruction, trap 5");

		case EXC_SUN3_TRAP6:
			return("Illegal instruction, trap 6");

		case EXC_SUN3_TRAP7:
			return("Illegal instruction, trap 7");

		case EXC_SUN3_TRAP8:
			return("Illegal instruction, trap 8");

		case EXC_SUN3_TRAP9:
			return("Illegal instruction, trap 9");

		case EXC_SUN3_TRAP10:
			return("Illegal instruction, trap 10");

		case EXC_SUN3_TRAP11:
			return("Illegal instruction, trap 11");

		case EXC_SUN3_TRAP12:
			return("Illegal instruction, trap 12");

		case EXC_SUN3_TRAP13:
			return("Illegal instruction, trap 13");

		case EXC_SUN3_TRAP14:
			return("Illegal instruction, trap 14");

		case EXC_SUN3_FLT_BSUN:
			return("Illegal instruction, code == FLT_BSUN");

		case EXC_SUN3_FLT_OPERAND_ERROR:
			return("Illegal instruction, illegal floating operand");

		default:
			return("Illegal or undefined instruction or operand");
		}


	case EXC_ARITHMETIC:
		switch (code) {
		case EXC_SUN3_ZERO_DIVIDE:
			return("Arithmetic exception, divide by zero");

		case EXC_SUN3_FLT_INEXACT:
			return("Arithmetic exception, floating inexact");

		case EXC_SUN3_FLT_ZERO_DIVIDE:
			return("Arithmetic exception, floating divide by zero");

		case EXC_SUN3_FLT_UNDERFLOW:
			return("Arithmetic exception, floating underflow");

		case EXC_SUN3_FLT_OVERFLOW:
			return("Arithmetic exception, floating overflow");

		case EXC_SUN3_FLT_NOT_A_NUMBER:
			return("Arithmetic exception, not a floating number");

		default:
			return("Arithmetic error with undefined code");
		}

	case EXC_EMULATION:
		switch (code) {
		case EXC_SUN3_LINE_1010:
			return("Emulation exception, line 1010");

		case EXC_SUN3_LINE_1111:
			return("Emulation exception, line 1111");

		default:
			return("Emulation error with undefined code");
		}

	case EXC_SOFTWARE:
		switch (code) {
		case EXC_SUN3_CHK:
			return("Software exception, CHK");

		case EXC_SUN3_TRAPV:
			return("Software exception, TRAPV");

		default:
			return("Software generated exception (undefigned type)");
		}

	case EXC_BREAKPOINT:
		switch (code) {
		case EXC_SUN3_TRACE:
			return("Breakpoint exception, trace");

		case EXC_SUN3_BREAKPOINT:
			return("Breakpoint exception, breakpoint");

		default:
			return("Breakpoint exception, undefined code.");
		}

	default:
		return("unknown exception");
	}
}


void mach_sun3_exception(str, exception, code, subcode)
	char *str;
	int exception, code, subcode;
{
	char	*msg;

	msg = mach_sun3_exception_string(exception, code, subcode);
	fprintf(stderr, "%s: %s(%d %d %d)\n",
		str, msg, exception, code, subcode);
}


char *mach_romp_exception_string(exception, code, subcode)
	int exception, code, subcode;
{
	char	*buf;

	switch (exception) {
	case EXC_BAD_ACCESS:
		buf = (char*)malloc(100);
		sprintf(buf,
			"Memory access exception on address 0x%x (%s)",
			subcode, mach_error_string(code));
		return(buf);
	case EXC_BAD_INSTRUCTION:
		switch (code) {
		case EXC_ROMP_PRIV_INST:
			return("Bad instruction, privileged");

		case EXC_ROMP_ILLEGAL_INST:
			return("Bad instruction, illegal");

		default:
			return("Bad instruction, undefined exception code");
		}

	case EXC_BREAKPOINT:
		switch (code) {
		case EXC_ROMP_TRAP_INST:
			return("Breakpoint exception, trap");

		case EXC_ROMP_INST_STEP:
			return("Breakpoint exception, step");

		default:
			return("Breakpoint exception, undefined exception code");
		}

	case EXC_ARITHMETIC:
		switch (code) {
		case EXC_ROMP_FPA_EMUL:
			return("Arithmetic exception, FPA emulation");

		case EXC_ROMP_68881:
			return("Arithmetic exception, 68881");

		case EXC_ROMP_68881_TIMEOUT:
			return("Arithmetic exception, 68881 timeout");

		case EXC_ROMP_FLOAT_SPEC:
			return("Arithmetic exception, floating specification");

		default:
			return("Arithmetic exception, undefined exception code");
		}

	case EXC_SOFTWARE:
		return("Software exception.");

	case EXC_EMULATION:
		return("Emulation exception.");

	default:
		return("Undefined exception code");
	}
}


void mach_romp_exception(str, exception, code, subcode)
	char *str;
	int exception, code, subcode;
{
	char	*msg;

	msg = mach_romp_exception_string(exception, code, subcode);
	fprintf(stderr, "%s: %s(%d %d %d)\n",
		str, msg, exception, code, subcode);
}

char *mach_vax_exception_string(exception, code, subcode)
	int exception, code, subcode;
{
	char	*buf;

	switch (exception) {
	case EXC_BAD_ACCESS:
		buf = (char*)malloc(100);
		sprintf(buf,
			"Memory access exception on address 0x%x (%s)",
			subcode, mach_error_string(code));
		return(buf);

	case EXC_BAD_INSTRUCTION:
		switch (code) {
		case EXC_VAX_PRIVINST:
			return("Bad Instruction exception, privileged instruction");

		case EXC_VAX_RESOPND:
			return("Bad Instruction exception, reserved operand");

		case EXC_VAX_RESADDR:
			return("Bad Instruction exception, reserved address");

		case EXC_VAX_COMPAT:
			switch (subcode) {
				case EXC_VAX_COMPAT_RESINST:
					return("Bad Instruction exception, compat, reserved instruction");

				case EXC_VAX_COMPAT_BPT:
					return("Bad Instruction exception, compat, breakpoint");

				case EXC_VAX_COMPAT_IOT:
					return("Bad Instruction exception, compat, IOT");

				case EXC_VAX_COMPAT_EMT:
					return("Bad Instruction exception, compat, emulation");
				case EXC_VAX_COMPAT_TRAP:
					return("Bad Instruction exception, compat, trap");

				case EXC_VAX_COMPAT_RESOP:
					return("Bad Instruction exception, compat, reserved operation");

				case EXC_VAX_COMPAT_ODDADDR:
					return("Bad Instruction exception, compat, odd address");

				default:
					return("Bad Instruction exception, compat, invalid exception subcode");
			}

		default:
			return("Bad Instruction exception, invalid exception code");
		}

	case EXC_ARITHMETIC:
		switch (code) {

		case EXC_VAX_INT_OVF:
			return("Arithmetic exception, integer overflow");

		case EXC_VAX_INT_DIV:
			return("Arithmetic exception, integer division");

		case EXC_VAX_FLT_OVF_T:
			return("Arithmetic exception, floating overflow T");

		case EXC_VAX_FLT_DIV_T:
			return("Arithmetic exception, floating division T");

		case EXC_VAX_FLT_UND_T:
			return("Arithmetic exception, floating underflow T");

		case EXC_VAX_DEC_OVF:
			return("Arithmetic exception, decimal overflow T");

		case EXC_VAX_FLT_OVF_F:
			return("Arithmetic exception, floating overflow F");

		case EXC_VAX_FLT_DIV_F:
			return("Arithmetic exception, floating division F");

		case EXC_VAX_FLT_UND_F:
			return("Arithmetic exception, floating underflow F");

		default:
			return("Arithmetic exception, undefined exception code");
		}

	case EXC_SOFTWARE:
		switch (code) {
		case EXC_VAX_SUB_RNG:
			return("Software exception, subrange");

		default:
			return("Software exception, undefined exception code");
		}

	case EXC_EMULATION:
		return("Emulation exception.");

	case EXC_BREAKPOINT:
		switch (code) {

		case EXC_VAX_BPT:
			return("Breakpoint exception, breakpoint");

		case EXC_VAX_TRACE:
			return("Breakpoint exception, trace");

		default:
			return("Breakpoint exception, undefined exception code");
		}

	default:
		return("Undefined exception number");
	}
}

void mach_vax_exception(str, exception, code, subcode)
	char *str;
	int exception, code, subcode;
{
	char	*msg;

	msg = mach_vax_exception_string(exception, code, subcode);
	fprintf(stderr, "%s: %s(%d %d %d)\n",
		str, msg, exception, code, subcode);
}

char *mach_sun4_exception_string(exception, code, subcode)
	int exception, code, subcode;
{
	char	*buf;

	switch (exception) {
	case EXC_BAD_ACCESS:
		buf = (char*)malloc(100);
		sprintf(buf,
			"Memory access exception on address 0x%x (%s)",
			subcode, mach_error_string(code));
		return(buf);

	case EXC_BAD_INSTRUCTION:
		switch (code) {
		case EXC_SUN4_WINDOW_OVERFLOW:
			return("User window overflow failed");

		case EXC_SUN4_PRIVILEGE_VIOLATION:
			return("Illegal instruction, privilege violation");

		case EXC_SUN4_UNIMPLEMENTED:
			return("Unimplemented instruction");

		default:
			buf = (char*)malloc(100);
			sprintf(buf, "Illegal or undefined instruction, trap 0x%x", code);
			return(buf);
		}


	case EXC_ARITHMETIC:
		switch (code) {
		case EXC_SUN4_ZERO_DIVIDE:
			return("Arithmetic exception, divide by zero");

		case EXC_SUN4_FLT_EXCEPTION:
			return("Arithmetic exception, floating point");

		default:
			return("Arithmetic error with undefined code");
		}

	case EXC_EMULATION:
		switch (code) {
		case EXC_SUN4_TAG_OVERFLOW:
			return("Emulation exception, tag overflow");

		default:
			return("Emulation error with undefined code");
		}

	case EXC_SOFTWARE:
		switch (code) {
		default:
			return("Software generated exception (undefined type)");
		}

	case EXC_BREAKPOINT:
		switch (code) {
		case EXC_SUN4_BREAKPOINT:
			return("Breakpoint exception, breakpoint");

		default:
			return("Breakpoint exception, undefined code.");
		}

	default:
		return("unknown exception");
	}
}


void mach_sun4_exception(str, exception, code, subcode)
	char *str;
	int exception, code, subcode;
{
	char	*msg;

	msg = mach_sun4_exception_string(exception, code, subcode);
	fprintf(stderr, "%s: %s(%d %d %d)\n",
		str, msg, exception, code, subcode);
}

char *mach_mips_exception_string(exception, code, subcode)
	int exception, code, subcode;
{
	char	*buf;

	switch (exception) {
	case EXC_BAD_ACCESS:
		buf = (char*)malloc(100);
		sprintf(buf,
			"Memory access exception on address 0x%x (%s)",
			subcode, mach_error_string(code));
		return(buf);

	case EXC_BAD_INSTRUCTION:
		switch (code) {
		case EXC_MIPS_PRIVINST:
			return("Bad Instruction exception, privileged instruction");

		case EXC_MIPS_RESOPND:
			return("Bad Instruction exception, reserved operand");

		case EXC_MIPS_RESADDR:
			return("Bad Instruction exception, reserved address");

		default:
			return("Bad Instruction exception, invalid exception code");
		}

	case EXC_ARITHMETIC:
		switch (code) {

		case EXC_MIPS_FLT_UNIMP:
			return("Arithmetic exception, floating unimplemented T");

		case EXC_MIPS_FLT_INVALID:
			return("Arithmetic exception, floating invalid T");

		case EXC_MIPS_FLT_DIVIDE0:
			return("Arithmetic exception, floating zerodivide T");

		case EXC_MIPS_FLT_OVERFLOW:
			return("Arithmetic exception, floating overflow F");

		case EXC_MIPS_FLT_UNDERFLOW:
			return("Arithmetic exception, floating underflow F");

		case EXC_MIPS_FLT_INEXACT:
			return("Arithmetic exception, floating inexact F");

		default:
			return("Arithmetic exception, undefined exception code");
		}

	case EXC_SOFTWARE:
		switch (code) {
		case EXC_MIPS_SOFT_CPU:
			return("Software exception, coprocessor unusable");
#ifdef EXC_MIPS_SOFT_SEGV /* temp hack until kernel bug fix */
		case EXC_MIPS_SOFT_SEGV:
			buf = (char*)malloc(100);
			sprintf(buf,
				"Memory access exception, cause 0x%x", subcode);
			return(buf);
#endif
		default:
			return("Software exception, undefined exception code");
		}

	case EXC_EMULATION:
		return("Emulation exception.");

	case EXC_BREAKPOINT:
		switch (code) {

		case EXC_MIPS_BPT:
			return("Breakpoint exception, breakpoint");

		case EXC_MIPS_TRACE:
			return("Breakpoint exception, trace");

		default:
			return("Breakpoint exception, undefined exception code");
		}

	default:
		return("Undefined exception number");
	}
}

void mach_mips_exception(str, exception, code, subcode)
	char *str;
	int exception, code, subcode;
{
	char	*msg;

	msg = mach_mips_exception_string(exception, code, subcode);
	fprintf(stderr, "%s: %s(%d %d %d)\n",
		str, msg, exception, code, subcode);
}

char *mach_mmax_exception_string(exception, code, subcode)
	int exception, code, subcode;
{
	char	*buf;

	switch (exception) {
	case EXC_BAD_ACCESS:
		buf = (char*)malloc(100);
		sprintf(buf,
			"Memory access exception on address 0x%x (%s)",
			subcode, mach_error_string(code));
		return(buf);

	case EXC_BAD_INSTRUCTION:
		switch (code) {
		case EXC_NS32K_FPU:
			switch(subcode) {
				case EXC_NS32K_FPU_ILLEGAL:
    return("Bad Instruction exception, illegal floating point instruction");

				case EXC_NS32K_FPU_INVALID:
    return("Bad Instruction exception, invalid floating point operation");

    				default:
    return("Bad Instruction exception, undefined floating point subcode");
			}

		case EXC_NS32K_ILL:
			return("Bad Instruction exception, illegal operation");

		case EXC_NS32K_UND:
			return("Bad Instruction exception, undefined opcode");

		default:
			return("Bad Instruction exception, undefined exception code");
		}

	case EXC_ARITHMETIC:
		switch (code) {

		case EXC_NS32K_FPU:
			switch(subcode) {
				case EXC_NS32K_FPU_UNDERFLOW:
		return("Arithmetic exception, floating point underflow");

				case EXC_NS32K_FPU_OVERFLOW:
		return("Arithmetic exception, floating point overflow");

				case EXC_NS32K_FPU_DVZ:
		return("Arithmetic exception, floating point divide by zero");

				case EXC_NS32K_FPU_INEXACT:
		return("Arithmetic exception, inexact floating point result");

				case EXC_NS32K_FPU_OPERAND:
		return("Arithmetic exception, floating point operand error");

				default:
		return("Arithmetic exception, undefined floating point subcode");
			}

		default:
			return("Arithmetic exception, undefined exception code");
		}

	case EXC_SOFTWARE:
		switch (code) {
		case EXC_NS32K_FLG:
			return("Software exception, FLAG instruction trap");
		default:
			return("Software exception, undefined exception code");
		}

	case EXC_EMULATION:
		return("Emulation exception.");

	case EXC_BREAKPOINT:
		switch (code) {

		case EXC_NS32K_BPT:
			return("Breakpoint exception, breakpoint");

		case EXC_NS32K_TRC:
			return("Breakpoint exception, trace trap");

		default:
			return("Breakpoint exception, undefined exception code");
		}

	default:
		return("Undefined exception number");
	}
}

void mach_mmax_exception(str, exception, code, subcode)
	char *str;
	int exception, code, subcode;
{
	char	*msg;

	msg = mach_mmax_exception_string(exception, code, subcode);
	fprintf(stderr, "%s: %s(%d %d %d)\n",
		str, msg, exception, code, subcode);
}

char *mach_i386_exception_string(exception, code, subcode)
	int exception, code, subcode;
{
	char	*buf;

	switch (exception) {
	case EXC_BAD_ACCESS:
		buf = (char*)malloc(100);
		if (!buf) {
			fprintf(stderr,
				"mach_i386_exception_string: no memory!\n");
			abort();
		}
		sprintf(buf,
			"Memory access exception on address 0x%x (%s)",
			subcode, mach_error_string(code));
		return(buf);		/* XXX - core leak */

	case EXC_BAD_INSTRUCTION:
		switch (code) {
		case EXC_I386_INVOP:
			return("Bad Instruction exception, invalid opcode");

		default:
			return("Bad Instruction exception, invalid exception code");
		}

	case EXC_ARITHMETIC:
		switch (code) {

		case EXC_I386_DIV:
			return("Arithmetic exception, divide error");
		case EXC_I386_INTO:
			return("Arithmetic exception, INTO overflow fault");
		case EXC_I386_NOEXT:
			return("Arithmetic exception, coprocessor not available fault");
		case EXC_I386_EXTOVR:
			return("Arithmetic exception, coprocessor overrun fault");
		case EXC_I386_EXTERR:
			return("Arithmetic exception, coprocessor error");
		case EXC_I386_EMERR:
			return("Arithmetic exception, emulated extension fault");
		case EXC_I386_BOUND:
			return("Arithmetic exception, BOUND instruction fault");
		default:
			return("Arithmetic exception, undefined exception code");
		}

	case EXC_SOFTWARE:
		return("Software exception, undefined exception code");

	case EXC_BREAKPOINT:
		switch (code) {

		  case EXC_I386_SGL:
			return("Breakpoint exception, trace");

  		  case EXC_I386_BPT:
			return("Breakpoint exception, breakpoint");

		  default:
			return("Breakpoint exception, undefined exception code");
		}

	default:
		return("Undefined exception number");
	}
}

void mach_i386_exception(str, exception, code, subcode)
	char *str;
	int exception, code, subcode;
{
	char	*msg;

	msg = mach_i386_exception_string(exception, code, subcode);
	fprintf(stderr, "%s: %s(%d %d %d)\n",
		str, msg, exception, code, subcode);
}

char *mach_mac2_exception_string(exception, code, subcode)
int exception, code, subcode;
{
  char      *buf;

  switch (exception) {
    case EXC_BAD_ACCESS:
      /* Could not access memory */
      /* Code contains kern_return_t describing error. */
      /* Subcode contains bad memory address. */
      buf = (char*)malloc(100);
      sprintf(buf, "Memory access exception on address 0x%x (%s)",
        subcode, mach_error_string(code));
      return buf;
    case EXC_BAD_INSTRUCTION:
      /* Instruction failed */
      /* Illegal or undefined instruction or operand */
      switch (code) {
        case EXC_MAC2_ILLEGAL_INSTRUCTION:
          return "Illegal or undefined instruction or operand";
        case EXC_MAC2_PRIVILEGE_VIOLATION:
          return "Illegal instruction, privilege violation";
        case EXC_MAC2_COPROCESSOR:
          return "Illegal instruction, coprocessor";
        case EXC_MAC2_TRAP1:
          return "Illegal instruction, trap 1";
        case EXC_MAC2_TRAP2:
          return "Illegal instruction, trap 2";
        case EXC_MAC2_TRAP3:
          return "Illegal instruction, trap 3";
        case EXC_MAC2_TRAP4:
          return "Illegal instruction, trap 4";
        case EXC_MAC2_TRAP5:
          return "Illegal instruction, trap 5";
        case EXC_MAC2_TRAP6:
          return "Illegal instruction, trap 6";
        case EXC_MAC2_TRAP7:
          return "Illegal instruction, trap 7";
        case EXC_MAC2_TRAP8:
          return "Illegal instruction, trap 8";
        case EXC_MAC2_TRAP9:
          return "Illegal instruction, trap 9";
        case EXC_MAC2_TRAP10:
          return "Illegal instruction, trap 10";
        case EXC_MAC2_TRAP11:
          return "Illegal instruction, trap 11";
        case EXC_MAC2_TRAP12:
          return "Illegal instruction, trap 12";
        case EXC_MAC2_TRAP13:
          return "Illegal instruction, trap 13";
        case EXC_MAC2_TRAP14:
          return "Illegal instruction, trap 14";
        case EXC_MAC2_FLT_BSUN:
          return "Illegal instruction, code == FLT_BSUN";
        case EXC_MAC2_FLT_OPERAND_ERROR:
          return "Illegal instruction, illegal floating operand";
        default:
          return "Illegal or undefined instruction or operand";
      }
    case EXC_ARITHMETIC:
      /* Arithmetic exception */
      /* Exact nature of exception is in code field */
      switch (code) {
        case EXC_MAC2_ZERO_DIVIDE:
          return "Arithmetic exception, divide by zero";
        case EXC_MAC2_FLT_INEXACT:
          return "Arithmetic exception, floating inexact";
        case EXC_MAC2_FLT_ZERO_DIVIDE:
          return "Arithmetic exception, floating divide by zero";
        case EXC_MAC2_FLT_UNDERFLOW:
          return "Arithmetic exception, floating underflow";
        case EXC_MAC2_FLT_OVERFLOW:
          return "Arithmetic exception, floating overflow";
        case EXC_MAC2_FLT_NOT_A_NUMBER:
          return "Arithmetic exception, not a floating number";
        default:
          return "Arithmetic error with undefined code";
      }
    case EXC_EMULATION:
      /* Emulation instruction */
      /* Emulation support instruction encountered */
      /* Details in code and subcode fields      */
      switch (code) {
        case EXC_MAC2_LINE_1010:
          return "Emulation exception, line 1010";
        case EXC_MAC2_LINE_1111:
          return "Emulation exception, line 1111";
        default:
          return "Emulation error with undefined code";
      }
    case EXC_SOFTWARE:
      /* Software generated exception */
      /* Exact exception is in code field. */
      /* Codes 0 - 0xFFFF reserved to hardware */
      /* Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) */
      switch (code) {
        case EXC_MAC2_CHK:
          return "Software exception, CHK";
        case EXC_MAC2_TRAPV:
          return "Software exception, TRAPV";
        default:
          return "Software generated exception (undefigned type)";
      }
    case EXC_BREAKPOINT:
      /* Trace, breakpoint, etc. */
      /* Details in code field. */
      switch (code) {
        case EXC_MAC2_TRACE:
          return "Breakpoint exception, trace";
        case EXC_MAC2_BREAKPOINT:
          return "Breakpoint exception, breakpoint";
        default:
          return "Breakpoint exception, undefined code.";
      }
    default:
      return "unknown exception";
  }
}

void mach_mac2_exception(str, exception, code, subcode)
char *str;
int exception, code, subcode;
{
  char *msg;

  msg = mach_mac2_exception_string(exception, code, subcode);
  fprintf(stderr, "%s: %s(%d %d %d)\n", str, msg, exception, code, subcode);
}

#endif /* mac2_mpw_drvr */
@EOF@

echo "libmach/XXX_new_vawp.c"
cat >libmach/XXX_new_vawp.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	XXX_new_vawp.c,v $
 * Revision 1.1  90/02/19  18:07:16  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.3  89/05/05  18:38:49  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*  
 * Abstract:
 *	Write around for the obsolete call vm_allocate_with_pager
 */

#include <mach.h>

#undef vm_allocate_with_pager

kern_return_t vm_allocate_with_pager(
	target_task, address, size, anywhere, memory_object, offset)
		vm_task_t target_task;
		vm_address_t *address;
		vm_size_t size;
		boolean_t anywhere;
		memory_object_t memory_object;
		vm_offset_t offset;
{
	return(vm_map(target_task, address, size, 0, anywhere,
		memory_object, offset, FALSE,
		VM_PROT_ALL, VM_PROT_ALL, VM_INHERIT_COPY));
}
@EOF@

echo "libmach/new_mach_user.c"
cat >libmach/new_mach_user.c <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	new_mach_user.c,v $
 * Revision 1.2  90/02/19  18:31:07  bww
 * 	#undef LINTLIBRARY from Mary Thompson.
 * 	[90/02/19  18:29:33  bww]
 * 
 * Revision 1.1  90/02/19  18:08:40  bww
 * 	Mach Release 2.5
 * 	[90/02/19  18:07:07  bww]
 * 
 * Revision 1.2  89/05/05  18:46:41  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*
 *	Each of the following routines is replaced by a pretty
 *	compatible version.  For these, we try the new interface
 *	routine, then the old one.
 */

#undef LINTLIBRARY

#include <:mach:mach_types.h>
#include <mig_errors.h>


kern_return_t port_allocate(task, port_name)
	task_t		task;
	port_name_t	*port_name;
{
	kern_return_t	result;
	extern
	kern_return_t	NEW_port_allocate();
	extern
	kern_return_t	xxx_port_allocate();

	if ((result = NEW_port_allocate(task, port_name)) == MIG_BAD_ID)
		result = xxx_port_allocate(task, port_name);
	return(result);
}

kern_return_t port_deallocate(task, port_name)
	task_t		task;
	port_name_t	port_name;
{
	kern_return_t	result;
	extern
	kern_return_t	NEW_port_deallocate();
	extern
	kern_return_t	xxx_port_deallocate();


	if ((result = NEW_port_deallocate(task, port_name)) == MIG_BAD_ID)
		result = xxx_port_deallocate(task, port_name);
	return(result);
}

kern_return_t port_set_backlog(task, port_name, backlog)
	task_t		task;
	port_name_t	port_name;
	int		backlog;
{
	kern_return_t	result;
	extern
	kern_return_t	NEW_port_set_backlog();
	extern
	kern_return_t	xxx_port_set_backlog();


	if ((result = NEW_port_set_backlog(task, port_name, backlog)) == MIG_BAD_ID)
		result = xxx_port_set_backlog(task, port_name, backlog);
	return(result);
}

#define	port_allocate	NEW_port_allocate
#define	port_deallocate	NEW_port_deallocate
#define	port_set_backlog	NEW_port_set_backlog

/*
 *	These should be replaced by user-level support.  We should
 *	try the new replacement code first, then back off to the
 *	old interface routine.
 *
 *	Before we can really enable this change, we have to get
 *	the include files with the new declaration of PORT_ENABLED and
 *	PORT_DEFAULT out.
 *
 *	NOTES:
 *		There's no synchronization among multiple uses of these routines.
 *		The values returned by the new port_set routines may be
 *		 unexpected by programs expecting the old semantics.  This
 *		 can probably be corrected if anyone cares.
 */

port_t		PORT_ENABLED = (-1);

kern_return_t	port_enable(target_task, port)
	task_t		target_task;
	port_t		port;
{
	extern
	kern_return_t	port_set_add();
	extern
	kern_return_t	xxx_port_enable();

#if	PORT_ENABLED_IS_A_VARIABLE
	extern
	kern_return_t	port_set_allocate();

	if (PORT_ENABLED == (-1))
		(void) port_set_allocate(target_task, &PORT_ENABLED);
#endif	PORT_ENABLED_IS_A_VARIABLE

	return((PORT_ENABLED == (-1)) ?
		xxx_port_enable(target_task, port) :
	 	port_set_add(target_task, port, PORT_ENABLED)
		);
}

kern_return_t	port_disable(target_task, port)
	task_t		target_task;
	port_t		port;
{
	extern
	kern_return_t	port_set_remove();
	extern
	kern_return_t	xxx_port_disable();

#if	PORT_ENABLED_IS_A_VARIABLE
	extern
	kern_return_t	port_set_allocate();

	if (PORT_ENABLED == (-1))
		(void) port_set_allocate(target_task, &PORT_ENABLED);
#endif	PORT_ENABLED_IS_A_VARIABLE

	return((PORT_ENABLED == (-1)) ?
		xxx_port_disable(target_task, port) :
	 	port_set_remove(target_task, port)
		);
}

/*
 *	This routine exists in the new library, but has
 *	different calling sequence and semantics.
 *
 *	Any old users lose totally.
 */

/* port_status */

/*
 *	This routine can't even be easily emulated in
 *	the new library.  If old users complain loudly,
 *	we may be able to return it to service.
 */

/* port_status */


#include "mach_user.c"
@EOF@

echo "libmach/mach_traps.a"
cat >libmach/mach_traps.a <<'@EOF@'
* these are the MACH kernel calls
*
* MacMach version 01; bsd4.3-tahoe; Mach/2.6 #5.1(X129); CMU-MACMACH 013
*
* this is essentially the result of doing "cc -E mach_traps.S", removing
* the "_" prefixes and replacing ".globl" with "PROC EXPORT ... ENDPROC"

* make sure that the lower case identifiers are exported as such
	CASE ON

task_self: PROC EXPORT
	PEA	-10
	TRAP	#0
	RTS
	ENDPROC
 
thread_reply: PROC EXPORT
	PEA	-11
	TRAP	#0
	RTS
	ENDPROC
 
task_notify: PROC EXPORT
	PEA	-12
	TRAP	#0
	RTS
	ENDPROC
 
thread_self: PROC EXPORT
	PEA	-13
	TRAP	#0
	RTS
	ENDPROC
 
msg_send_old: PROC EXPORT
	PEA	-14
	TRAP	#0
	RTS
	ENDPROC
 
msg_receive_old: PROC EXPORT
	PEA	-15
	TRAP	#0
	RTS
	ENDPROC
 
msg_rpc_old: PROC EXPORT
	PEA	-16
	TRAP	#0
	RTS
	ENDPROC
 
msg_send_trap: PROC EXPORT
	PEA	-20
	TRAP	#0
	RTS
	ENDPROC
 
msg_receive_trap: PROC EXPORT
	PEA	-21
	TRAP	#0
	RTS
	ENDPROC
 
msg_rpc_trap: PROC EXPORT
	PEA	-22
	TRAP	#0
	RTS
	ENDPROC
 
htg_unix_syscall: PROC EXPORT
	PEA	-52
	TRAP	#0
	RTS
	ENDPROC
 

inode_swap_preference: PROC EXPORT
	PEA	-40
	TRAP	#0
	RTS
	ENDPROC
 
init_process: PROC EXPORT
	PEA	-41
	TRAP	#0
	RTS
	ENDPROC
 
map_fd: PROC EXPORT
	PEA	-43
	TRAP	#0
	RTS
	ENDPROC
 
rfs_make_symlink: PROC EXPORT
	PEA	-44
	TRAP	#0
	RTS
	ENDPROC
 
mach_swapon: PROC EXPORT
	PEA	-45
	TRAP	#0
	RTS
	ENDPROC
 
host_self: PROC EXPORT
	PEA	-55
	TRAP	#0
	RTS
	ENDPROC
 
host_priv_self: PROC EXPORT
	PEA	-56
	TRAP	#0
	RTS
	ENDPROC
 
swtch_pri: PROC EXPORT
	PEA	-59
	TRAP	#0
	RTS
	ENDPROC
 
swtch: PROC EXPORT
	PEA	-60
	TRAP	#0
	RTS
	ENDPROC
 
thread_switch: PROC EXPORT
	PEA	-61
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_0: PROC EXPORT
	PEA	-70
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_1: PROC EXPORT
	PEA	-71
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_2: PROC EXPORT
	PEA	-72
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_3: PROC EXPORT
	PEA	-73
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_4: PROC EXPORT
	PEA	-74
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_5: PROC EXPORT
	PEA	-75
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_6: PROC EXPORT
	PEA	-76
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_7: PROC EXPORT
	PEA	-77
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_8: PROC EXPORT
	PEA	-78
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_9: PROC EXPORT
	PEA	-79
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_10: PROC EXPORT
	PEA	-80
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_11: PROC EXPORT
	PEA	-81
	TRAP	#0
	RTS
	ENDPROC
 
mach_sctimes_port_alloc_dealloc: PROC EXPORT
	PEA	-82
	TRAP	#0
	RTS
	ENDPROC
 
	END
@EOF@

echo "libmach/err_kern.sub"
cat >libmach/err_kern.sub <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	err_kern.sub,v $
NONERevision 1.1  90/02/19  18:07:40  bww
NONE	Mach Release 2.5
NONE	[90/02/19  18:07:07  bww]
NONE
 * Revision 1.2  89/05/05  18:40:38  mrt
 * 	Cleanup for Mach 2.5
 * 
 */
/*	err_os subsystems	*/


static char * err_codes_kern[] = {
	"(os/kern) successful",
	"(os/kern) invalid address",
	"(os/kern) protection failure",
	"(os/kern) no space available",
	"(os/kern) invalid argument",
	"(os/kern) failure",
	"(os/kern) resource shortage",
	"(os/kern) not receiver",
	"(os/kern) no access",
};

static char * err_codes_unix[] = {
	NO_SUCH_ERROR,
	"(os/unix) no rights to object",
	"(os/unix) file or directory does not exist",
	"(os/unix) no such process",
	"(os/unix) interrupted system call",
	"(os/unix) i/o error",
	"(os/unix) device does not exist",
	"(os/unix) argument list is too long",
	"(os/unix) invalid executable object format",
	"(os/unix) bad file descriptor number",
	"(os/unix) no child processes are present",
	"(os/unix) no more processes are available",
	"(os/unix) insufficient memory",
	"(os/unix) access denied",
	"(os/unix) memory access fault",
	"(os/unix) block device required for operation",
	"(os/unix) mount device busy",
	"(os/unix) file already exists",
	"(os/unix) cross device link",
	"(os/unix) device does not exist",
	"(os/unix) object is not a directory",
	"(os/unix) object is a directory",
	"(os/unix) invalid argument",
	"(os/unix) internal file table overflow",
	"(os/unix) maximum number of open files reached",
	"(os/unix) object is not a tty-like device",
	"(os/unix) executable object is in use",
	"(os/unix) file is too large",
	"(os/unix) no space is left on device",
	"(os/unix) illegal seek attempt",
	"(os/unix) read-only file system",
	"(os/unix) too many links",
	"(os/unix) broken pipe",
	"(os/unix) argument is too large",
	"(os/unix) result is out of range",
	"(os/unix) operation on device would block",
	"(os/unix) operation is already in progress",
	"(os/unix) socket operation attempted on non-socket object",
	"(os/unix) destination address is required",
	"(os/unix) message is too long",
	"(os/unix) protocol type is incorrect for socket",
	"(os/unix) protocol type is not availaible",
	"(os/unix) protocol type is not supported",
	"(os/unix) socket type is not supported",
	"(os/unix) operation is not supported on sockets",
	"(os/unix) protocol family is not supported",
	"(os/unix) address family is not supported by protocol family",
	"(os/unix) address is already in use",
	"(os/unix) can't assign requested address",
	"(os/unix) network is down",
	"(os/unix) network is unreachable",
	"(os/unix) network dropped connection on reset",
	"(os/unix) software aborted connection",
	"(os/unix) connection reset by peer",
	"(os/unix) no buffer space is available",
	"(os/unix) socket is already connected",
	"(os/unix) socket is not connected",
	"(os/unix) can't send after socket shutdown",
	"(os/unix) too many references; can't splice",
	"(os/unix) connection timed out",
	"(os/unix) connection was refused",
	"(os/unix) too many levels of symbolic links",
	"(os/unix) file name exceeds system maximum limit",
	"(os/unix) host is down",
	"(os/unix) there is no route to host",
	"(os/unix) directory is not empty",
	"(os/unix) quota on number of processes exceeded",
	"(os/unix) quota on number of users exceeded",
	"(os/unix) quota on available disk space exceeded",
};

static struct error_subsystem err_os_sub[] = {
	{
	"(os/kern)",
	errlib_count(err_codes_kern),
	err_codes_kern,
	},
	{
	"(os/?)",
	0,
	},
	{
	"(os/?)",
	0,
	},
	{
	"(os/unix)",
	errlib_count(err_codes_unix),
	err_codes_unix,
	},
};
@EOF@

echo "libmach/err_us.sub"
cat >libmach/err_us.sub <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	err_us.sub,v $
NONERevision 1.1  90/02/19  18:07:46  bww
NONE	Mach Release 2.5
NONE	[90/02/19  18:07:07  bww]
NONE
 * Revision 1.2  89/05/05  18:41:08  mrt
 * 	09-Apr-88	Douglas Orr (dorr) at Carnegie-Mellon University
 * 
 *	add mig codes
 * 
 * 09-Mar-88	Douglas Orr (dorr) at Carnegie-Mellon University
 *	created.
 */
/*
 * File:	err_us.sub
 * Purpose:
 *	Generic error code interface
 */


static char 	* err_codes_loader[] = {
	NO_SUCH_ERROR,
	"(us/loader) mapped file open error",			/* 1 */
	"(us/loader) mapped file write error",			/* 2 */
	"(us/loader) mapped file read error",			/* 3 */
	"(us/loader) mapped file storage allocation error",	/* 4 */
	"(us/loader) mapped file invalid open mode",		/* 5 */
	"(us/loader) mapped file value out of range",		/* 6 */
	"(us/loader) region not found",				/* 7 */
	"(us/loader) overlapping regions",			/* 8 */
	"(us/loader) bad object module format",			/* 9 */
	"(us/loader) invalid mach-o op code",			/* a */
	"(us/loader) internal inconsistency",			/* b */
	"(us/loader) load module end of file",			/* c */
	"(us/loader) target not aligned",			/* d */
	"(us/loader) cpu initialization error",			/* e */
	"(us/loader) a.out format not currently supported",	/* f */
};



/*	err_us subsystems      	*/
static struct error_subsystem err_us_sub[] = {
	/* us/0; */
	{
		"(us/?)",
		0,
	},
	/* us/1; mach loader */
	{
		"(us/loader)",
		errlib_count(err_codes_loader),
		err_codes_loader,
	}
};




@EOF@

echo "libmach/err_server.sub"
cat >libmach/err_server.sub <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	err_server.sub,v $
 * Revision 1.7  90/01/24  23:11:39  mrt
 * 	Added error codes for cpu_server
 * 	[90/01/17            dlb]
 * 
 * Revision 1.6  89/06/13  16:07:01  mrt
 * 	Changed to use the zeroth error number.
 * 	[89/05/18            mrt]
 * 
 * Revision 1.5  89/05/09  22:17:29  mrt
 * 	Added string for "(server/env_mgr) variable not found "
 * 
 * 
 * Revision 1.4  89/05/07  12:41:59  mrt
 * 	Cleanup for Mach 2.5 and added new ENV_PORT_NULL error message.
 * 	[89/05/07            mrt]
 * 
 *
 * 12-Jul-88	Joseph Barrera (jsb) at Carnegie-Mellon University
 *	Added codes for netmemory server.
 *
 * 09-Mar-88	Douglas Orr (dorr) at Carnegie-Mellon University
 *	created.
 */
/*
 * File:	err_server.sub
 * Purpose:
 *	Generic error code interface
 */

static char * err_codes_netname[] = {
		"(server/netname) name is not yours",
		"(server/netname) name not checked in",
		"(server/netname) no such host",
		"(server/netname) host not found",
};
static char * err_codes_env_mgr[] = {
		"(server/env_mgr) variable not found ",
		"(server/env_mgr) wrong type of variable ",
		"(server/env_mgr) unknown port ",
		"(server/env_mgr) read only environment ",
		"(server/env_mgr) no more connections available ",
		"(server/env_mgr) port table full ",
		"(server/env_mgr) attempting to enter a null port ",
};
static char * err_codes_execd[] = {
		"(server/execd) could not find file to run ",
		"(server/execd) userid or password incorrect ",
		"(server/execd) fork failed ",
};
static char * err_codes_netmemory[] = {
		"(server/netmemory) successful ",
		"(server/netmemory) invalid argument ",
		"(server/netmemory) resource shortage ",
};
static char * err_codes_cpu_server[] = {
		"(server/cpu_server) invalid argument ",
		"(server/cpu_server) request exceeds limits ",
		"(server/cpu_server) request is active ",
};

/*	err_us subsystems      	*/
static struct error_subsystem err_server_sub[] = {
	/* server/0; */
	{
		"(server/netname)",
		errlib_count(err_codes_netname),
		err_codes_netname,
	},
	/* server/1; */
	{
		"(server/env_mgr)",
		errlib_count(err_codes_env_mgr),
		err_codes_env_mgr,
	},
	/* server/2; */
	{
		"(server/execd)",
		errlib_count(err_codes_execd),
		err_codes_execd,
	},
	/* server/3; */
	{
		"(server/netmemory)",
		errlib_count(err_codes_netmemory),
		err_codes_netmemory,
	},
	/* server/4; */
	{
		"(server/cpu_server)",
		errlib_count(err_codes_cpu_server),
		err_codes_cpu_server,
	}
};


@EOF@

echo "libmach/err_ipc.sub"
cat >libmach/err_ipc.sub <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	err_ipc.sub,v $
NONERevision 1.1  90/02/19  18:07:36  bww
NONE	Mach Release 2.5
NONE	[90/02/19  18:07:07  bww]
NONE
 * Revision 1.2  89/05/05  18:40:22  mrt
 * 	16-May-88	Mary R. Thompson (mrt) at Carnegie Mellon
 * 
 *	Added ipc/send unused for 104
 * 09-Mar-88	Douglas Orr (dorr) at Carnegie-Mellon University
 *	created.
 */
/*
 * File:	err_ipc.sub
 * Purpose:
 *	Generic error code interface
 */

static char * err_codes_send[] = {
	"(ipc/send) unknown error",		/* -100 */
	"(ipc/send) invalid memory",		/* -101 */
	"(ipc/send) invalid port",		/* -102 */
	"(ipc/send) timed out",			/* -103 */
	"(ipc/send) unused error",		/* -104 */
	"(ipc/send) will notify",		/* -105 */
	"(ipc/send) notify in progress",	/* -106 */	
	"(ipc/send) kernel refused message",	/* -107 */
	"(ipc/send) send interrupted",		/* -108 */
	"(ipc/send) send message too large",	/* -109 */
	"(ipc/send) send message too small",	/* -110 */
	"(ipc/send) message size changed while being copied",	/* -111 */
};

static char * err_codes_rcv[] = {
	"(ipc/rcv) unknown error",			/* -200 */
	"(ipc/rcv) invalid memory",			/* -201 */
	"(ipc/rcv) invalid port",			/* -202 */
	"(ipc/rcv) receive timed out",			/* -203 */
	"(ipc/rcv) message too large",			/* -204 */
	"(ipc/rcv) no space for message data",		/* -205 */
	"(ipc/rcv) only sender remaining",		/* -206 */
	"(ipc/rcv) receive interrupted",		/* -207 */
	"(ipc/rcv) port receiver changed or port became enabled", /* -208 */
};

static char 	* err_codes_mig[] = {
	"(ipc/mig) type check failure in message interface",	/* 0 (-300) */
	"(ipc/mig) wrong return message ID",			/* 1 */
	"(ipc/mig) server detected error",			/* 2 */
	"(ipc/mig) bad message ID",				/* 3 */
	"(ipc/mig) server found wrong arguments",		/* 4 */
	"(ipc/mig) no reply should be sent",			/* 5 */
	"(ipc/mig) server raised exception",			/* 6 */
	"(ipc/mig) user specified array not large enough for return info",	/* 7 */
};

/*	err_ipc subsystems      	*/
static struct error_subsystem err_ipc_sub[] = {
	/* ipc/0; */
	{
		"(ipc/send)",
		errlib_count(err_codes_send),
		err_codes_send,
	},
	/* ipc/1; */
	{
		"(ipc/rcv)",
		errlib_count(err_codes_rcv),
		err_codes_rcv,

	},
	/* ipc/2 */
	{
		"(ipc/mig)",
		errlib_count(err_codes_mig),
		err_codes_mig,
	},

};

@EOF@

echo "libmach/SYS.h"
cat >libmach/SYS.h <<'@EOF@'
/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 **********************************************************************
 * HISTORY
 *
 * 21-Nov-88  Zon Williamson (zon) at Carnegie-Mellon University
 *      Created this version for the mac2.
 *
 **********************************************************************
 *
 *	@(#)SYS.h	5.4 (Berkeley) 6/27/88
 */

#include <:sys:syscall.h>

/* macros to profile assembly functions */

#ifdef	__STDC__
#ifdef	PROF
		    .globl  mcount
#define _MCOUNT	    link a6,\#0; lea mcntr,a0; \
		    .data; .even; mcntr: .long 0; \
		    .text; jsr mcount; unlk a6
#define _MCOUNT2    link a6,\#0; lea mcntr2,a0; \
		    .data; .even; mcntr2: .long 0; \
		    .text; jsr mcount; unlk a6
#else	/* PROF */
#define _MCOUNT
#define _MCOUNT2
#endif	/* PROF */
#define	ENTRY(x)    .globl _##x; _##x: _MCOUNT
#define	ENTRY2(x)    .globl _##x; _##x: _MCOUNT2
#else	/* __STDC__ */
#ifdef PROF
		    .globl  mcount
#define _MCOUNT	    link a6,#0; lea mcntr,a0; \
		    .data; .even; mcntr: .long 0; \
		    .text; jsr mcount; unlk a6
#define _MCOUNT2    link a6,#0; lea mcntr2,a0; \
		    .data; .even; mcntr2: .long 0; \
		    .text; jsr mcount; unlk a6
#else	/* PROF */
#define _MCOUNT
#define _MCOUNT2
#endif	/* PROF */
#define	ENTRY(x)    .globl _/**/x; _/**/x: _MCOUNT
#define	ENTRY2(x)   .globl _/**/x; _/**/x: _MCOUNT2
#endif	/* __STDC__ */

/* macros to make system calls with error returns */
#ifdef	__STDC__
#define	SYSCALL(x)  .globl cerror; err: jmp cerror; \
		    ENTRY(x); pea SYS_##x; trap \#0; jcs err
#define	PSEUDO(x,y) ENTRY(x); pea SYS_##y; trap \#0
#else	/* __STDC__ */
#define	SYSCALL(x)  .globl cerror; err: jmp cerror; \
		    ENTRY(x); pea SYS_/**/x; trap #0; jcs err
#define	PSEUDO(x,y) ENTRY(x); pea SYS_/**/y; trap #0
#endif	/* __STDC__ */

@EOF@

echo "libmach/env_mgrUser.c"
cat >libmach/env_mgrUser.c <<'@EOF@'
#include "env_mgr.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_env_mgr
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine env_set_string */
mig_external kern_return_t env_set_string
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	env_str_val_t env_val
)
#else
	(port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	env_str_val_t env_val;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_nameType;
		env_name_t env_name;
		msg_type_long_t env_valType;
		env_str_val_t env_val;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 384;

#if	UseStaticMsgType
	static msg_type_long_t env_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t env_valType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	2048,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_nameType = env_nameType;
#else	UseStaticMsgType
	InP->env_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_nameType.msg_type_long_size = 640;
	InP->env_nameType.msg_type_long_number = 1;
	InP->env_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->env_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->env_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->env_name /* env_name */, /* env_name */ env_name, 80);
	InP->env_name /* env_name */[79] = '\0';

#if	UseStaticMsgType
	InP->env_valType = env_valType;
#else	UseStaticMsgType
	InP->env_valType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_valType.msg_type_long_size = 2048;
	InP->env_valType.msg_type_long_number = 1;
	InP->env_valType.msg_type_header.msg_type_inline = TRUE;
	InP->env_valType.msg_type_header.msg_type_longform = TRUE;
	InP->env_valType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_valType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->env_val /* env_val */, /* env_val */ env_val, 256);
	InP->env_val /* env_val */[255] = '\0';

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1600;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1700)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine env_get_string */
mig_external kern_return_t env_get_string
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	env_str_val_t env_val
)
#else
	(port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	env_str_val_t env_val;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_nameType;
		env_name_t env_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t env_valType;
		env_str_val_t env_val;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 116;

#if	UseStaticMsgType
	static msg_type_long_t env_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_nameType = env_nameType;
#else	UseStaticMsgType
	InP->env_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_nameType.msg_type_long_size = 640;
	InP->env_nameType.msg_type_long_number = 1;
	InP->env_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->env_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->env_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->env_name /* env_name */, /* env_name */ env_name, 80);
	InP->env_name /* env_name */[79] = '\0';

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1601;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1701)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 300) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->env_valType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->env_valType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->env_valType.msg_type_long_name != MSG_TYPE_STRING) ||
	    (OutP->env_valType.msg_type_long_number != 1) ||
	    (OutP->env_valType.msg_type_long_size != 2048))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	(void) mig_strncpy(env_val /* env_val */, /* env_val */ OutP->env_val, 256);
	env_val /* env_val */[255] = '\0';

	return OutP->RetCode;
}

/* Routine env_del_string */
mig_external kern_return_t env_del_string
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name
)
#else
	(port, env_name)
	port_t port;
	env_name_t env_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_nameType;
		env_name_t env_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 116;

#if	UseStaticMsgType
	static msg_type_long_t env_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_nameType = env_nameType;
#else	UseStaticMsgType
	InP->env_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_nameType.msg_type_long_size = 640;
	InP->env_nameType.msg_type_long_number = 1;
	InP->env_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->env_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->env_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->env_name /* env_name */, /* env_name */ env_name, 80);
	InP->env_name /* env_name */[79] = '\0';

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1602;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1702)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine env_set_port */
mig_external kern_return_t env_set_port
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	port_t env_val
)
#else
	(port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	port_t env_val;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_nameType;
		env_name_t env_name;
		msg_type_t env_valType;
		port_t env_val;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 124;

#if	UseStaticMsgType
	static msg_type_long_t env_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t env_valType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_nameType = env_nameType;
#else	UseStaticMsgType
	InP->env_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_nameType.msg_type_long_size = 640;
	InP->env_nameType.msg_type_long_number = 1;
	InP->env_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->env_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->env_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->env_name /* env_name */, /* env_name */ env_name, 80);
	InP->env_name /* env_name */[79] = '\0';

#if	UseStaticMsgType
	InP->env_valType = env_valType;
#else	UseStaticMsgType
	InP->env_valType.msg_type_name = MSG_TYPE_PORT;
	InP->env_valType.msg_type_size = 32;
	InP->env_valType.msg_type_number = 1;
	InP->env_valType.msg_type_inline = TRUE;
	InP->env_valType.msg_type_longform = FALSE;
	InP->env_valType.msg_type_deallocate = FALSE;
	InP->env_valType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->env_val /* env_val */ = /* env_val */ env_val;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1603;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1703)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine env_get_port */
mig_external kern_return_t env_get_port
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	port_t *env_val
)
#else
	(port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	port_t *env_val;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_nameType;
		env_name_t env_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t env_valType;
		port_t env_val;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 116;

#if	UseStaticMsgType
	static msg_type_long_t env_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t env_valCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_nameType = env_nameType;
#else	UseStaticMsgType
	InP->env_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_nameType.msg_type_long_size = 640;
	InP->env_nameType.msg_type_long_number = 1;
	InP->env_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->env_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->env_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->env_name /* env_name */, /* env_name */ env_name, 80);
	InP->env_name /* env_name */[79] = '\0';

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1604;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1704)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->env_valType != * (int *) &env_valCheck)
#else	UseStaticMsgType
	if ((OutP->env_valType.msg_type_inline != TRUE) ||
	    (OutP->env_valType.msg_type_longform != FALSE) ||
	    (OutP->env_valType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->env_valType.msg_type_number != 1) ||
	    (OutP->env_valType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*env_val /* env_val */ = /* *env_val */ OutP->env_val;

	return OutP->RetCode;
}

/* Routine env_del_port */
mig_external kern_return_t env_del_port
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name
)
#else
	(port, env_name)
	port_t port;
	env_name_t env_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_nameType;
		env_name_t env_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 116;

#if	UseStaticMsgType
	static msg_type_long_t env_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_nameType = env_nameType;
#else	UseStaticMsgType
	InP->env_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_nameType.msg_type_long_size = 640;
	InP->env_nameType.msg_type_long_number = 1;
	InP->env_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->env_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->env_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->env_name /* env_name */, /* env_name */ env_name, 80);
	InP->env_name /* env_name */[79] = '\0';

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1605;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1705)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine env_list_strings */
mig_external kern_return_t env_list_strings
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list *env_names,
	unsigned int *env_namesCnt,
	env_str_list *env_string_vals,
	unsigned int *env_string_valsCnt
)
#else
	(port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt)
	port_t port;
	env_name_list *env_names;
	unsigned int *env_namesCnt;
	env_str_list *env_string_vals;
	unsigned int *env_string_valsCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t env_namesType;
		env_name_list env_names;
		msg_type_long_t env_string_valsType;
		env_str_list env_string_vals;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1606;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1706)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 64) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->env_namesType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->env_namesType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->env_namesType.msg_type_long_name != MSG_TYPE_STRING) ||
	    (OutP->env_namesType.msg_type_long_size != 640))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*env_names /* env_names */ = /* *env_names */ OutP->env_names;

	*env_namesCnt /* env_namesType.msg_type_long_number */ = /* *env_namesCnt */ OutP->env_namesType.msg_type_long_number;

#if	TypeCheck
	if ((OutP->env_string_valsType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->env_string_valsType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->env_string_valsType.msg_type_long_name != MSG_TYPE_STRING) ||
	    (OutP->env_string_valsType.msg_type_long_size != 2048))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*env_string_vals /* env_string_vals */ = /* *env_string_vals */ OutP->env_string_vals;

	*env_string_valsCnt /* env_string_valsType.msg_type_long_number */ = /* *env_string_valsCnt */ OutP->env_string_valsType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine env_list_ports */
mig_external kern_return_t env_list_ports
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list *env_names,
	unsigned int *env_namesCnt,
	port_array_t *env_ports_vals,
	unsigned int *env_ports_valsCnt
)
#else
	(port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt)
	port_t port;
	env_name_list *env_names;
	unsigned int *env_namesCnt;
	port_array_t *env_ports_vals;
	unsigned int *env_ports_valsCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t env_namesType;
		env_name_list env_names;
		msg_type_long_t env_ports_valsType;
		port_array_t env_ports_vals;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1607;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1707)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 64) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->env_namesType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->env_namesType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->env_namesType.msg_type_long_name != MSG_TYPE_STRING) ||
	    (OutP->env_namesType.msg_type_long_size != 640))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*env_names /* env_names */ = /* *env_names */ OutP->env_names;

	*env_namesCnt /* env_namesType.msg_type_long_number */ = /* *env_namesCnt */ OutP->env_namesType.msg_type_long_number;

#if	TypeCheck
	if ((OutP->env_ports_valsType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->env_ports_valsType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->env_ports_valsType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->env_ports_valsType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*env_ports_vals /* env_ports_vals */ = /* *env_ports_vals */ OutP->env_ports_vals;

	*env_ports_valsCnt /* env_ports_valsType.msg_type_long_number */ = /* *env_ports_valsCnt */ OutP->env_ports_valsType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine env_set_stlist */
mig_external kern_return_t env_set_stlist
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list env_names,
	unsigned int env_namesCnt,
	env_str_list env_string_vals,
	unsigned int env_string_valsCnt
)
#else
	(port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt)
	port_t port;
	env_name_list env_names;
	unsigned int env_namesCnt;
	env_str_list env_string_vals;
	unsigned int env_string_valsCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_namesType;
		env_name_list env_names;
		msg_type_long_t env_string_valsType;
		env_str_list env_string_vals;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 56;

#if	UseStaticMsgType
	static msg_type_long_t env_namesType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t env_string_valsType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	2048,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_namesType = env_namesType;
#else	UseStaticMsgType
	InP->env_namesType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_namesType.msg_type_long_size = 640;
	InP->env_namesType.msg_type_header.msg_type_inline = FALSE;
	InP->env_namesType.msg_type_header.msg_type_longform = TRUE;
	InP->env_namesType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_namesType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->env_names /* env_names */ = /* env_names */ env_names;

	InP->env_namesType.msg_type_long_number /* env_namesCnt */ = /* env_namesType.msg_type_long_number */ env_namesCnt;

#if	UseStaticMsgType
	InP->env_string_valsType = env_string_valsType;
#else	UseStaticMsgType
	InP->env_string_valsType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_string_valsType.msg_type_long_size = 2048;
	InP->env_string_valsType.msg_type_header.msg_type_inline = FALSE;
	InP->env_string_valsType.msg_type_header.msg_type_longform = TRUE;
	InP->env_string_valsType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_string_valsType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->env_string_vals /* env_string_vals */ = /* env_string_vals */ env_string_vals;

	InP->env_string_valsType.msg_type_long_number /* env_string_valsCnt */ = /* env_string_valsType.msg_type_long_number */ env_string_valsCnt;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1608;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1708)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine env_set_ptlist */
mig_external kern_return_t env_set_ptlist
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list env_names,
	unsigned int env_namesCnt,
	port_array_t env_ports_vals,
	unsigned int env_ports_valsCnt
)
#else
	(port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt)
	port_t port;
	env_name_list env_names;
	unsigned int env_namesCnt;
	port_array_t env_ports_vals;
	unsigned int env_ports_valsCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t env_namesType;
		env_name_list env_names;
		msg_type_long_t env_ports_valsType;
		port_array_t env_ports_vals;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 56;

#if	UseStaticMsgType
	static msg_type_long_t env_namesType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t env_ports_valsType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_PORT,
		/* msg_type_long_size = */	32,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->env_namesType = env_namesType;
#else	UseStaticMsgType
	InP->env_namesType.msg_type_long_name = MSG_TYPE_STRING;
	InP->env_namesType.msg_type_long_size = 640;
	InP->env_namesType.msg_type_header.msg_type_inline = FALSE;
	InP->env_namesType.msg_type_header.msg_type_longform = TRUE;
	InP->env_namesType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_namesType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->env_names /* env_names */ = /* env_names */ env_names;

	InP->env_namesType.msg_type_long_number /* env_namesCnt */ = /* env_namesType.msg_type_long_number */ env_namesCnt;

#if	UseStaticMsgType
	InP->env_ports_valsType = env_ports_valsType;
#else	UseStaticMsgType
	InP->env_ports_valsType.msg_type_long_name = MSG_TYPE_PORT;
	InP->env_ports_valsType.msg_type_long_size = 32;
	InP->env_ports_valsType.msg_type_header.msg_type_inline = FALSE;
	InP->env_ports_valsType.msg_type_header.msg_type_longform = TRUE;
	InP->env_ports_valsType.msg_type_header.msg_type_deallocate = FALSE;
	InP->env_ports_valsType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->env_ports_vals /* env_ports_vals */ = /* env_ports_vals */ env_ports_vals;

	InP->env_ports_valsType.msg_type_long_number /* env_ports_valsCnt */ = /* env_ports_valsType.msg_type_long_number */ env_ports_valsCnt;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1609;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1709)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine env_copy_conn */
mig_external kern_return_t env_copy_conn
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
)
#else
	(port, new_env_port)
	port_t port;
	port_t *new_env_port;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t new_env_portType;
		port_t new_env_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_env_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_OWNERSHIP,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1610;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1710)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->new_env_portType != * (int *) &new_env_portCheck)
#else	UseStaticMsgType
	if ((OutP->new_env_portType.msg_type_inline != TRUE) ||
	    (OutP->new_env_portType.msg_type_longform != FALSE) ||
	    (OutP->new_env_portType.msg_type_name != MSG_TYPE_PORT_OWNERSHIP) ||
	    (OutP->new_env_portType.msg_type_number != 1) ||
	    (OutP->new_env_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*new_env_port /* new_env_port */ = /* *new_env_port */ OutP->new_env_port;

	return OutP->RetCode;
}

/* Routine env_new_conn */
mig_external kern_return_t env_new_conn
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
)
#else
	(port, new_env_port)
	port_t port;
	port_t *new_env_port;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t new_env_portType;
		port_t new_env_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_env_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_OWNERSHIP,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1611;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1711)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->new_env_portType != * (int *) &new_env_portCheck)
#else	UseStaticMsgType
	if ((OutP->new_env_portType.msg_type_inline != TRUE) ||
	    (OutP->new_env_portType.msg_type_longform != FALSE) ||
	    (OutP->new_env_portType.msg_type_name != MSG_TYPE_PORT_OWNERSHIP) ||
	    (OutP->new_env_portType.msg_type_number != 1) ||
	    (OutP->new_env_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*new_env_port /* new_env_port */ = /* *new_env_port */ OutP->new_env_port;

	return OutP->RetCode;
}

/* Routine env_restrict_conn */
mig_external kern_return_t env_restrict_conn
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
)
#else
	(port, new_env_port)
	port_t port;
	port_t *new_env_port;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t new_env_portType;
		port_t new_env_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_env_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_OWNERSHIP,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1612;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1712)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->new_env_portType != * (int *) &new_env_portCheck)
#else	UseStaticMsgType
	if ((OutP->new_env_portType.msg_type_inline != TRUE) ||
	    (OutP->new_env_portType.msg_type_longform != FALSE) ||
	    (OutP->new_env_portType.msg_type_name != MSG_TYPE_PORT_OWNERSHIP) ||
	    (OutP->new_env_portType.msg_type_number != 1) ||
	    (OutP->new_env_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*new_env_port /* new_env_port */ = /* *new_env_port */ OutP->new_env_port;

	return OutP->RetCode;
}

/* Routine env_disconnect */
mig_external kern_return_t env_disconnect
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port
)
#else
	(port)
	port_t port;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1613;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1713)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}
@EOF@

echo "libmach/ipcxUser.c"
cat >libmach/ipcxUser.c <<'@EOF@'
#include "ipcx.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_ipcx
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine startserver */
mig_external kern_return_t startserver
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t mPort,
	a_string userid,
	a_string password,
	a_string commandline,
	port_t *serverkport,
	port_t *serverdport
)
#else
	(mPort, userid, password, commandline, serverkport, serverdport)
	port_t mPort;
	a_string userid;
	a_string password;
	a_string commandline;
	port_t *serverkport;
	port_t *serverdport;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t useridType;
		a_string userid;
		msg_type_long_t passwordType;
		a_string password;
		msg_type_long_t commandlineType;
		a_string commandline;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t serverkportType;
		port_t serverkport;
		msg_type_t serverdportType;
		port_t serverdport;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 828;

#if	UseStaticMsgType
	static msg_type_long_t useridType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	2048,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t passwordType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	2048,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t commandlineType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	2048,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t serverkportCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t serverdportCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->useridType = useridType;
#else	UseStaticMsgType
	InP->useridType.msg_type_long_name = MSG_TYPE_STRING;
	InP->useridType.msg_type_long_size = 2048;
	InP->useridType.msg_type_long_number = 1;
	InP->useridType.msg_type_header.msg_type_inline = TRUE;
	InP->useridType.msg_type_header.msg_type_longform = TRUE;
	InP->useridType.msg_type_header.msg_type_deallocate = FALSE;
	InP->useridType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->userid /* userid */, /* userid */ userid, 256);
	InP->userid /* userid */[255] = '\0';

#if	UseStaticMsgType
	InP->passwordType = passwordType;
#else	UseStaticMsgType
	InP->passwordType.msg_type_long_name = MSG_TYPE_STRING;
	InP->passwordType.msg_type_long_size = 2048;
	InP->passwordType.msg_type_long_number = 1;
	InP->passwordType.msg_type_header.msg_type_inline = TRUE;
	InP->passwordType.msg_type_header.msg_type_longform = TRUE;
	InP->passwordType.msg_type_header.msg_type_deallocate = FALSE;
	InP->passwordType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->password /* password */, /* password */ password, 256);
	InP->password /* password */[255] = '\0';

#if	UseStaticMsgType
	InP->commandlineType = commandlineType;
#else	UseStaticMsgType
	InP->commandlineType.msg_type_long_name = MSG_TYPE_STRING;
	InP->commandlineType.msg_type_long_size = 2048;
	InP->commandlineType.msg_type_long_number = 1;
	InP->commandlineType.msg_type_header.msg_type_inline = TRUE;
	InP->commandlineType.msg_type_header.msg_type_longform = TRUE;
	InP->commandlineType.msg_type_header.msg_type_deallocate = FALSE;
	InP->commandlineType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->commandline /* commandline */, /* commandline */ commandline, 256);
	InP->commandline /* commandline */[255] = '\0';

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = mPort;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 27600;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 27700)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->serverkportType != * (int *) &serverkportCheck)
#else	UseStaticMsgType
	if ((OutP->serverkportType.msg_type_inline != TRUE) ||
	    (OutP->serverkportType.msg_type_longform != FALSE) ||
	    (OutP->serverkportType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->serverkportType.msg_type_number != 1) ||
	    (OutP->serverkportType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*serverkport /* serverkport */ = /* *serverkport */ OutP->serverkport;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->serverdportType != * (int *) &serverdportCheck)
#else	UseStaticMsgType
	if ((OutP->serverdportType.msg_type_inline != TRUE) ||
	    (OutP->serverdportType.msg_type_longform != FALSE) ||
	    (OutP->serverdportType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->serverdportType.msg_type_number != 1) ||
	    (OutP->serverdportType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*serverdport /* serverdport */ = /* *serverdport */ OutP->serverdport;

	return OutP->RetCode;
}
@EOF@

echo "libmach/netnameUser.c"
cat >libmach/netnameUser.c <<'@EOF@'
#include "netname.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_netname
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine netname_check_in */
mig_external kern_return_t netname_check_in
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t port_name,
	port_t signature,
	port_t port_id
)
#else
	(server_port, port_name, signature, port_id)
	port_t server_port;
	netname_name_t port_name;
	port_t signature;
	port_t port_id;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t port_nameType;
		netname_name_t port_name;
		msg_type_t signatureType;
		port_t signature;
		msg_type_t port_idType;
		port_t port_id;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 132;

#if	UseStaticMsgType
	static msg_type_long_t port_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t signatureType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t port_idType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->port_nameType.msg_type_long_size = 640;
	InP->port_nameType.msg_type_long_number = 1;
	InP->port_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->port_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->port_name /* port_name */, /* port_name */ port_name, 80);
	InP->port_name /* port_name */[79] = '\0';

#if	UseStaticMsgType
	InP->signatureType = signatureType;
#else	UseStaticMsgType
	InP->signatureType.msg_type_name = MSG_TYPE_PORT;
	InP->signatureType.msg_type_size = 32;
	InP->signatureType.msg_type_number = 1;
	InP->signatureType.msg_type_inline = TRUE;
	InP->signatureType.msg_type_longform = FALSE;
	InP->signatureType.msg_type_deallocate = FALSE;
	InP->signatureType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->signature /* signature */ = /* signature */ signature;

#if	UseStaticMsgType
	InP->port_idType = port_idType;
#else	UseStaticMsgType
	InP->port_idType.msg_type_name = MSG_TYPE_PORT;
	InP->port_idType.msg_type_size = 32;
	InP->port_idType.msg_type_number = 1;
	InP->port_idType.msg_type_inline = TRUE;
	InP->port_idType.msg_type_longform = FALSE;
	InP->port_idType.msg_type_deallocate = FALSE;
	InP->port_idType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_id /* port_id */ = /* port_id */ port_id;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = server_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1040;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1140)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine netname_look_up */
mig_external kern_return_t netname_look_up
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t host_name,
	netname_name_t port_name,
	port_t *port_id
)
#else
	(server_port, host_name, port_name, port_id)
	port_t server_port;
	netname_name_t host_name;
	netname_name_t port_name;
	port_t *port_id;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t host_nameType;
		netname_name_t host_name;
		msg_type_long_t port_nameType;
		netname_name_t port_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t port_idType;
		port_t port_id;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 208;

#if	UseStaticMsgType
	static msg_type_long_t host_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t port_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t port_idCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->host_nameType = host_nameType;
#else	UseStaticMsgType
	InP->host_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->host_nameType.msg_type_long_size = 640;
	InP->host_nameType.msg_type_long_number = 1;
	InP->host_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->host_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->host_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->host_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->host_name /* host_name */, /* host_name */ host_name, 80);
	InP->host_name /* host_name */[79] = '\0';

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->port_nameType.msg_type_long_size = 640;
	InP->port_nameType.msg_type_long_number = 1;
	InP->port_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->port_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->port_name /* port_name */, /* port_name */ port_name, 80);
	InP->port_name /* port_name */[79] = '\0';

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = server_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1041;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1141)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->port_idType != * (int *) &port_idCheck)
#else	UseStaticMsgType
	if ((OutP->port_idType.msg_type_inline != TRUE) ||
	    (OutP->port_idType.msg_type_longform != FALSE) ||
	    (OutP->port_idType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->port_idType.msg_type_number != 1) ||
	    (OutP->port_idType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*port_id /* port_id */ = /* *port_id */ OutP->port_id;

	return OutP->RetCode;
}

/* Routine netname_check_out */
mig_external kern_return_t netname_check_out
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t port_name,
	port_t signature
)
#else
	(server_port, port_name, signature)
	port_t server_port;
	netname_name_t port_name;
	port_t signature;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t port_nameType;
		netname_name_t port_name;
		msg_type_t signatureType;
		port_t signature;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 124;

#if	UseStaticMsgType
	static msg_type_long_t port_nameType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_STRING,
		/* msg_type_long_size = */	640,
		/* msg_type_long_number = */	1
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t signatureType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_long_name = MSG_TYPE_STRING;
	InP->port_nameType.msg_type_long_size = 640;
	InP->port_nameType.msg_type_long_number = 1;
	InP->port_nameType.msg_type_header.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_header.msg_type_longform = TRUE;
	InP->port_nameType.msg_type_header.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	(void) mig_strncpy(InP->port_name /* port_name */, /* port_name */ port_name, 80);
	InP->port_name /* port_name */[79] = '\0';

#if	UseStaticMsgType
	InP->signatureType = signatureType;
#else	UseStaticMsgType
	InP->signatureType.msg_type_name = MSG_TYPE_PORT;
	InP->signatureType.msg_type_size = 32;
	InP->signatureType.msg_type_number = 1;
	InP->signatureType.msg_type_inline = TRUE;
	InP->signatureType.msg_type_longform = FALSE;
	InP->signatureType.msg_type_deallocate = FALSE;
	InP->signatureType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->signature /* signature */ = /* signature */ signature;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = server_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1042;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1142)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine netname_version */
mig_external kern_return_t netname_version
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t version
)
#else
	(server_port, version)
	port_t server_port;
	netname_name_t version;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t versionType;
		netname_name_t version;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = server_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 1043;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 1143)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 124) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->versionType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->versionType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->versionType.msg_type_long_name != MSG_TYPE_STRING) ||
	    (OutP->versionType.msg_type_long_number != 1) ||
	    (OutP->versionType.msg_type_long_size != 640))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	(void) mig_strncpy(version /* version */, /* version */ OutP->version, 80);
	version /* version */[79] = '\0';

	return OutP->RetCode;
}
@EOF@

echo "libmach/serviceUser.c"
cat >libmach/serviceUser.c <<'@EOF@'
#include "service.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_service
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine old_service_checkin */
mig_external kern_return_t old_service_checkin
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t service_request,
	port_t service_desired,
	port_t *service_granted
)
#else
	(service_request, service_desired, service_granted)
	port_t service_request;
	port_t service_desired;
	port_t *service_granted;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t service_desiredType;
		port_t service_desired;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t service_grantedType;
		port_t service_granted;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t service_desiredType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t service_grantedCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_RECEIVE,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->service_desiredType = service_desiredType;
#else	UseStaticMsgType
	InP->service_desiredType.msg_type_name = MSG_TYPE_PORT;
	InP->service_desiredType.msg_type_size = 32;
	InP->service_desiredType.msg_type_number = 1;
	InP->service_desiredType.msg_type_inline = TRUE;
	InP->service_desiredType.msg_type_longform = FALSE;
	InP->service_desiredType.msg_type_deallocate = FALSE;
	InP->service_desiredType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->service_desired /* service_desired */ = /* service_desired */ service_desired;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = service_request;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 400;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 500)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->service_grantedType != * (int *) &service_grantedCheck)
#else	UseStaticMsgType
	if ((OutP->service_grantedType.msg_type_inline != TRUE) ||
	    (OutP->service_grantedType.msg_type_longform != FALSE) ||
	    (OutP->service_grantedType.msg_type_name != MSG_TYPE_PORT_RECEIVE) ||
	    (OutP->service_grantedType.msg_type_number != 1) ||
	    (OutP->service_grantedType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*service_granted /* service_granted */ = /* *service_granted */ OutP->service_granted;

	return OutP->RetCode;
}

/* Routine service_checkin */
mig_external kern_return_t service_checkin
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t service_request,
	port_t service_desired,
	port_t *service_granted
)
#else
	(service_request, service_desired, service_granted)
	port_t service_request;
	port_t service_desired;
	port_t *service_granted;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t service_desiredType;
		port_t service_desired;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t service_grantedType;
		port_t service_granted;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t service_desiredType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t service_grantedCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_ALL,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->service_desiredType = service_desiredType;
#else	UseStaticMsgType
	InP->service_desiredType.msg_type_name = MSG_TYPE_PORT;
	InP->service_desiredType.msg_type_size = 32;
	InP->service_desiredType.msg_type_number = 1;
	InP->service_desiredType.msg_type_inline = TRUE;
	InP->service_desiredType.msg_type_longform = FALSE;
	InP->service_desiredType.msg_type_deallocate = FALSE;
	InP->service_desiredType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->service_desired /* service_desired */ = /* service_desired */ service_desired;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = service_request;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 401;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 501)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->service_grantedType != * (int *) &service_grantedCheck)
#else	UseStaticMsgType
	if ((OutP->service_grantedType.msg_type_inline != TRUE) ||
	    (OutP->service_grantedType.msg_type_longform != FALSE) ||
	    (OutP->service_grantedType.msg_type_name != MSG_TYPE_PORT_ALL) ||
	    (OutP->service_grantedType.msg_type_number != 1) ||
	    (OutP->service_grantedType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*service_granted /* service_granted */ = /* *service_granted */ OutP->service_granted;

	return OutP->RetCode;
}
@EOF@

echo "libmach/excUser.c"
cat >libmach/excUser.c <<'@EOF@'
#include "exc.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_exc
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine exception_raise */
mig_external kern_return_t exception_raise
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t exception_port,
	port_t clear_port,
	port_t thread,
	port_t task,
	int exception,
	int code,
	int subcode
)
#else
	(exception_port, clear_port, thread, task, exception, code, subcode)
	port_t exception_port;
	port_t clear_port;
	port_t thread;
	port_t task;
	int exception;
	int code;
	int subcode;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t threadType;
		port_t thread;
		msg_type_t taskType;
		port_t task;
		msg_type_t exceptionType;
		int exception;
		msg_type_t codeType;
		int code;
		msg_type_t subcodeType;
		int subcode;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 64;

#if	UseStaticMsgType
	static msg_type_t threadType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t taskType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t exceptionType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t codeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t subcodeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->threadType = threadType;
#else	UseStaticMsgType
	InP->threadType.msg_type_name = MSG_TYPE_PORT;
	InP->threadType.msg_type_size = 32;
	InP->threadType.msg_type_number = 1;
	InP->threadType.msg_type_inline = TRUE;
	InP->threadType.msg_type_longform = FALSE;
	InP->threadType.msg_type_deallocate = FALSE;
	InP->threadType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->thread /* thread */ = /* thread */ thread;

#if	UseStaticMsgType
	InP->taskType = taskType;
#else	UseStaticMsgType
	InP->taskType.msg_type_name = MSG_TYPE_PORT;
	InP->taskType.msg_type_size = 32;
	InP->taskType.msg_type_number = 1;
	InP->taskType.msg_type_inline = TRUE;
	InP->taskType.msg_type_longform = FALSE;
	InP->taskType.msg_type_deallocate = FALSE;
	InP->taskType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->task /* task */ = /* task */ task;

#if	UseStaticMsgType
	InP->exceptionType = exceptionType;
#else	UseStaticMsgType
	InP->exceptionType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->exceptionType.msg_type_size = 32;
	InP->exceptionType.msg_type_number = 1;
	InP->exceptionType.msg_type_inline = TRUE;
	InP->exceptionType.msg_type_longform = FALSE;
	InP->exceptionType.msg_type_deallocate = FALSE;
	InP->exceptionType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->exception /* exception */ = /* exception */ exception;

#if	UseStaticMsgType
	InP->codeType = codeType;
#else	UseStaticMsgType
	InP->codeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->codeType.msg_type_size = 32;
	InP->codeType.msg_type_number = 1;
	InP->codeType.msg_type_inline = TRUE;
	InP->codeType.msg_type_longform = FALSE;
	InP->codeType.msg_type_deallocate = FALSE;
	InP->codeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->code /* code */ = /* code */ code;

#if	UseStaticMsgType
	InP->subcodeType = subcodeType;
#else	UseStaticMsgType
	InP->subcodeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->subcodeType.msg_type_size = 32;
	InP->subcodeType.msg_type_number = 1;
	InP->subcodeType.msg_type_inline = TRUE;
	InP->subcodeType.msg_type_longform = FALSE;
	InP->subcodeType.msg_type_deallocate = FALSE;
	InP->subcodeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->subcode /* subcode */ = /* subcode */ subcode;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = exception_port;
	InP->Head.msg_reply_port = clear_port;
	InP->Head.msg_id = 2400;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2500)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}
@EOF@

echo "libmach/excServer.c"
cat >libmach/excServer.c <<'@EOF@'
/* Module exc */

#define EXPORT_BOOLEAN
#include <:mach:boolean.h>
#include <:mach:message.h>
#include <:mach:mig_errors.h>

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

/* Due to pcc compiler bug, cannot use void */
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(hc)
#define novalue void
#else
#define novalue int
#endif

#define msg_request_port	msg_local_port
#define msg_reply_port		msg_remote_port
#include <:mach:std_types.h>

/* Routine exception_raise */
mig_internal novalue _Xexception_raise
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t threadType;
		port_t thread;
		msg_type_t taskType;
		port_t task;
		msg_type_t exceptionType;
		int exception;
		msg_type_t codeType;
		int code;
		msg_type_t subcodeType;
		int subcode;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t catch_exception_raise
#if	(defined(__STDC__) || defined(c_plusplus))
		(port_t exception_port, port_t thread, port_t task, int exception, int code, int subcode);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t threadCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t taskCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t exceptionCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t codeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t subcodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 64) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->threadType != * (int *) &threadCheck)
#else	UseStaticMsgType
	if ((In0P->threadType.msg_type_inline != TRUE) ||
	    (In0P->threadType.msg_type_longform != FALSE) ||
	    (In0P->threadType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->threadType.msg_type_number != 1) ||
	    (In0P->threadType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->taskType != * (int *) &taskCheck)
#else	UseStaticMsgType
	if ((In0P->taskType.msg_type_inline != TRUE) ||
	    (In0P->taskType.msg_type_longform != FALSE) ||
	    (In0P->taskType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->taskType.msg_type_number != 1) ||
	    (In0P->taskType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->exceptionType != * (int *) &exceptionCheck)
#else	UseStaticMsgType
	if ((In0P->exceptionType.msg_type_inline != TRUE) ||
	    (In0P->exceptionType.msg_type_longform != FALSE) ||
	    (In0P->exceptionType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->exceptionType.msg_type_number != 1) ||
	    (In0P->exceptionType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->codeType != * (int *) &codeCheck)
#else	UseStaticMsgType
	if ((In0P->codeType.msg_type_inline != TRUE) ||
	    (In0P->codeType.msg_type_longform != FALSE) ||
	    (In0P->codeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->codeType.msg_type_number != 1) ||
	    (In0P->codeType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->subcodeType != * (int *) &subcodeCheck)
#else	UseStaticMsgType
	if ((In0P->subcodeType.msg_type_inline != TRUE) ||
	    (In0P->subcodeType.msg_type_longform != FALSE) ||
	    (In0P->subcodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->subcodeType.msg_type_number != 1) ||
	    (In0P->subcodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	OutP->RetCode = catch_exception_raise(In0P->Head.msg_request_port, In0P->thread, In0P->task, In0P->exception, In0P->code, In0P->subcode);
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	if (OutP->RetCode != KERN_SUCCESS)
		return;

	msg_size = 32;

	OutP->Head.msg_simple = TRUE;
	OutP->Head.msg_size = msg_size;
}

boolean_t exc_server
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	register msg_header_t *InP =  InHeadP;
	register death_pill_t *OutP = (death_pill_t *) OutHeadP;

#if	UseStaticMsgType
	static msg_type_t RetCodeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	OutP->Head.msg_simple = TRUE;
	OutP->Head.msg_size = sizeof *OutP;
	OutP->Head.msg_type = InP->msg_type;
	OutP->Head.msg_local_port = PORT_NULL;
	OutP->Head.msg_remote_port = InP->msg_reply_port;
	OutP->Head.msg_id = InP->msg_id + 100;

#if	UseStaticMsgType
	OutP->RetCodeType = RetCodeType;
#else	UseStaticMsgType
	OutP->RetCodeType.msg_type_name = MSG_TYPE_INTEGER_32;
	OutP->RetCodeType.msg_type_size = 32;
	OutP->RetCodeType.msg_type_number = 1;
	OutP->RetCodeType.msg_type_inline = TRUE;
	OutP->RetCodeType.msg_type_longform = FALSE;
	OutP->RetCodeType.msg_type_deallocate = FALSE;
	OutP->RetCodeType.msg_type_unused = 0;
#endif	UseStaticMsgType
	OutP->RetCode = MIG_BAD_ID;

	if ((InP->msg_id > 2400) || (InP->msg_id < 2400))
		return FALSE;
	else {
		typedef novalue (*SERVER_STUB_PROC)
#if	(defined(__STDC__) || defined(c_plusplus))
			(msg_header_t *, msg_header_t *);
#else
			();
#endif
		static SERVER_STUB_PROC routines[] = {
			_Xexception_raise,
		};

		if (routines[InP->msg_id - 2400])
			(routines[InP->msg_id - 2400]) (InP, &OutP->Head);
		 else
			return FALSE;
	}
	return TRUE;
}
@EOF@

echo "libmach/netmemoryUser.c"
cat >libmach/netmemoryUser.c <<'@EOF@'
#include "netmemory.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_netmemory
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine netmemory_create */
mig_external kern_return_t netmemory_create
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	vm_size_t object_size,
	port_t *paging_object,
	port_t *control_port
)
#else
	(server_port, object_size, paging_object, control_port)
	port_t server_port;
	vm_size_t object_size;
	port_t *paging_object;
	port_t *control_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t object_sizeType;
		vm_size_t object_size;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t paging_objectType;
		port_t paging_object;
		msg_type_t control_portType;
		port_t control_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t object_sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t paging_objectCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t control_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->object_sizeType = object_sizeType;
#else	UseStaticMsgType
	InP->object_sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->object_sizeType.msg_type_size = 32;
	InP->object_sizeType.msg_type_number = 1;
	InP->object_sizeType.msg_type_inline = TRUE;
	InP->object_sizeType.msg_type_longform = FALSE;
	InP->object_sizeType.msg_type_deallocate = FALSE;
	InP->object_sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->object_size /* object_size */ = /* object_size */ object_size;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = server_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 4200;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 4300)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->paging_objectType != * (int *) &paging_objectCheck)
#else	UseStaticMsgType
	if ((OutP->paging_objectType.msg_type_inline != TRUE) ||
	    (OutP->paging_objectType.msg_type_longform != FALSE) ||
	    (OutP->paging_objectType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->paging_objectType.msg_type_number != 1) ||
	    (OutP->paging_objectType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*paging_object /* paging_object */ = /* *paging_object */ OutP->paging_object;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->control_portType != * (int *) &control_portCheck)
#else	UseStaticMsgType
	if ((OutP->control_portType.msg_type_inline != TRUE) ||
	    (OutP->control_portType.msg_type_longform != FALSE) ||
	    (OutP->control_portType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->control_portType.msg_type_number != 1) ||
	    (OutP->control_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*control_port /* control_port */ = /* *control_port */ OutP->control_port;

	return OutP->RetCode;
}

/* Routine netmemory_destroy */
mig_external kern_return_t netmemory_destroy
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t control_port
)
#else
	(control_port)
	port_t control_port;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = control_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 4201;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 4301)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine netmemory_cache */
mig_external kern_return_t netmemory_cache
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	port_t paging_object,
	port_t *local_paging_object
)
#else
	(server_port, paging_object, local_paging_object)
	port_t server_port;
	port_t paging_object;
	port_t *local_paging_object;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t paging_objectType;
		port_t paging_object;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t local_paging_objectType;
		port_t local_paging_object;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t paging_objectType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t local_paging_objectCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->paging_objectType = paging_objectType;
#else	UseStaticMsgType
	InP->paging_objectType.msg_type_name = MSG_TYPE_PORT;
	InP->paging_objectType.msg_type_size = 32;
	InP->paging_objectType.msg_type_number = 1;
	InP->paging_objectType.msg_type_inline = TRUE;
	InP->paging_objectType.msg_type_longform = FALSE;
	InP->paging_objectType.msg_type_deallocate = FALSE;
	InP->paging_objectType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->paging_object /* paging_object */ = /* paging_object */ paging_object;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = server_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 4202;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 4302)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->local_paging_objectType != * (int *) &local_paging_objectCheck)
#else	UseStaticMsgType
	if ((OutP->local_paging_objectType.msg_type_inline != TRUE) ||
	    (OutP->local_paging_objectType.msg_type_longform != FALSE) ||
	    (OutP->local_paging_objectType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->local_paging_objectType.msg_type_number != 1) ||
	    (OutP->local_paging_objectType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*local_paging_object /* local_paging_object */ = /* *local_paging_object */ OutP->local_paging_object;

	return OutP->RetCode;
}

/* Routine paging_object_server_statistics */
mig_external kern_return_t paging_object_server_statistics
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t object_server,
	pointer_t *rusage,
	unsigned int *rusageCnt,
	pointer_t *faults_total,
	unsigned int *faults_totalCnt
)
#else
	(object_server, rusage, rusageCnt, faults_total, faults_totalCnt)
	port_t object_server;
	pointer_t *rusage;
	unsigned int *rusageCnt;
	pointer_t *faults_total;
	unsigned int *faults_totalCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t rusageType;
		pointer_t rusage;
		msg_type_long_t faults_totalType;
		pointer_t faults_total;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = object_server;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 4203;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 4303)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 64) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->rusageType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->rusageType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->rusageType.msg_type_long_name != MSG_TYPE_BYTE) ||
	    (OutP->rusageType.msg_type_long_size != 8))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*rusage /* rusage */ = /* *rusage */ OutP->rusage;

	*rusageCnt /* rusageType.msg_type_long_number */ = /* *rusageCnt */ OutP->rusageType.msg_type_long_number;

#if	TypeCheck
	if ((OutP->faults_totalType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->faults_totalType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->faults_totalType.msg_type_long_name != MSG_TYPE_BYTE) ||
	    (OutP->faults_totalType.msg_type_long_size != 8))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*faults_total /* faults_total */ = /* *faults_total */ OutP->faults_total;

	*faults_totalCnt /* faults_totalType.msg_type_long_number */ = /* *faults_totalCnt */ OutP->faults_totalType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine netmemory_cover */
mig_external kern_return_t netmemory_cover
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	pointer_t object_data,
	unsigned int object_dataCnt,
	port_t *paging_object,
	port_t *control_port
)
#else
	(server_port, object_data, object_dataCnt, paging_object, control_port)
	port_t server_port;
	pointer_t object_data;
	unsigned int object_dataCnt;
	port_t *paging_object;
	port_t *control_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t object_dataType;
		pointer_t object_data;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t paging_objectType;
		port_t paging_object;
		msg_type_t control_portType;
		port_t control_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_long_t object_dataType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_BYTE,
		/* msg_type_long_size = */	8,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t paging_objectCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t control_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->object_dataType = object_dataType;
#else	UseStaticMsgType
	InP->object_dataType.msg_type_long_name = MSG_TYPE_BYTE;
	InP->object_dataType.msg_type_long_size = 8;
	InP->object_dataType.msg_type_header.msg_type_inline = FALSE;
	InP->object_dataType.msg_type_header.msg_type_longform = TRUE;
	InP->object_dataType.msg_type_header.msg_type_deallocate = FALSE;
	InP->object_dataType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->object_data /* object_data */ = /* object_data */ object_data;

	InP->object_dataType.msg_type_long_number /* object_dataCnt */ = /* object_dataType.msg_type_long_number */ object_dataCnt;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = server_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 4204;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 4304)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->paging_objectType != * (int *) &paging_objectCheck)
#else	UseStaticMsgType
	if ((OutP->paging_objectType.msg_type_inline != TRUE) ||
	    (OutP->paging_objectType.msg_type_longform != FALSE) ||
	    (OutP->paging_objectType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->paging_objectType.msg_type_number != 1) ||
	    (OutP->paging_objectType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*paging_object /* paging_object */ = /* *paging_object */ OutP->paging_object;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->control_portType != * (int *) &control_portCheck)
#else	UseStaticMsgType
	if ((OutP->control_portType.msg_type_inline != TRUE) ||
	    (OutP->control_portType.msg_type_longform != FALSE) ||
	    (OutP->control_portType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->control_portType.msg_type_number != 1) ||
	    (OutP->control_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*control_port /* control_port */ = /* *control_port */ OutP->control_port;

	return OutP->RetCode;
}
@EOF@

echo "libmach/netmemstatUser.c"
cat >libmach/netmemstatUser.c <<'@EOF@'
#include "netmemstat.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_netmemstat
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine paging_object_statistics */
mig_external kern_return_t paging_object_statistics
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t paging_object,
	pointer_t *faults_per_page,
	unsigned int *faults_per_pageCnt,
	pointer_t *faults_total,
	unsigned int *faults_totalCnt
)
#else
	(paging_object, faults_per_page, faults_per_pageCnt, faults_total, faults_totalCnt)
	port_t paging_object;
	pointer_t *faults_per_page;
	unsigned int *faults_per_pageCnt;
	pointer_t *faults_total;
	unsigned int *faults_totalCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t faults_per_pageType;
		pointer_t faults_per_page;
		msg_type_long_t faults_totalType;
		pointer_t faults_total;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = paging_object;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 4220;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 4320)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 64) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->faults_per_pageType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->faults_per_pageType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->faults_per_pageType.msg_type_long_name != MSG_TYPE_BYTE) ||
	    (OutP->faults_per_pageType.msg_type_long_size != 8))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*faults_per_page /* faults_per_page */ = /* *faults_per_page */ OutP->faults_per_page;

	*faults_per_pageCnt /* faults_per_pageType.msg_type_long_number */ = /* *faults_per_pageCnt */ OutP->faults_per_pageType.msg_type_long_number;

#if	TypeCheck
	if ((OutP->faults_totalType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->faults_totalType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->faults_totalType.msg_type_long_name != MSG_TYPE_BYTE) ||
	    (OutP->faults_totalType.msg_type_long_size != 8))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*faults_total /* faults_total */ = /* *faults_total */ OutP->faults_total;

	*faults_totalCnt /* faults_totalType.msg_type_long_number */ = /* *faults_totalCnt */ OutP->faults_totalType.msg_type_long_number;

	return OutP->RetCode;
}
@EOF@

echo "libmach/memory_objectServer.c"
cat >libmach/memory_objectServer.c <<'@EOF@'
/* Module memory_object */

#define EXPORT_BOOLEAN
#include <:mach:boolean.h>
#include <:mach:message.h>
#include <:mach:mig_errors.h>

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

/* Due to pcc compiler bug, cannot use void */
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(hc)
#define novalue void
#else
#define novalue int
#endif

#define msg_request_port	msg_local_port
#define msg_reply_port		msg_remote_port
#include <:mach:std_types.h>
#include <:mach:mach_types.h>

/* SimpleRoutine memory_object_init */
mig_internal novalue _Xmemory_object_init
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t memory_controlType;
		memory_object_control_t memory_control;
		msg_type_t memory_object_nameType;
		memory_object_name_t memory_object_name;
		msg_type_t memory_object_page_sizeType;
		vm_size_t memory_object_page_size;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t memory_object_init
#if	(defined(__STDC__) || defined(c_plusplus))
		(memory_object_t memory_object, memory_object_control_t memory_control, memory_object_name_t memory_object_name, vm_size_t memory_object_page_size);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t memory_controlCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t memory_object_nameCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t memory_object_page_sizeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 48) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_controlType != * (int *) &memory_controlCheck)
#else	UseStaticMsgType
	if ((In0P->memory_controlType.msg_type_inline != TRUE) ||
	    (In0P->memory_controlType.msg_type_longform != FALSE) ||
	    (In0P->memory_controlType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->memory_controlType.msg_type_number != 1) ||
	    (In0P->memory_controlType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_object_nameType != * (int *) &memory_object_nameCheck)
#else	UseStaticMsgType
	if ((In0P->memory_object_nameType.msg_type_inline != TRUE) ||
	    (In0P->memory_object_nameType.msg_type_longform != FALSE) ||
	    (In0P->memory_object_nameType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->memory_object_nameType.msg_type_number != 1) ||
	    (In0P->memory_object_nameType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_object_page_sizeType != * (int *) &memory_object_page_sizeCheck)
#else	UseStaticMsgType
	if ((In0P->memory_object_page_sizeType.msg_type_inline != TRUE) ||
	    (In0P->memory_object_page_sizeType.msg_type_longform != FALSE) ||
	    (In0P->memory_object_page_sizeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->memory_object_page_sizeType.msg_type_number != 1) ||
	    (In0P->memory_object_page_sizeType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	(void) memory_object_init(In0P->Head.msg_request_port, In0P->memory_control, In0P->memory_object_name, In0P->memory_object_page_size);
	OutP->RetCode = MIG_NO_REPLY;
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	;
}

/* SimpleRoutine memory_object_terminate */
mig_internal novalue _Xmemory_object_terminate
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t memory_controlType;
		memory_object_control_t memory_control;
		msg_type_t memory_object_nameType;
		memory_object_name_t memory_object_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t memory_object_terminate
#if	(defined(__STDC__) || defined(c_plusplus))
		(memory_object_t memory_object, memory_object_control_t memory_control, memory_object_name_t memory_object_name);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t memory_controlCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_ALL,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	TRUE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t memory_object_nameCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_ALL,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	TRUE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 40) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_controlType != * (int *) &memory_controlCheck)
#else	UseStaticMsgType
	if ((In0P->memory_controlType.msg_type_inline != TRUE) ||
	    (In0P->memory_controlType.msg_type_longform != FALSE) ||
	    (In0P->memory_controlType.msg_type_name != MSG_TYPE_PORT_ALL) ||
	    (In0P->memory_controlType.msg_type_number != 1) ||
	    (In0P->memory_controlType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_object_nameType != * (int *) &memory_object_nameCheck)
#else	UseStaticMsgType
	if ((In0P->memory_object_nameType.msg_type_inline != TRUE) ||
	    (In0P->memory_object_nameType.msg_type_longform != FALSE) ||
	    (In0P->memory_object_nameType.msg_type_name != MSG_TYPE_PORT_ALL) ||
	    (In0P->memory_object_nameType.msg_type_number != 1) ||
	    (In0P->memory_object_nameType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	(void) memory_object_terminate(In0P->Head.msg_request_port, In0P->memory_control, In0P->memory_object_name);
	OutP->RetCode = MIG_NO_REPLY;
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	;
}

/* SimpleRoutine memory_object_copy */
mig_internal novalue _Xmemory_object_copy
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t old_memory_controlType;
		memory_object_control_t old_memory_control;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t lengthType;
		vm_size_t length;
		msg_type_t new_memory_objectType;
		memory_object_t new_memory_object;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t memory_object_copy
#if	(defined(__STDC__) || defined(c_plusplus))
		(memory_object_t old_memory_object, memory_object_control_t old_memory_control, vm_offset_t offset, vm_size_t length, memory_object_t new_memory_object);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t old_memory_controlCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t offsetCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t lengthCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_memory_objectCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_ALL,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	TRUE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 56) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->old_memory_controlType != * (int *) &old_memory_controlCheck)
#else	UseStaticMsgType
	if ((In0P->old_memory_controlType.msg_type_inline != TRUE) ||
	    (In0P->old_memory_controlType.msg_type_longform != FALSE) ||
	    (In0P->old_memory_controlType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->old_memory_controlType.msg_type_number != 1) ||
	    (In0P->old_memory_controlType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->offsetType != * (int *) &offsetCheck)
#else	UseStaticMsgType
	if ((In0P->offsetType.msg_type_inline != TRUE) ||
	    (In0P->offsetType.msg_type_longform != FALSE) ||
	    (In0P->offsetType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->offsetType.msg_type_number != 1) ||
	    (In0P->offsetType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->lengthType != * (int *) &lengthCheck)
#else	UseStaticMsgType
	if ((In0P->lengthType.msg_type_inline != TRUE) ||
	    (In0P->lengthType.msg_type_longform != FALSE) ||
	    (In0P->lengthType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->lengthType.msg_type_number != 1) ||
	    (In0P->lengthType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->new_memory_objectType != * (int *) &new_memory_objectCheck)
#else	UseStaticMsgType
	if ((In0P->new_memory_objectType.msg_type_inline != TRUE) ||
	    (In0P->new_memory_objectType.msg_type_longform != FALSE) ||
	    (In0P->new_memory_objectType.msg_type_name != MSG_TYPE_PORT_ALL) ||
	    (In0P->new_memory_objectType.msg_type_number != 1) ||
	    (In0P->new_memory_objectType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	(void) memory_object_copy(In0P->Head.msg_request_port, In0P->old_memory_control, In0P->offset, In0P->length, In0P->new_memory_object);
	OutP->RetCode = MIG_NO_REPLY;
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	;
}

/* SimpleRoutine memory_object_data_request */
mig_internal novalue _Xmemory_object_data_request
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t memory_controlType;
		memory_object_control_t memory_control;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t lengthType;
		vm_size_t length;
		msg_type_t desired_accessType;
		vm_prot_t desired_access;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t memory_object_data_request
#if	(defined(__STDC__) || defined(c_plusplus))
		(memory_object_t memory_object, memory_object_control_t memory_control, vm_offset_t offset, vm_size_t length, vm_prot_t desired_access);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t memory_controlCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t offsetCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t lengthCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t desired_accessCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 56) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_controlType != * (int *) &memory_controlCheck)
#else	UseStaticMsgType
	if ((In0P->memory_controlType.msg_type_inline != TRUE) ||
	    (In0P->memory_controlType.msg_type_longform != FALSE) ||
	    (In0P->memory_controlType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->memory_controlType.msg_type_number != 1) ||
	    (In0P->memory_controlType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->offsetType != * (int *) &offsetCheck)
#else	UseStaticMsgType
	if ((In0P->offsetType.msg_type_inline != TRUE) ||
	    (In0P->offsetType.msg_type_longform != FALSE) ||
	    (In0P->offsetType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->offsetType.msg_type_number != 1) ||
	    (In0P->offsetType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->lengthType != * (int *) &lengthCheck)
#else	UseStaticMsgType
	if ((In0P->lengthType.msg_type_inline != TRUE) ||
	    (In0P->lengthType.msg_type_longform != FALSE) ||
	    (In0P->lengthType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->lengthType.msg_type_number != 1) ||
	    (In0P->lengthType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->desired_accessType != * (int *) &desired_accessCheck)
#else	UseStaticMsgType
	if ((In0P->desired_accessType.msg_type_inline != TRUE) ||
	    (In0P->desired_accessType.msg_type_longform != FALSE) ||
	    (In0P->desired_accessType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->desired_accessType.msg_type_number != 1) ||
	    (In0P->desired_accessType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	(void) memory_object_data_request(In0P->Head.msg_request_port, In0P->memory_control, In0P->offset, In0P->length, In0P->desired_access);
	OutP->RetCode = MIG_NO_REPLY;
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	;
}

/* SimpleRoutine memory_object_data_unlock */
mig_internal novalue _Xmemory_object_data_unlock
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t memory_controlType;
		memory_object_control_t memory_control;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t lengthType;
		vm_size_t length;
		msg_type_t desired_accessType;
		vm_prot_t desired_access;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t memory_object_data_unlock
#if	(defined(__STDC__) || defined(c_plusplus))
		(memory_object_t memory_object, memory_object_control_t memory_control, vm_offset_t offset, vm_size_t length, vm_prot_t desired_access);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t memory_controlCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t offsetCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t lengthCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t desired_accessCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 56) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_controlType != * (int *) &memory_controlCheck)
#else	UseStaticMsgType
	if ((In0P->memory_controlType.msg_type_inline != TRUE) ||
	    (In0P->memory_controlType.msg_type_longform != FALSE) ||
	    (In0P->memory_controlType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->memory_controlType.msg_type_number != 1) ||
	    (In0P->memory_controlType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->offsetType != * (int *) &offsetCheck)
#else	UseStaticMsgType
	if ((In0P->offsetType.msg_type_inline != TRUE) ||
	    (In0P->offsetType.msg_type_longform != FALSE) ||
	    (In0P->offsetType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->offsetType.msg_type_number != 1) ||
	    (In0P->offsetType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->lengthType != * (int *) &lengthCheck)
#else	UseStaticMsgType
	if ((In0P->lengthType.msg_type_inline != TRUE) ||
	    (In0P->lengthType.msg_type_longform != FALSE) ||
	    (In0P->lengthType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->lengthType.msg_type_number != 1) ||
	    (In0P->lengthType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->desired_accessType != * (int *) &desired_accessCheck)
#else	UseStaticMsgType
	if ((In0P->desired_accessType.msg_type_inline != TRUE) ||
	    (In0P->desired_accessType.msg_type_longform != FALSE) ||
	    (In0P->desired_accessType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->desired_accessType.msg_type_number != 1) ||
	    (In0P->desired_accessType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	(void) memory_object_data_unlock(In0P->Head.msg_request_port, In0P->memory_control, In0P->offset, In0P->length, In0P->desired_access);
	OutP->RetCode = MIG_NO_REPLY;
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	;
}

/* SimpleRoutine memory_object_data_write */
mig_internal novalue _Xmemory_object_data_write
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t memory_controlType;
		memory_object_control_t memory_control;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_long_t dataType;
		pointer_t data;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t memory_object_data_write
#if	(defined(__STDC__) || defined(c_plusplus))
		(memory_object_t memory_object, memory_object_control_t memory_control, vm_offset_t offset, pointer_t data, unsigned int dataCnt);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t memory_controlCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t offsetCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 56) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_controlType != * (int *) &memory_controlCheck)
#else	UseStaticMsgType
	if ((In0P->memory_controlType.msg_type_inline != TRUE) ||
	    (In0P->memory_controlType.msg_type_longform != FALSE) ||
	    (In0P->memory_controlType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->memory_controlType.msg_type_number != 1) ||
	    (In0P->memory_controlType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->offsetType != * (int *) &offsetCheck)
#else	UseStaticMsgType
	if ((In0P->offsetType.msg_type_inline != TRUE) ||
	    (In0P->offsetType.msg_type_longform != FALSE) ||
	    (In0P->offsetType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->offsetType.msg_type_number != 1) ||
	    (In0P->offsetType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
	if ((In0P->dataType.msg_type_header.msg_type_inline != FALSE) ||
	    (In0P->dataType.msg_type_header.msg_type_longform != TRUE) ||
	    (In0P->dataType.msg_type_long_name != MSG_TYPE_BYTE) ||
	    (In0P->dataType.msg_type_long_size != 8))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	(void) memory_object_data_write(In0P->Head.msg_request_port, In0P->memory_control, In0P->offset, In0P->data, In0P->dataType.msg_type_long_number);
	OutP->RetCode = MIG_NO_REPLY;
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	;
}

/* SimpleRoutine memory_object_lock_completed */
mig_internal novalue _Xmemory_object_lock_completed
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t memory_controlType;
		memory_object_control_t memory_control;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t lengthType;
		vm_size_t length;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	register Request *In0P = (Request *) InHeadP;
	register Reply *OutP = (Reply *) OutHeadP;
	extern kern_return_t memory_object_lock_completed
#if	(defined(__STDC__) || defined(c_plusplus))
		(memory_object_t memory_object, memory_object_control_t memory_control, vm_offset_t offset, vm_size_t length);
#else
		();
#endif

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size;

#if	UseStaticMsgType
	static msg_type_t memory_controlCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t offsetCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t lengthCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	TypeCheck
	msg_size = In0P->Head.msg_size;
	msg_simple = In0P->Head.msg_simple;
	if ((msg_size != 48) || (msg_simple != FALSE))
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; return; }
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->memory_controlType != * (int *) &memory_controlCheck)
#else	UseStaticMsgType
	if ((In0P->memory_controlType.msg_type_inline != TRUE) ||
	    (In0P->memory_controlType.msg_type_longform != FALSE) ||
	    (In0P->memory_controlType.msg_type_name != MSG_TYPE_PORT) ||
	    (In0P->memory_controlType.msg_type_number != 1) ||
	    (In0P->memory_controlType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->offsetType != * (int *) &offsetCheck)
#else	UseStaticMsgType
	if ((In0P->offsetType.msg_type_inline != TRUE) ||
	    (In0P->offsetType.msg_type_longform != FALSE) ||
	    (In0P->offsetType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->offsetType.msg_type_number != 1) ||
	    (In0P->offsetType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &In0P->lengthType != * (int *) &lengthCheck)
#else	UseStaticMsgType
	if ((In0P->lengthType.msg_type_inline != TRUE) ||
	    (In0P->lengthType.msg_type_longform != FALSE) ||
	    (In0P->lengthType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (In0P->lengthType.msg_type_number != 1) ||
	    (In0P->lengthType.msg_type_size != 32))
#endif	UseStaticMsgType
		{ OutP->RetCode = MIG_BAD_ARGUMENTS; goto punt0; }
#define	label_punt0
#endif	TypeCheck

	(void) memory_object_lock_completed(In0P->Head.msg_request_port, In0P->memory_control, In0P->offset, In0P->length);
	OutP->RetCode = MIG_NO_REPLY;
#ifdef	label_punt0
#undef	label_punt0
punt0:
#endif	label_punt0
	;
}

boolean_t memory_object_server
#if	(defined(__STDC__) || defined(c_plusplus))
	(msg_header_t *InHeadP, msg_header_t *OutHeadP)
#else
	(InHeadP, OutHeadP)
	msg_header_t *InHeadP, *OutHeadP;
#endif
{
	register msg_header_t *InP =  InHeadP;
	register death_pill_t *OutP = (death_pill_t *) OutHeadP;

#if	UseStaticMsgType
	static msg_type_t RetCodeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	OutP->Head.msg_simple = TRUE;
	OutP->Head.msg_size = sizeof *OutP;
	OutP->Head.msg_type = InP->msg_type;
	OutP->Head.msg_local_port = PORT_NULL;
	OutP->Head.msg_remote_port = InP->msg_reply_port;
	OutP->Head.msg_id = InP->msg_id + 100;

#if	UseStaticMsgType
	OutP->RetCodeType = RetCodeType;
#else	UseStaticMsgType
	OutP->RetCodeType.msg_type_name = MSG_TYPE_INTEGER_32;
	OutP->RetCodeType.msg_type_size = 32;
	OutP->RetCodeType.msg_type_number = 1;
	OutP->RetCodeType.msg_type_inline = TRUE;
	OutP->RetCodeType.msg_type_longform = FALSE;
	OutP->RetCodeType.msg_type_deallocate = FALSE;
	OutP->RetCodeType.msg_type_unused = 0;
#endif	UseStaticMsgType
	OutP->RetCode = MIG_BAD_ID;

	if ((InP->msg_id > 2206) || (InP->msg_id < 2200))
		return FALSE;
	else {
		typedef novalue (*SERVER_STUB_PROC)
#if	(defined(__STDC__) || defined(c_plusplus))
			(msg_header_t *, msg_header_t *);
#else
			();
#endif
		static SERVER_STUB_PROC routines[] = {
			_Xmemory_object_init,
			_Xmemory_object_terminate,
			_Xmemory_object_copy,
			_Xmemory_object_data_request,
			_Xmemory_object_data_unlock,
			_Xmemory_object_data_write,
			_Xmemory_object_lock_completed,
		};

		if (routines[InP->msg_id - 2200])
			(routines[InP->msg_id - 2200]) (InP, &OutP->Head);
		 else
			return FALSE;
	}
	return TRUE;
}
@EOF@

echo "libmach/mach_user.c"
cat >libmach/mach_user.c <<'@EOF@'
#include "mach_interface.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_mach
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine xxx_port_allocate */
mig_external kern_return_t xxx_port_allocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t *my_port
)
#else
	(target_task, my_port)
	task_t target_task;
	port_t *my_port;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t my_portType;
		port_t my_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t my_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2000;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2100)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->my_portType != * (int *) &my_portCheck)
#else	UseStaticMsgType
	if ((OutP->my_portType.msg_type_inline != TRUE) ||
	    (OutP->my_portType.msg_type_longform != FALSE) ||
	    (OutP->my_portType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->my_portType.msg_type_number != 1) ||
	    (OutP->my_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*my_port /* my_port */ = /* *my_port */ OutP->my_port;

	return OutP->RetCode;
}

/* Routine xxx_port_deallocate */
mig_external kern_return_t xxx_port_deallocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
)
#else
	(target_task, my_port)
	task_t target_task;
	port_t my_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t my_portType;
		port_t my_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t my_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->my_portType = my_portType;
#else	UseStaticMsgType
	InP->my_portType.msg_type_name = MSG_TYPE_PORT;
	InP->my_portType.msg_type_size = 32;
	InP->my_portType.msg_type_number = 1;
	InP->my_portType.msg_type_inline = TRUE;
	InP->my_portType.msg_type_longform = FALSE;
	InP->my_portType.msg_type_deallocate = FALSE;
	InP->my_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->my_port /* my_port */ = /* my_port */ my_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2001;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2101)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine xxx_port_enable */
mig_external kern_return_t xxx_port_enable
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
)
#else
	(target_task, my_port)
	task_t target_task;
	port_t my_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t my_portType;
		port_t my_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t my_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->my_portType = my_portType;
#else	UseStaticMsgType
	InP->my_portType.msg_type_name = MSG_TYPE_PORT;
	InP->my_portType.msg_type_size = 32;
	InP->my_portType.msg_type_number = 1;
	InP->my_portType.msg_type_inline = TRUE;
	InP->my_portType.msg_type_longform = FALSE;
	InP->my_portType.msg_type_deallocate = FALSE;
	InP->my_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->my_port /* my_port */ = /* my_port */ my_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2002;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2102)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine xxx_port_disable */
mig_external kern_return_t xxx_port_disable
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
)
#else
	(target_task, my_port)
	task_t target_task;
	port_t my_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t my_portType;
		port_t my_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t my_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->my_portType = my_portType;
#else	UseStaticMsgType
	InP->my_portType.msg_type_name = MSG_TYPE_PORT;
	InP->my_portType.msg_type_size = 32;
	InP->my_portType.msg_type_number = 1;
	InP->my_portType.msg_type_inline = TRUE;
	InP->my_portType.msg_type_longform = FALSE;
	InP->my_portType.msg_type_deallocate = FALSE;
	InP->my_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->my_port /* my_port */ = /* my_port */ my_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2003;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2103)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine xxx_port_select */
mig_external kern_return_t xxx_port_select
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t *port_list,
	unsigned int *port_listCnt
)
#else
	(target_task, port_list, port_listCnt)
	task_t target_task;
	port_array_t *port_list;
	unsigned int *port_listCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t port_listType;
		port_array_t port_list;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2004;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2104)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->port_listType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->port_listType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->port_listType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->port_listType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*port_list /* port_list */ = /* *port_list */ OutP->port_list;

	*port_listCnt /* port_listType.msg_type_long_number */ = /* *port_listCnt */ OutP->port_listType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine xxx_port_set_backlog */
mig_external kern_return_t xxx_port_set_backlog
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port,
	int backlog
)
#else
	(target_task, my_port, backlog)
	task_t target_task;
	port_t my_port;
	int backlog;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t my_portType;
		port_t my_port;
		msg_type_t backlogType;
		int backlog;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t my_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t backlogType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->my_portType = my_portType;
#else	UseStaticMsgType
	InP->my_portType.msg_type_name = MSG_TYPE_PORT;
	InP->my_portType.msg_type_size = 32;
	InP->my_portType.msg_type_number = 1;
	InP->my_portType.msg_type_inline = TRUE;
	InP->my_portType.msg_type_longform = FALSE;
	InP->my_portType.msg_type_deallocate = FALSE;
	InP->my_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->my_port /* my_port */ = /* my_port */ my_port;

#if	UseStaticMsgType
	InP->backlogType = backlogType;
#else	UseStaticMsgType
	InP->backlogType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->backlogType.msg_type_size = 32;
	InP->backlogType.msg_type_number = 1;
	InP->backlogType.msg_type_inline = TRUE;
	InP->backlogType.msg_type_longform = FALSE;
	InP->backlogType.msg_type_deallocate = FALSE;
	InP->backlogType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->backlog /* backlog */ = /* backlog */ backlog;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2005;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2105)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine xxx_port_status */
mig_external kern_return_t xxx_port_status
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port,
	boolean_t *enabled,
	int *num_msgs,
	int *backlog,
	boolean_t *ownership,
	boolean_t *receive_rights
)
#else
	(target_task, my_port, enabled, num_msgs, backlog, ownership, receive_rights)
	task_t target_task;
	port_t my_port;
	boolean_t *enabled;
	int *num_msgs;
	int *backlog;
	boolean_t *ownership;
	boolean_t *receive_rights;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t my_portType;
		port_t my_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t enabledType;
		boolean_t enabled;
		msg_type_t num_msgsType;
		int num_msgs;
		msg_type_t backlogType;
		int backlog;
		msg_type_t ownershipType;
		boolean_t ownership;
		msg_type_t receive_rightsType;
		boolean_t receive_rights;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t my_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t enabledCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t num_msgsCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t backlogCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t ownershipCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t receive_rightsCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->my_portType = my_portType;
#else	UseStaticMsgType
	InP->my_portType.msg_type_name = MSG_TYPE_PORT;
	InP->my_portType.msg_type_size = 32;
	InP->my_portType.msg_type_number = 1;
	InP->my_portType.msg_type_inline = TRUE;
	InP->my_portType.msg_type_longform = FALSE;
	InP->my_portType.msg_type_deallocate = FALSE;
	InP->my_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->my_port /* my_port */ = /* my_port */ my_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2006;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2106)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 72) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->enabledType != * (int *) &enabledCheck)
#else	UseStaticMsgType
	if ((OutP->enabledType.msg_type_inline != TRUE) ||
	    (OutP->enabledType.msg_type_longform != FALSE) ||
	    (OutP->enabledType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->enabledType.msg_type_number != 1) ||
	    (OutP->enabledType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*enabled /* enabled */ = /* *enabled */ OutP->enabled;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->num_msgsType != * (int *) &num_msgsCheck)
#else	UseStaticMsgType
	if ((OutP->num_msgsType.msg_type_inline != TRUE) ||
	    (OutP->num_msgsType.msg_type_longform != FALSE) ||
	    (OutP->num_msgsType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->num_msgsType.msg_type_number != 1) ||
	    (OutP->num_msgsType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*num_msgs /* num_msgs */ = /* *num_msgs */ OutP->num_msgs;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->backlogType != * (int *) &backlogCheck)
#else	UseStaticMsgType
	if ((OutP->backlogType.msg_type_inline != TRUE) ||
	    (OutP->backlogType.msg_type_longform != FALSE) ||
	    (OutP->backlogType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->backlogType.msg_type_number != 1) ||
	    (OutP->backlogType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*backlog /* backlog */ = /* *backlog */ OutP->backlog;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->ownershipType != * (int *) &ownershipCheck)
#else	UseStaticMsgType
	if ((OutP->ownershipType.msg_type_inline != TRUE) ||
	    (OutP->ownershipType.msg_type_longform != FALSE) ||
	    (OutP->ownershipType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->ownershipType.msg_type_number != 1) ||
	    (OutP->ownershipType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*ownership /* ownership */ = /* *ownership */ OutP->ownership;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->receive_rightsType != * (int *) &receive_rightsCheck)
#else	UseStaticMsgType
	if ((OutP->receive_rightsType.msg_type_inline != TRUE) ||
	    (OutP->receive_rightsType.msg_type_longform != FALSE) ||
	    (OutP->receive_rightsType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->receive_rightsType.msg_type_number != 1) ||
	    (OutP->receive_rightsType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*receive_rights /* receive_rights */ = /* *receive_rights */ OutP->receive_rights;

	return OutP->RetCode;
}

/* Routine task_create */
mig_external kern_return_t task_create
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	boolean_t inherit_memory,
	task_t *child_task
)
#else
	(target_task, inherit_memory, child_task)
	task_t target_task;
	boolean_t inherit_memory;
	task_t *child_task;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t inherit_memoryType;
		boolean_t inherit_memory;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t child_taskType;
		task_t child_task;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t inherit_memoryType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t child_taskCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->inherit_memoryType = inherit_memoryType;
#else	UseStaticMsgType
	InP->inherit_memoryType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->inherit_memoryType.msg_type_size = 32;
	InP->inherit_memoryType.msg_type_number = 1;
	InP->inherit_memoryType.msg_type_inline = TRUE;
	InP->inherit_memoryType.msg_type_longform = FALSE;
	InP->inherit_memoryType.msg_type_deallocate = FALSE;
	InP->inherit_memoryType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->inherit_memory /* inherit_memory */ = /* inherit_memory */ inherit_memory;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2007;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2107)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->child_taskType != * (int *) &child_taskCheck)
#else	UseStaticMsgType
	if ((OutP->child_taskType.msg_type_inline != TRUE) ||
	    (OutP->child_taskType.msg_type_longform != FALSE) ||
	    (OutP->child_taskType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->child_taskType.msg_type_number != 1) ||
	    (OutP->child_taskType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*child_task /* child_task */ = /* *child_task */ OutP->child_task;

	return OutP->RetCode;
}

/* Routine task_terminate */
mig_external kern_return_t task_terminate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
)
#else
	(target_task)
	task_t target_task;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2008;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2108)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_threads */
mig_external kern_return_t task_threads
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	thread_array_t *thread_list,
	unsigned int *thread_listCnt
)
#else
	(target_task, thread_list, thread_listCnt)
	task_t target_task;
	thread_array_t *thread_list;
	unsigned int *thread_listCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t thread_listType;
		thread_array_t thread_list;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2011;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2111)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->thread_listType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->thread_listType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->thread_listType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->thread_listType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*thread_list /* thread_list */ = /* *thread_list */ OutP->thread_list;

	*thread_listCnt /* thread_listType.msg_type_long_number */ = /* *thread_listCnt */ OutP->thread_listType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine thread_terminate */
mig_external kern_return_t thread_terminate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
)
#else
	(target_thread)
	thread_t target_thread;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2016;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2116)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine vm_allocate */
mig_external kern_return_t vm_allocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t size,
	boolean_t anywhere
)
#else
	(target_task, address, size, anywhere)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t size;
	boolean_t anywhere;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t anywhereType;
		boolean_t anywhere;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t addressType;
		vm_address_t address;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 48;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t anywhereType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t addressCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* *address */ = /* address */ *address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->anywhereType = anywhereType;
#else	UseStaticMsgType
	InP->anywhereType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->anywhereType.msg_type_size = 32;
	InP->anywhereType.msg_type_number = 1;
	InP->anywhereType.msg_type_inline = TRUE;
	InP->anywhereType.msg_type_longform = FALSE;
	InP->anywhereType.msg_type_deallocate = FALSE;
	InP->anywhereType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->anywhere /* anywhere */ = /* anywhere */ anywhere;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2021;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2121)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->addressType != * (int *) &addressCheck)
#else	UseStaticMsgType
	if ((OutP->addressType.msg_type_inline != TRUE) ||
	    (OutP->addressType.msg_type_longform != FALSE) ||
	    (OutP->addressType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->addressType.msg_type_number != 1) ||
	    (OutP->addressType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*address /* address */ = /* *address */ OutP->address;

	return OutP->RetCode;
}

/* Routine vm_deallocate */
mig_external kern_return_t vm_deallocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size
)
#else
	(target_task, address, size)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* address */ = /* address */ address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2023;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2123)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine vm_protect */
mig_external kern_return_t vm_protect
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	boolean_t set_maximum,
	vm_prot_t new_protection
)
#else
	(target_task, address, size, set_maximum, new_protection)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	boolean_t set_maximum;
	vm_prot_t new_protection;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t set_maximumType;
		boolean_t set_maximum;
		msg_type_t new_protectionType;
		vm_prot_t new_protection;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 56;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t set_maximumType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_protectionType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* address */ = /* address */ address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->set_maximumType = set_maximumType;
#else	UseStaticMsgType
	InP->set_maximumType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->set_maximumType.msg_type_size = 32;
	InP->set_maximumType.msg_type_number = 1;
	InP->set_maximumType.msg_type_inline = TRUE;
	InP->set_maximumType.msg_type_longform = FALSE;
	InP->set_maximumType.msg_type_deallocate = FALSE;
	InP->set_maximumType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->set_maximum /* set_maximum */ = /* set_maximum */ set_maximum;

#if	UseStaticMsgType
	InP->new_protectionType = new_protectionType;
#else	UseStaticMsgType
	InP->new_protectionType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->new_protectionType.msg_type_size = 32;
	InP->new_protectionType.msg_type_number = 1;
	InP->new_protectionType.msg_type_inline = TRUE;
	InP->new_protectionType.msg_type_longform = FALSE;
	InP->new_protectionType.msg_type_deallocate = FALSE;
	InP->new_protectionType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->new_protection /* new_protection */ = /* new_protection */ new_protection;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2024;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2124)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine vm_inherit */
mig_external kern_return_t vm_inherit
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	vm_inherit_t new_inheritance
)
#else
	(target_task, address, size, new_inheritance)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	vm_inherit_t new_inheritance;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t new_inheritanceType;
		vm_inherit_t new_inheritance;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 48;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_inheritanceType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* address */ = /* address */ address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->new_inheritanceType = new_inheritanceType;
#else	UseStaticMsgType
	InP->new_inheritanceType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->new_inheritanceType.msg_type_size = 32;
	InP->new_inheritanceType.msg_type_number = 1;
	InP->new_inheritanceType.msg_type_inline = TRUE;
	InP->new_inheritanceType.msg_type_longform = FALSE;
	InP->new_inheritanceType.msg_type_deallocate = FALSE;
	InP->new_inheritanceType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->new_inheritance /* new_inheritance */ = /* new_inheritance */ new_inheritance;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2025;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2125)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine vm_read */
mig_external kern_return_t vm_read
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	pointer_t *data,
	unsigned int *dataCnt
)
#else
	(target_task, address, size, data, dataCnt)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	pointer_t *data;
	unsigned int *dataCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t dataType;
		pointer_t data;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* address */ = /* address */ address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2026;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2126)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->dataType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->dataType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->dataType.msg_type_long_name != MSG_TYPE_BYTE) ||
	    (OutP->dataType.msg_type_long_size != 8))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*data /* data */ = /* *data */ OutP->data;

	*dataCnt /* dataType.msg_type_long_number */ = /* *dataCnt */ OutP->dataType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine vm_write */
mig_external kern_return_t vm_write
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	pointer_t data,
	unsigned int dataCnt
)
#else
	(target_task, address, data, dataCnt)
	vm_task_t target_task;
	vm_address_t address;
	pointer_t data;
	unsigned int dataCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_long_t dataType;
		pointer_t data;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 48;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t dataType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_BYTE,
		/* msg_type_long_size = */	8,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* address */ = /* address */ address;

#if	UseStaticMsgType
	InP->dataType = dataType;
#else	UseStaticMsgType
	InP->dataType.msg_type_long_name = MSG_TYPE_BYTE;
	InP->dataType.msg_type_long_size = 8;
	InP->dataType.msg_type_header.msg_type_inline = FALSE;
	InP->dataType.msg_type_header.msg_type_longform = TRUE;
	InP->dataType.msg_type_header.msg_type_deallocate = FALSE;
	InP->dataType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->data /* data */ = /* data */ data;

	InP->dataType.msg_type_long_number /* dataCnt */ = /* dataType.msg_type_long_number */ dataCnt;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2027;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2127)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine vm_copy */
mig_external kern_return_t vm_copy
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t source_address,
	vm_size_t size,
	vm_address_t dest_address
)
#else
	(target_task, source_address, size, dest_address)
	vm_task_t target_task;
	vm_address_t source_address;
	vm_size_t size;
	vm_address_t dest_address;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t source_addressType;
		vm_address_t source_address;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t dest_addressType;
		vm_address_t dest_address;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 48;

#if	UseStaticMsgType
	static msg_type_t source_addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t dest_addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->source_addressType = source_addressType;
#else	UseStaticMsgType
	InP->source_addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->source_addressType.msg_type_size = 32;
	InP->source_addressType.msg_type_number = 1;
	InP->source_addressType.msg_type_inline = TRUE;
	InP->source_addressType.msg_type_longform = FALSE;
	InP->source_addressType.msg_type_deallocate = FALSE;
	InP->source_addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->source_address /* source_address */ = /* source_address */ source_address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->dest_addressType = dest_addressType;
#else	UseStaticMsgType
	InP->dest_addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->dest_addressType.msg_type_size = 32;
	InP->dest_addressType.msg_type_number = 1;
	InP->dest_addressType.msg_type_inline = TRUE;
	InP->dest_addressType.msg_type_longform = FALSE;
	InP->dest_addressType.msg_type_deallocate = FALSE;
	InP->dest_addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->dest_address /* dest_address */ = /* dest_address */ dest_address;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2028;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2128)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine vm_region */
mig_external kern_return_t vm_region
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t *size,
	vm_prot_t *protection,
	vm_prot_t *max_protection,
	vm_inherit_t *inheritance,
	boolean_t *is_shared,
	memory_object_name_t *object_name,
	vm_offset_t *offset
)
#else
	(target_task, address, size, protection, max_protection, inheritance, is_shared, object_name, offset)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t *size;
	vm_prot_t *protection;
	vm_prot_t *max_protection;
	vm_inherit_t *inheritance;
	boolean_t *is_shared;
	memory_object_name_t *object_name;
	vm_offset_t *offset;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t protectionType;
		vm_prot_t protection;
		msg_type_t max_protectionType;
		vm_prot_t max_protection;
		msg_type_t inheritanceType;
		vm_inherit_t inheritance;
		msg_type_t is_sharedType;
		boolean_t is_shared;
		msg_type_t object_nameType;
		memory_object_name_t object_name;
		msg_type_t offsetType;
		vm_offset_t offset;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t addressCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t protectionCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t max_protectionCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t inheritanceCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t is_sharedCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t object_nameCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t offsetCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* *address */ = /* address */ *address;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2029;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2129)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 96) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->addressType != * (int *) &addressCheck)
#else	UseStaticMsgType
	if ((OutP->addressType.msg_type_inline != TRUE) ||
	    (OutP->addressType.msg_type_longform != FALSE) ||
	    (OutP->addressType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->addressType.msg_type_number != 1) ||
	    (OutP->addressType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*address /* address */ = /* *address */ OutP->address;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->sizeType != * (int *) &sizeCheck)
#else	UseStaticMsgType
	if ((OutP->sizeType.msg_type_inline != TRUE) ||
	    (OutP->sizeType.msg_type_longform != FALSE) ||
	    (OutP->sizeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->sizeType.msg_type_number != 1) ||
	    (OutP->sizeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*size /* size */ = /* *size */ OutP->size;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->protectionType != * (int *) &protectionCheck)
#else	UseStaticMsgType
	if ((OutP->protectionType.msg_type_inline != TRUE) ||
	    (OutP->protectionType.msg_type_longform != FALSE) ||
	    (OutP->protectionType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->protectionType.msg_type_number != 1) ||
	    (OutP->protectionType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*protection /* protection */ = /* *protection */ OutP->protection;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->max_protectionType != * (int *) &max_protectionCheck)
#else	UseStaticMsgType
	if ((OutP->max_protectionType.msg_type_inline != TRUE) ||
	    (OutP->max_protectionType.msg_type_longform != FALSE) ||
	    (OutP->max_protectionType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->max_protectionType.msg_type_number != 1) ||
	    (OutP->max_protectionType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*max_protection /* max_protection */ = /* *max_protection */ OutP->max_protection;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->inheritanceType != * (int *) &inheritanceCheck)
#else	UseStaticMsgType
	if ((OutP->inheritanceType.msg_type_inline != TRUE) ||
	    (OutP->inheritanceType.msg_type_longform != FALSE) ||
	    (OutP->inheritanceType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->inheritanceType.msg_type_number != 1) ||
	    (OutP->inheritanceType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*inheritance /* inheritance */ = /* *inheritance */ OutP->inheritance;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->is_sharedType != * (int *) &is_sharedCheck)
#else	UseStaticMsgType
	if ((OutP->is_sharedType.msg_type_inline != TRUE) ||
	    (OutP->is_sharedType.msg_type_longform != FALSE) ||
	    (OutP->is_sharedType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->is_sharedType.msg_type_number != 1) ||
	    (OutP->is_sharedType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*is_shared /* is_shared */ = /* *is_shared */ OutP->is_shared;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->object_nameType != * (int *) &object_nameCheck)
#else	UseStaticMsgType
	if ((OutP->object_nameType.msg_type_inline != TRUE) ||
	    (OutP->object_nameType.msg_type_longform != FALSE) ||
	    (OutP->object_nameType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->object_nameType.msg_type_number != 1) ||
	    (OutP->object_nameType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*object_name /* object_name */ = /* *object_name */ OutP->object_name;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->offsetType != * (int *) &offsetCheck)
#else	UseStaticMsgType
	if ((OutP->offsetType.msg_type_inline != TRUE) ||
	    (OutP->offsetType.msg_type_longform != FALSE) ||
	    (OutP->offsetType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->offsetType.msg_type_number != 1) ||
	    (OutP->offsetType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*offset /* offset */ = /* *offset */ OutP->offset;

	return OutP->RetCode;
}

/* Routine vm_statistics */
mig_external kern_return_t vm_statistics
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_statistics_data_t *vm_stats
)
#else
	(target_task, vm_stats)
	vm_task_t target_task;
	vm_statistics_data_t *vm_stats;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t vm_statsType;
		vm_statistics_data_t vm_stats;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t vm_statsCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		13,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2030;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2130)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 88) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->vm_statsType != * (int *) &vm_statsCheck)
#else	UseStaticMsgType
	if ((OutP->vm_statsType.msg_type_inline != TRUE) ||
	    (OutP->vm_statsType.msg_type_longform != FALSE) ||
	    (OutP->vm_statsType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->vm_statsType.msg_type_number != 13) ||
	    (OutP->vm_statsType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*vm_stats /* vm_stats */ = /* *vm_stats */ OutP->vm_stats;

	return OutP->RetCode;
}

/* Routine task_by_unix_pid */
mig_external kern_return_t task_by_unix_pid
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int process_id,
	task_t *result_task
)
#else
	(target_task, process_id, result_task)
	task_t target_task;
	int process_id;
	task_t *result_task;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t process_idType;
		int process_id;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t result_taskType;
		task_t result_task;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t process_idType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t result_taskCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->process_idType = process_idType;
#else	UseStaticMsgType
	InP->process_idType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->process_idType.msg_type_size = 32;
	InP->process_idType.msg_type_number = 1;
	InP->process_idType.msg_type_inline = TRUE;
	InP->process_idType.msg_type_longform = FALSE;
	InP->process_idType.msg_type_deallocate = FALSE;
	InP->process_idType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->process_id /* process_id */ = /* process_id */ process_id;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2031;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2131)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->result_taskType != * (int *) &result_taskCheck)
#else	UseStaticMsgType
	if ((OutP->result_taskType.msg_type_inline != TRUE) ||
	    (OutP->result_taskType.msg_type_longform != FALSE) ||
	    (OutP->result_taskType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->result_taskType.msg_type_number != 1) ||
	    (OutP->result_taskType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*result_task /* result_task */ = /* *result_task */ OutP->result_task;

	return OutP->RetCode;
}

/* Routine mach_ports_register */
mig_external kern_return_t mach_ports_register
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t init_port_set,
	unsigned int init_port_setCnt
)
#else
	(target_task, init_port_set, init_port_setCnt)
	task_t target_task;
	port_array_t init_port_set;
	unsigned int init_port_setCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t init_port_setType;
		port_array_t init_port_set;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_long_t init_port_setType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_PORT,
		/* msg_type_long_size = */	32,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->init_port_setType = init_port_setType;
#else	UseStaticMsgType
	InP->init_port_setType.msg_type_long_name = MSG_TYPE_PORT;
	InP->init_port_setType.msg_type_long_size = 32;
	InP->init_port_setType.msg_type_header.msg_type_inline = FALSE;
	InP->init_port_setType.msg_type_header.msg_type_longform = TRUE;
	InP->init_port_setType.msg_type_header.msg_type_deallocate = FALSE;
	InP->init_port_setType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->init_port_set /* init_port_set */ = /* init_port_set */ init_port_set;

	InP->init_port_setType.msg_type_long_number /* init_port_setCnt */ = /* init_port_setType.msg_type_long_number */ init_port_setCnt;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2033;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2133)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine mach_ports_lookup */
mig_external kern_return_t mach_ports_lookup
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t *init_port_set,
	unsigned int *init_port_setCnt
)
#else
	(target_task, init_port_set, init_port_setCnt)
	task_t target_task;
	port_array_t *init_port_set;
	unsigned int *init_port_setCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t init_port_setType;
		port_array_t init_port_set;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2034;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2134)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->init_port_setType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->init_port_setType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->init_port_setType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->init_port_setType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*init_port_set /* init_port_set */ = /* *init_port_set */ OutP->init_port_set;

	*init_port_setCnt /* init_port_setType.msg_type_long_number */ = /* *init_port_setCnt */ OutP->init_port_setType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine unix_pid */
mig_external kern_return_t unix_pid
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int *process_id
)
#else
	(target_task, process_id)
	task_t target_task;
	int *process_id;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t process_idType;
		int process_id;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t process_idCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2035;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2135)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->process_idType != * (int *) &process_idCheck)
#else	UseStaticMsgType
	if ((OutP->process_idType.msg_type_inline != TRUE) ||
	    (OutP->process_idType.msg_type_longform != FALSE) ||
	    (OutP->process_idType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->process_idType.msg_type_number != 1) ||
	    (OutP->process_idType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*process_id /* process_id */ = /* *process_id */ OutP->process_id;

	return OutP->RetCode;
}

/* Routine netipc_listen */
mig_external kern_return_t netipc_listen
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	int src_addr,
	int dst_addr,
	int src_port,
	int dst_port,
	int protocol,
	port_t ipc_port
)
#else
	(request_port, src_addr, dst_addr, src_port, dst_port, protocol, ipc_port)
	port_t request_port;
	int src_addr;
	int dst_addr;
	int src_port;
	int dst_port;
	int protocol;
	port_t ipc_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t src_addrType;
		int src_addr;
		msg_type_t dst_addrType;
		int dst_addr;
		msg_type_t src_portType;
		int src_port;
		msg_type_t dst_portType;
		int dst_port;
		msg_type_t protocolType;
		int protocol;
		msg_type_t ipc_portType;
		port_t ipc_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 72;

#if	UseStaticMsgType
	static msg_type_t src_addrType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t dst_addrType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t src_portType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t dst_portType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t protocolType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t ipc_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->src_addrType = src_addrType;
#else	UseStaticMsgType
	InP->src_addrType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->src_addrType.msg_type_size = 32;
	InP->src_addrType.msg_type_number = 1;
	InP->src_addrType.msg_type_inline = TRUE;
	InP->src_addrType.msg_type_longform = FALSE;
	InP->src_addrType.msg_type_deallocate = FALSE;
	InP->src_addrType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->src_addr /* src_addr */ = /* src_addr */ src_addr;

#if	UseStaticMsgType
	InP->dst_addrType = dst_addrType;
#else	UseStaticMsgType
	InP->dst_addrType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->dst_addrType.msg_type_size = 32;
	InP->dst_addrType.msg_type_number = 1;
	InP->dst_addrType.msg_type_inline = TRUE;
	InP->dst_addrType.msg_type_longform = FALSE;
	InP->dst_addrType.msg_type_deallocate = FALSE;
	InP->dst_addrType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->dst_addr /* dst_addr */ = /* dst_addr */ dst_addr;

#if	UseStaticMsgType
	InP->src_portType = src_portType;
#else	UseStaticMsgType
	InP->src_portType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->src_portType.msg_type_size = 32;
	InP->src_portType.msg_type_number = 1;
	InP->src_portType.msg_type_inline = TRUE;
	InP->src_portType.msg_type_longform = FALSE;
	InP->src_portType.msg_type_deallocate = FALSE;
	InP->src_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->src_port /* src_port */ = /* src_port */ src_port;

#if	UseStaticMsgType
	InP->dst_portType = dst_portType;
#else	UseStaticMsgType
	InP->dst_portType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->dst_portType.msg_type_size = 32;
	InP->dst_portType.msg_type_number = 1;
	InP->dst_portType.msg_type_inline = TRUE;
	InP->dst_portType.msg_type_longform = FALSE;
	InP->dst_portType.msg_type_deallocate = FALSE;
	InP->dst_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->dst_port /* dst_port */ = /* dst_port */ dst_port;

#if	UseStaticMsgType
	InP->protocolType = protocolType;
#else	UseStaticMsgType
	InP->protocolType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->protocolType.msg_type_size = 32;
	InP->protocolType.msg_type_number = 1;
	InP->protocolType.msg_type_inline = TRUE;
	InP->protocolType.msg_type_longform = FALSE;
	InP->protocolType.msg_type_deallocate = FALSE;
	InP->protocolType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->protocol /* protocol */ = /* protocol */ protocol;

#if	UseStaticMsgType
	InP->ipc_portType = ipc_portType;
#else	UseStaticMsgType
	InP->ipc_portType.msg_type_name = MSG_TYPE_PORT;
	InP->ipc_portType.msg_type_size = 32;
	InP->ipc_portType.msg_type_number = 1;
	InP->ipc_portType.msg_type_inline = TRUE;
	InP->ipc_portType.msg_type_longform = FALSE;
	InP->ipc_portType.msg_type_deallocate = FALSE;
	InP->ipc_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->ipc_port /* ipc_port */ = /* ipc_port */ ipc_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = request_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2036;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2136)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine netipc_ignore */
mig_external kern_return_t netipc_ignore
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	port_t ipc_port
)
#else
	(request_port, ipc_port)
	port_t request_port;
	port_t ipc_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t ipc_portType;
		port_t ipc_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t ipc_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->ipc_portType = ipc_portType;
#else	UseStaticMsgType
	InP->ipc_portType.msg_type_name = MSG_TYPE_PORT;
	InP->ipc_portType.msg_type_size = 32;
	InP->ipc_portType.msg_type_number = 1;
	InP->ipc_portType.msg_type_inline = TRUE;
	InP->ipc_portType.msg_type_longform = FALSE;
	InP->ipc_portType.msg_type_deallocate = FALSE;
	InP->ipc_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->ipc_port /* ipc_port */ = /* ipc_port */ ipc_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = request_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2037;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2137)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* SimpleRoutine memory_object_data_provided */
mig_external kern_return_t memory_object_data_provided
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	pointer_t data,
	unsigned int dataCnt,
	vm_prot_t lock_value
)
#else
	(memory_control, offset, data, dataCnt, lock_value)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	pointer_t data;
	unsigned int dataCnt;
	vm_prot_t lock_value;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_long_t dataType;
		pointer_t data;
		msg_type_t lock_valueType;
		vm_prot_t lock_value;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 56;

#if	UseStaticMsgType
	static msg_type_t offsetType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t dataType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_BYTE,
		/* msg_type_long_size = */	8,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t lock_valueType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->offsetType = offsetType;
#else	UseStaticMsgType
	InP->offsetType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->offsetType.msg_type_size = 32;
	InP->offsetType.msg_type_number = 1;
	InP->offsetType.msg_type_inline = TRUE;
	InP->offsetType.msg_type_longform = FALSE;
	InP->offsetType.msg_type_deallocate = FALSE;
	InP->offsetType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->offset /* offset */ = /* offset */ offset;

#if	UseStaticMsgType
	InP->dataType = dataType;
#else	UseStaticMsgType
	InP->dataType.msg_type_long_name = MSG_TYPE_BYTE;
	InP->dataType.msg_type_long_size = 8;
	InP->dataType.msg_type_header.msg_type_inline = FALSE;
	InP->dataType.msg_type_header.msg_type_longform = TRUE;
	InP->dataType.msg_type_header.msg_type_deallocate = FALSE;
	InP->dataType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->data /* data */ = /* data */ data;

	InP->dataType.msg_type_long_number /* dataCnt */ = /* dataType.msg_type_long_number */ dataCnt;

#if	UseStaticMsgType
	InP->lock_valueType = lock_valueType;
#else	UseStaticMsgType
	InP->lock_valueType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->lock_valueType.msg_type_size = 32;
	InP->lock_valueType.msg_type_number = 1;
	InP->lock_valueType.msg_type_inline = TRUE;
	InP->lock_valueType.msg_type_longform = FALSE;
	InP->lock_valueType.msg_type_deallocate = FALSE;
	InP->lock_valueType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->lock_value /* lock_value */ = /* lock_value */ lock_value;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2038;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* SimpleRoutine memory_object_data_unavailable */
mig_external kern_return_t memory_object_data_unavailable
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size
)
#else
	(memory_control, offset, size)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t sizeType;
		vm_size_t size;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t offsetType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->offsetType = offsetType;
#else	UseStaticMsgType
	InP->offsetType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->offsetType.msg_type_size = 32;
	InP->offsetType.msg_type_number = 1;
	InP->offsetType.msg_type_inline = TRUE;
	InP->offsetType.msg_type_longform = FALSE;
	InP->offsetType.msg_type_deallocate = FALSE;
	InP->offsetType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->offset /* offset */ = /* offset */ offset;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2039;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* Routine memory_object_get_attributes */
mig_external kern_return_t memory_object_get_attributes
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t *object_ready,
	boolean_t *may_cache,
	memory_object_copy_strategy_t *copy_strategy
)
#else
	(memory_control, object_ready, may_cache, copy_strategy)
	memory_object_control_t memory_control;
	boolean_t *object_ready;
	boolean_t *may_cache;
	memory_object_copy_strategy_t *copy_strategy;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t object_readyType;
		boolean_t object_ready;
		msg_type_t may_cacheType;
		boolean_t may_cache;
		msg_type_t copy_strategyType;
		memory_object_copy_strategy_t copy_strategy;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t object_readyCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t may_cacheCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t copy_strategyCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2040;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2140)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 56) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->object_readyType != * (int *) &object_readyCheck)
#else	UseStaticMsgType
	if ((OutP->object_readyType.msg_type_inline != TRUE) ||
	    (OutP->object_readyType.msg_type_longform != FALSE) ||
	    (OutP->object_readyType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->object_readyType.msg_type_number != 1) ||
	    (OutP->object_readyType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*object_ready /* object_ready */ = /* *object_ready */ OutP->object_ready;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->may_cacheType != * (int *) &may_cacheCheck)
#else	UseStaticMsgType
	if ((OutP->may_cacheType.msg_type_inline != TRUE) ||
	    (OutP->may_cacheType.msg_type_longform != FALSE) ||
	    (OutP->may_cacheType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->may_cacheType.msg_type_number != 1) ||
	    (OutP->may_cacheType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*may_cache /* may_cache */ = /* *may_cache */ OutP->may_cache;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->copy_strategyType != * (int *) &copy_strategyCheck)
#else	UseStaticMsgType
	if ((OutP->copy_strategyType.msg_type_inline != TRUE) ||
	    (OutP->copy_strategyType.msg_type_longform != FALSE) ||
	    (OutP->copy_strategyType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->copy_strategyType.msg_type_number != 1) ||
	    (OutP->copy_strategyType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*copy_strategy /* copy_strategy */ = /* *copy_strategy */ OutP->copy_strategy;

	return OutP->RetCode;
}

/* Routine vm_set_default_memory_manager */
mig_external kern_return_t vm_set_default_memory_manager
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host,
	memory_object_t *default_manager
)
#else
	(host, default_manager)
	host_priv_t host;
	memory_object_t *default_manager;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t default_managerType;
		memory_object_t default_manager;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t default_managerType;
		memory_object_t default_manager;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t default_managerType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t default_managerCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->default_managerType = default_managerType;
#else	UseStaticMsgType
	InP->default_managerType.msg_type_name = MSG_TYPE_PORT;
	InP->default_managerType.msg_type_size = 32;
	InP->default_managerType.msg_type_number = 1;
	InP->default_managerType.msg_type_inline = TRUE;
	InP->default_managerType.msg_type_longform = FALSE;
	InP->default_managerType.msg_type_deallocate = FALSE;
	InP->default_managerType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->default_manager /* *default_manager */ = /* default_manager */ *default_manager;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2041;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2141)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->default_managerType != * (int *) &default_managerCheck)
#else	UseStaticMsgType
	if ((OutP->default_managerType.msg_type_inline != TRUE) ||
	    (OutP->default_managerType.msg_type_longform != FALSE) ||
	    (OutP->default_managerType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->default_managerType.msg_type_number != 1) ||
	    (OutP->default_managerType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*default_manager /* default_manager */ = /* *default_manager */ OutP->default_manager;

	return OutP->RetCode;
}

/* SimpleRoutine memory_object_lock_request */
mig_external kern_return_t memory_object_lock_request
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size,
	boolean_t should_clean,
	boolean_t should_flush,
	vm_prot_t lock_value,
	port_t reply_to
)
#else
	(memory_control, offset, size, should_clean, should_flush, lock_value, reply_to)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
	boolean_t should_clean;
	boolean_t should_flush;
	vm_prot_t lock_value;
	port_t reply_to;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t should_cleanType;
		boolean_t should_clean;
		msg_type_t should_flushType;
		boolean_t should_flush;
		msg_type_t lock_valueType;
		vm_prot_t lock_value;
		msg_type_t reply_toType;
		port_t reply_to;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 72;

#if	UseStaticMsgType
	static msg_type_t offsetType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t should_cleanType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t should_flushType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t lock_valueType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t reply_toType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->offsetType = offsetType;
#else	UseStaticMsgType
	InP->offsetType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->offsetType.msg_type_size = 32;
	InP->offsetType.msg_type_number = 1;
	InP->offsetType.msg_type_inline = TRUE;
	InP->offsetType.msg_type_longform = FALSE;
	InP->offsetType.msg_type_deallocate = FALSE;
	InP->offsetType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->offset /* offset */ = /* offset */ offset;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->should_cleanType = should_cleanType;
#else	UseStaticMsgType
	InP->should_cleanType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->should_cleanType.msg_type_size = 32;
	InP->should_cleanType.msg_type_number = 1;
	InP->should_cleanType.msg_type_inline = TRUE;
	InP->should_cleanType.msg_type_longform = FALSE;
	InP->should_cleanType.msg_type_deallocate = FALSE;
	InP->should_cleanType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->should_clean /* should_clean */ = /* should_clean */ should_clean;

#if	UseStaticMsgType
	InP->should_flushType = should_flushType;
#else	UseStaticMsgType
	InP->should_flushType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->should_flushType.msg_type_size = 32;
	InP->should_flushType.msg_type_number = 1;
	InP->should_flushType.msg_type_inline = TRUE;
	InP->should_flushType.msg_type_longform = FALSE;
	InP->should_flushType.msg_type_deallocate = FALSE;
	InP->should_flushType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->should_flush /* should_flush */ = /* should_flush */ should_flush;

#if	UseStaticMsgType
	InP->lock_valueType = lock_valueType;
#else	UseStaticMsgType
	InP->lock_valueType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->lock_valueType.msg_type_size = 32;
	InP->lock_valueType.msg_type_number = 1;
	InP->lock_valueType.msg_type_inline = TRUE;
	InP->lock_valueType.msg_type_longform = FALSE;
	InP->lock_valueType.msg_type_deallocate = FALSE;
	InP->lock_valueType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->lock_value /* lock_value */ = /* lock_value */ lock_value;

#if	UseStaticMsgType
	InP->reply_toType = reply_toType;
#else	UseStaticMsgType
	InP->reply_toType.msg_type_name = MSG_TYPE_PORT;
	InP->reply_toType.msg_type_size = 32;
	InP->reply_toType.msg_type_number = 1;
	InP->reply_toType.msg_type_inline = TRUE;
	InP->reply_toType.msg_type_longform = FALSE;
	InP->reply_toType.msg_type_deallocate = FALSE;
	InP->reply_toType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->reply_to /* reply_to */ = /* reply_to */ reply_to;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2043;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* SimpleRoutine xxx_pager_cache */
mig_external kern_return_t xxx_pager_cache
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t should_cache
)
#else
	(memory_control, should_cache)
	memory_object_control_t memory_control;
	boolean_t should_cache;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t should_cacheType;
		boolean_t should_cache;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t should_cacheType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->should_cacheType = should_cacheType;
#else	UseStaticMsgType
	InP->should_cacheType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->should_cacheType.msg_type_size = 32;
	InP->should_cacheType.msg_type_number = 1;
	InP->should_cacheType.msg_type_inline = TRUE;
	InP->should_cacheType.msg_type_longform = FALSE;
	InP->should_cacheType.msg_type_deallocate = FALSE;
	InP->should_cacheType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->should_cache /* should_cache */ = /* should_cache */ should_cache;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2044;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* Routine xxx_host_info */
mig_external kern_return_t xxx_host_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t target_task,
	machine_info_data_t *info
)
#else
	(target_task, info)
	port_t target_task;
	machine_info_data_t *info;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t infoType;
		machine_info_data_t info;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t infoCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		5,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2047;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2147)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 56) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->infoType != * (int *) &infoCheck)
#else	UseStaticMsgType
	if ((OutP->infoType.msg_type_inline != TRUE) ||
	    (OutP->infoType.msg_type_longform != FALSE) ||
	    (OutP->infoType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->infoType.msg_type_number != 5) ||
	    (OutP->infoType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*info /* info */ = /* *info */ OutP->info;

	return OutP->RetCode;
}

/* Routine xxx_slot_info */
mig_external kern_return_t xxx_slot_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int slot,
	machine_slot_data_t *info
)
#else
	(target_task, slot, info)
	task_t target_task;
	int slot;
	machine_slot_data_t *info;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t slotType;
		int slot;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t infoType;
		machine_slot_data_t info;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t slotType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t infoCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		8,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->slotType = slotType;
#else	UseStaticMsgType
	InP->slotType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->slotType.msg_type_size = 32;
	InP->slotType.msg_type_number = 1;
	InP->slotType.msg_type_inline = TRUE;
	InP->slotType.msg_type_longform = FALSE;
	InP->slotType.msg_type_deallocate = FALSE;
	InP->slotType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->slot /* slot */ = /* slot */ slot;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2048;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2148)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 68) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->infoType != * (int *) &infoCheck)
#else	UseStaticMsgType
	if ((OutP->infoType.msg_type_inline != TRUE) ||
	    (OutP->infoType.msg_type_longform != FALSE) ||
	    (OutP->infoType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->infoType.msg_type_number != 8) ||
	    (OutP->infoType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*info /* info */ = /* *info */ OutP->info;

	return OutP->RetCode;
}

/* Routine xxx_cpu_control */
mig_external kern_return_t xxx_cpu_control
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int cpu,
	boolean_t running
)
#else
	(target_task, cpu, running)
	task_t target_task;
	int cpu;
	boolean_t running;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t cpuType;
		int cpu;
		msg_type_t runningType;
		boolean_t running;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t cpuType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t runningType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->cpuType = cpuType;
#else	UseStaticMsgType
	InP->cpuType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->cpuType.msg_type_size = 32;
	InP->cpuType.msg_type_number = 1;
	InP->cpuType.msg_type_inline = TRUE;
	InP->cpuType.msg_type_longform = FALSE;
	InP->cpuType.msg_type_deallocate = FALSE;
	InP->cpuType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->cpu /* cpu */ = /* cpu */ cpu;

#if	UseStaticMsgType
	InP->runningType = runningType;
#else	UseStaticMsgType
	InP->runningType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->runningType.msg_type_size = 32;
	InP->runningType.msg_type_number = 1;
	InP->runningType.msg_type_inline = TRUE;
	InP->runningType.msg_type_longform = FALSE;
	InP->runningType.msg_type_deallocate = FALSE;
	InP->runningType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->running /* running */ = /* running */ running;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2049;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2149)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine netport_init */
mig_external kern_return_t netport_init
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port
)
#else
	(request_port)
	port_t request_port;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = request_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2052;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2152)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine netport_enter */
mig_external kern_return_t netport_enter
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	network_port_t netport,
	port_t port,
	boolean_t local
)
#else
	(request_port, netport, port, local)
	port_t request_port;
	network_port_t netport;
	port_t port;
	boolean_t local;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t netportType;
		network_port_t netport;
		msg_type_t portType;
		port_t port;
		msg_type_t localType;
		boolean_t local;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 68;

#if	UseStaticMsgType
	static msg_type_t netportType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		6,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t localType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->netportType = netportType;
#else	UseStaticMsgType
	InP->netportType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->netportType.msg_type_size = 32;
	InP->netportType.msg_type_number = 6;
	InP->netportType.msg_type_inline = TRUE;
	InP->netportType.msg_type_longform = FALSE;
	InP->netportType.msg_type_deallocate = FALSE;
	InP->netportType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->netport /* netport */ = /* netport */ netport;

#if	UseStaticMsgType
	InP->portType = portType;
#else	UseStaticMsgType
	InP->portType.msg_type_name = MSG_TYPE_PORT;
	InP->portType.msg_type_size = 32;
	InP->portType.msg_type_number = 1;
	InP->portType.msg_type_inline = TRUE;
	InP->portType.msg_type_longform = FALSE;
	InP->portType.msg_type_deallocate = FALSE;
	InP->portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port /* port */ = /* port */ port;

#if	UseStaticMsgType
	InP->localType = localType;
#else	UseStaticMsgType
	InP->localType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->localType.msg_type_size = 32;
	InP->localType.msg_type_number = 1;
	InP->localType.msg_type_inline = TRUE;
	InP->localType.msg_type_longform = FALSE;
	InP->localType.msg_type_deallocate = FALSE;
	InP->localType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->local /* local */ = /* local */ local;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = request_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2053;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2153)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine netport_remove */
mig_external kern_return_t netport_remove
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	network_port_t netport
)
#else
	(request_port, netport)
	port_t request_port;
	network_port_t netport;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t netportType;
		network_port_t netport;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 52;

#if	UseStaticMsgType
	static msg_type_t netportType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		6,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->netportType = netportType;
#else	UseStaticMsgType
	InP->netportType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->netportType.msg_type_size = 32;
	InP->netportType.msg_type_number = 6;
	InP->netportType.msg_type_inline = TRUE;
	InP->netportType.msg_type_longform = FALSE;
	InP->netportType.msg_type_deallocate = FALSE;
	InP->netportType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->netport /* netport */ = /* netport */ netport;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = request_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2054;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2154)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_suspend */
mig_external kern_return_t task_suspend
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
)
#else
	(target_task)
	task_t target_task;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2056;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2156)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_resume */
mig_external kern_return_t task_resume
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
)
#else
	(target_task)
	task_t target_task;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2057;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2157)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_get_special_port */
mig_external kern_return_t task_get_special_port
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int which_port,
	port_t *special_port
)
#else
	(task, which_port, special_port)
	task_t task;
	int which_port;
	port_t *special_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t which_portType;
		int which_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t special_portType;
		port_t special_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t which_portType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t special_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->which_portType = which_portType;
#else	UseStaticMsgType
	InP->which_portType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->which_portType.msg_type_size = 32;
	InP->which_portType.msg_type_number = 1;
	InP->which_portType.msg_type_inline = TRUE;
	InP->which_portType.msg_type_longform = FALSE;
	InP->which_portType.msg_type_deallocate = FALSE;
	InP->which_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->which_port /* which_port */ = /* which_port */ which_port;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2058;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2158)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->special_portType != * (int *) &special_portCheck)
#else	UseStaticMsgType
	if ((OutP->special_portType.msg_type_inline != TRUE) ||
	    (OutP->special_portType.msg_type_longform != FALSE) ||
	    (OutP->special_portType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->special_portType.msg_type_number != 1) ||
	    (OutP->special_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*special_port /* special_port */ = /* *special_port */ OutP->special_port;

	return OutP->RetCode;
}

/* Routine task_set_special_port */
mig_external kern_return_t task_set_special_port
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int which_port,
	port_t special_port
)
#else
	(task, which_port, special_port)
	task_t task;
	int which_port;
	port_t special_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t which_portType;
		int which_port;
		msg_type_t special_portType;
		port_t special_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t which_portType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t special_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->which_portType = which_portType;
#else	UseStaticMsgType
	InP->which_portType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->which_portType.msg_type_size = 32;
	InP->which_portType.msg_type_number = 1;
	InP->which_portType.msg_type_inline = TRUE;
	InP->which_portType.msg_type_longform = FALSE;
	InP->which_portType.msg_type_deallocate = FALSE;
	InP->which_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->which_port /* which_port */ = /* which_port */ which_port;

#if	UseStaticMsgType
	InP->special_portType = special_portType;
#else	UseStaticMsgType
	InP->special_portType.msg_type_name = MSG_TYPE_PORT;
	InP->special_portType.msg_type_size = 32;
	InP->special_portType.msg_type_number = 1;
	InP->special_portType.msg_type_inline = TRUE;
	InP->special_portType.msg_type_longform = FALSE;
	InP->special_portType.msg_type_deallocate = FALSE;
	InP->special_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->special_port /* special_port */ = /* special_port */ special_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2059;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2159)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_info */
mig_external kern_return_t task_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int flavor,
	task_info_t task_info_out,
	unsigned int *task_info_outCnt
)
#else
	(target_task, flavor, task_info_out, task_info_outCnt)
	task_t target_task;
	int flavor;
	task_info_t task_info_out;
	unsigned int *task_info_outCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t flavorType;
		int flavor;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t task_info_outType;
		int task_info_out[1024];
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t flavorType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->flavorType = flavorType;
#else	UseStaticMsgType
	InP->flavorType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->flavorType.msg_type_size = 32;
	InP->flavorType.msg_type_number = 1;
	InP->flavorType.msg_type_inline = TRUE;
	InP->flavorType.msg_type_longform = FALSE;
	InP->flavorType.msg_type_deallocate = FALSE;
	InP->flavorType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->flavor /* flavor */ = /* flavor */ flavor;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2060;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2160)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size < 44) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->task_info_outType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->task_info_outType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->task_info_outType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->task_info_outType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
	msg_size_delta = (4 * OutP->task_info_outType.msg_type_long_number);
	if (msg_size != 44 + msg_size_delta)
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->task_info_outType.msg_type_long_number / 1 > *task_info_outCnt) {
		bcopy((char *) OutP->task_info_out, (char *) task_info_out, 4 * *task_info_outCnt);
		*task_info_outCnt /* task_info_outType.msg_type_long_number 1 */ = /* *task_info_outCnt */ OutP->task_info_outType.msg_type_long_number / 1;
		return MIG_ARRAY_TOO_LARGE;
	}
	bcopy((char *) OutP->task_info_out, (char *) task_info_out, 4 * OutP->task_info_outType.msg_type_long_number);

	*task_info_outCnt /* task_info_outType.msg_type_long_number */ = /* *task_info_outCnt */ OutP->task_info_outType.msg_type_long_number;

	OutP = &Mess.Out;
	return OutP->RetCode;
}

/* Routine thread_create */
mig_external kern_return_t thread_create
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t parent_task,
	thread_t *child_thread
)
#else
	(parent_task, child_thread)
	task_t parent_task;
	thread_t *child_thread;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t child_threadType;
		thread_t child_thread;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t child_threadCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = parent_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2061;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2161)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->child_threadType != * (int *) &child_threadCheck)
#else	UseStaticMsgType
	if ((OutP->child_threadType.msg_type_inline != TRUE) ||
	    (OutP->child_threadType.msg_type_longform != FALSE) ||
	    (OutP->child_threadType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->child_threadType.msg_type_number != 1) ||
	    (OutP->child_threadType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*child_thread /* child_thread */ = /* *child_thread */ OutP->child_thread;

	return OutP->RetCode;
}

/* Routine thread_suspend */
mig_external kern_return_t thread_suspend
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
)
#else
	(target_thread)
	thread_t target_thread;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2062;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2162)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_resume */
mig_external kern_return_t thread_resume
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
)
#else
	(target_thread)
	thread_t target_thread;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2063;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2163)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_abort */
mig_external kern_return_t thread_abort
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
)
#else
	(target_thread)
	thread_t target_thread;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2064;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2164)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_get_state */
mig_external kern_return_t thread_get_state
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_state_t old_state,
	unsigned int *old_stateCnt
)
#else
	(target_thread, flavor, old_state, old_stateCnt)
	thread_t target_thread;
	int flavor;
	thread_state_t old_state;
	unsigned int *old_stateCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t flavorType;
		int flavor;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t old_stateType;
		int old_state[1024];
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t flavorType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->flavorType = flavorType;
#else	UseStaticMsgType
	InP->flavorType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->flavorType.msg_type_size = 32;
	InP->flavorType.msg_type_number = 1;
	InP->flavorType.msg_type_inline = TRUE;
	InP->flavorType.msg_type_longform = FALSE;
	InP->flavorType.msg_type_deallocate = FALSE;
	InP->flavorType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->flavor /* flavor */ = /* flavor */ flavor;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2065;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2165)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size < 44) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->old_stateType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->old_stateType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->old_stateType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->old_stateType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
	msg_size_delta = (4 * OutP->old_stateType.msg_type_long_number);
	if (msg_size != 44 + msg_size_delta)
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->old_stateType.msg_type_long_number / 1 > *old_stateCnt) {
		bcopy((char *) OutP->old_state, (char *) old_state, 4 * *old_stateCnt);
		*old_stateCnt /* old_stateType.msg_type_long_number 1 */ = /* *old_stateCnt */ OutP->old_stateType.msg_type_long_number / 1;
		return MIG_ARRAY_TOO_LARGE;
	}
	bcopy((char *) OutP->old_state, (char *) old_state, 4 * OutP->old_stateType.msg_type_long_number);

	*old_stateCnt /* old_stateType.msg_type_long_number */ = /* *old_stateCnt */ OutP->old_stateType.msg_type_long_number;

	OutP = &Mess.Out;
	return OutP->RetCode;
}

/* Routine thread_set_state */
mig_external kern_return_t thread_set_state
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_state_t new_state,
	unsigned int new_stateCnt
)
#else
	(target_thread, flavor, new_state, new_stateCnt)
	thread_t target_thread;
	int flavor;
	thread_state_t new_state;
	unsigned int new_stateCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t flavorType;
		int flavor;
		msg_type_long_t new_stateType;
		int new_state[1024];
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 44;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t flavorType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t new_stateType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_INTEGER_32,
		/* msg_type_long_size = */	32,
		/* msg_type_long_number = */	1024
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->flavorType = flavorType;
#else	UseStaticMsgType
	InP->flavorType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->flavorType.msg_type_size = 32;
	InP->flavorType.msg_type_number = 1;
	InP->flavorType.msg_type_inline = TRUE;
	InP->flavorType.msg_type_longform = FALSE;
	InP->flavorType.msg_type_deallocate = FALSE;
	InP->flavorType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->flavor /* flavor */ = /* flavor */ flavor;

#if	UseStaticMsgType
	InP->new_stateType = new_stateType;
#else	UseStaticMsgType
	InP->new_stateType.msg_type_long_name = MSG_TYPE_INTEGER_32;
	InP->new_stateType.msg_type_long_size = 32;
	InP->new_stateType.msg_type_header.msg_type_inline = TRUE;
	InP->new_stateType.msg_type_header.msg_type_longform = TRUE;
	InP->new_stateType.msg_type_header.msg_type_deallocate = FALSE;
	InP->new_stateType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	if (new_stateCnt > 1024)
		return MIG_ARRAY_TOO_LARGE;
	bcopy((char *) new_state, (char *) InP->new_state, 4 * new_stateCnt);

	InP->new_stateType.msg_type_long_number /* new_stateCnt */ = /* new_stateType.msg_type_long_number */ new_stateCnt;

	msg_size_delta = (4 * new_stateCnt);
	msg_size += msg_size_delta;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2066;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2166)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_get_special_port */
mig_external kern_return_t thread_get_special_port
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int which_port,
	port_t *special_port
)
#else
	(thread, which_port, special_port)
	thread_t thread;
	int which_port;
	port_t *special_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t which_portType;
		int which_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t special_portType;
		port_t special_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t which_portType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t special_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->which_portType = which_portType;
#else	UseStaticMsgType
	InP->which_portType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->which_portType.msg_type_size = 32;
	InP->which_portType.msg_type_number = 1;
	InP->which_portType.msg_type_inline = TRUE;
	InP->which_portType.msg_type_longform = FALSE;
	InP->which_portType.msg_type_deallocate = FALSE;
	InP->which_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->which_port /* which_port */ = /* which_port */ which_port;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2067;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2167)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->special_portType != * (int *) &special_portCheck)
#else	UseStaticMsgType
	if ((OutP->special_portType.msg_type_inline != TRUE) ||
	    (OutP->special_portType.msg_type_longform != FALSE) ||
	    (OutP->special_portType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->special_portType.msg_type_number != 1) ||
	    (OutP->special_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*special_port /* special_port */ = /* *special_port */ OutP->special_port;

	return OutP->RetCode;
}

/* Routine thread_set_special_port */
mig_external kern_return_t thread_set_special_port
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int which_port,
	port_t special_port
)
#else
	(thread, which_port, special_port)
	thread_t thread;
	int which_port;
	port_t special_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t which_portType;
		int which_port;
		msg_type_t special_portType;
		port_t special_port;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t which_portType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t special_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->which_portType = which_portType;
#else	UseStaticMsgType
	InP->which_portType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->which_portType.msg_type_size = 32;
	InP->which_portType.msg_type_number = 1;
	InP->which_portType.msg_type_inline = TRUE;
	InP->which_portType.msg_type_longform = FALSE;
	InP->which_portType.msg_type_deallocate = FALSE;
	InP->which_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->which_port /* which_port */ = /* which_port */ which_port;

#if	UseStaticMsgType
	InP->special_portType = special_portType;
#else	UseStaticMsgType
	InP->special_portType.msg_type_name = MSG_TYPE_PORT;
	InP->special_portType.msg_type_size = 32;
	InP->special_portType.msg_type_number = 1;
	InP->special_portType.msg_type_inline = TRUE;
	InP->special_portType.msg_type_longform = FALSE;
	InP->special_portType.msg_type_deallocate = FALSE;
	InP->special_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->special_port /* special_port */ = /* special_port */ special_port;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2068;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2168)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_info */
mig_external kern_return_t thread_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_info_t thread_info_out,
	unsigned int *thread_info_outCnt
)
#else
	(target_thread, flavor, thread_info_out, thread_info_outCnt)
	thread_t target_thread;
	int flavor;
	thread_info_t thread_info_out;
	unsigned int *thread_info_outCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t flavorType;
		int flavor;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t thread_info_outType;
		int thread_info_out[1024];
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t flavorType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->flavorType = flavorType;
#else	UseStaticMsgType
	InP->flavorType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->flavorType.msg_type_size = 32;
	InP->flavorType.msg_type_number = 1;
	InP->flavorType.msg_type_inline = TRUE;
	InP->flavorType.msg_type_longform = FALSE;
	InP->flavorType.msg_type_deallocate = FALSE;
	InP->flavorType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->flavor /* flavor */ = /* flavor */ flavor;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2069;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2169)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size < 44) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->thread_info_outType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->thread_info_outType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->thread_info_outType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->thread_info_outType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
	msg_size_delta = (4 * OutP->thread_info_outType.msg_type_long_number);
	if (msg_size != 44 + msg_size_delta)
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->thread_info_outType.msg_type_long_number / 1 > *thread_info_outCnt) {
		bcopy((char *) OutP->thread_info_out, (char *) thread_info_out, 4 * *thread_info_outCnt);
		*thread_info_outCnt /* thread_info_outType.msg_type_long_number 1 */ = /* *thread_info_outCnt */ OutP->thread_info_outType.msg_type_long_number / 1;
		return MIG_ARRAY_TOO_LARGE;
	}
	bcopy((char *) OutP->thread_info_out, (char *) thread_info_out, 4 * OutP->thread_info_outType.msg_type_long_number);

	*thread_info_outCnt /* thread_info_outType.msg_type_long_number */ = /* *thread_info_outCnt */ OutP->thread_info_outType.msg_type_long_number;

	OutP = &Mess.Out;
	return OutP->RetCode;
}

/* Routine task_set_emulation */
mig_external kern_return_t task_set_emulation
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_port,
	vm_address_t routine_entry_pt,
	int routine_number
)
#else
	(target_port, routine_entry_pt, routine_number)
	task_t target_port;
	vm_address_t routine_entry_pt;
	int routine_number;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t routine_entry_ptType;
		vm_address_t routine_entry_pt;
		msg_type_t routine_numberType;
		int routine_number;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t routine_entry_ptType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t routine_numberType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->routine_entry_ptType = routine_entry_ptType;
#else	UseStaticMsgType
	InP->routine_entry_ptType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->routine_entry_ptType.msg_type_size = 32;
	InP->routine_entry_ptType.msg_type_number = 1;
	InP->routine_entry_ptType.msg_type_inline = TRUE;
	InP->routine_entry_ptType.msg_type_longform = FALSE;
	InP->routine_entry_ptType.msg_type_deallocate = FALSE;
	InP->routine_entry_ptType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->routine_entry_pt /* routine_entry_pt */ = /* routine_entry_pt */ routine_entry_pt;

#if	UseStaticMsgType
	InP->routine_numberType = routine_numberType;
#else	UseStaticMsgType
	InP->routine_numberType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->routine_numberType.msg_type_size = 32;
	InP->routine_numberType.msg_type_number = 1;
	InP->routine_numberType.msg_type_inline = TRUE;
	InP->routine_numberType.msg_type_longform = FALSE;
	InP->routine_numberType.msg_type_deallocate = FALSE;
	InP->routine_numberType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->routine_number /* routine_number */ = /* routine_number */ routine_number;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_port;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2070;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2170)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_names */
mig_external kern_return_t port_names
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_array_t *port_names_p,
	unsigned int *port_names_pCnt,
	port_type_array_t *port_types,
	unsigned int *port_typesCnt
)
#else
	(task, port_names_p, port_names_pCnt, port_types, port_typesCnt)
	task_t task;
	port_name_array_t *port_names_p;
	unsigned int *port_names_pCnt;
	port_type_array_t *port_types;
	unsigned int *port_typesCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t port_names_pType;
		port_name_array_t port_names_p;
		msg_type_long_t port_typesType;
		port_type_array_t port_types;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2073;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2173)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 64) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->port_names_pType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->port_names_pType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->port_names_pType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->port_names_pType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*port_names_p /* port_names_p */ = /* *port_names_p */ OutP->port_names_p;

	*port_names_pCnt /* port_names_pType.msg_type_long_number */ = /* *port_names_pCnt */ OutP->port_names_pType.msg_type_long_number;

#if	TypeCheck
	if ((OutP->port_typesType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->port_typesType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->port_typesType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->port_typesType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*port_types /* port_types */ = /* *port_types */ OutP->port_types;

	*port_typesCnt /* port_typesType.msg_type_long_number */ = /* *port_typesCnt */ OutP->port_typesType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine port_type */
mig_external kern_return_t port_type
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_type_t *port_type_p
)
#else
	(task, port_name, port_type_p)
	task_t task;
	port_name_t port_name;
	port_type_t *port_type_p;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t port_nameType;
		port_name_t port_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t port_type_pType;
		port_type_t port_type_p;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t port_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t port_type_pCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->port_nameType.msg_type_size = 32;
	InP->port_nameType.msg_type_number = 1;
	InP->port_nameType.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_longform = FALSE;
	InP->port_nameType.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_name /* port_name */ = /* port_name */ port_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2074;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2174)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->port_type_pType != * (int *) &port_type_pCheck)
#else	UseStaticMsgType
	if ((OutP->port_type_pType.msg_type_inline != TRUE) ||
	    (OutP->port_type_pType.msg_type_longform != FALSE) ||
	    (OutP->port_type_pType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->port_type_pType.msg_type_number != 1) ||
	    (OutP->port_type_pType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*port_type_p /* port_type_p */ = /* *port_type_p */ OutP->port_type_p;

	return OutP->RetCode;
}

/* Routine port_rename */
mig_external kern_return_t port_rename
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t old_name,
	port_name_t new_name
)
#else
	(task, old_name, new_name)
	task_t task;
	port_name_t old_name;
	port_name_t new_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t old_nameType;
		port_name_t old_name;
		msg_type_t new_nameType;
		port_name_t new_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t old_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->old_nameType = old_nameType;
#else	UseStaticMsgType
	InP->old_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->old_nameType.msg_type_size = 32;
	InP->old_nameType.msg_type_number = 1;
	InP->old_nameType.msg_type_inline = TRUE;
	InP->old_nameType.msg_type_longform = FALSE;
	InP->old_nameType.msg_type_deallocate = FALSE;
	InP->old_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->old_name /* old_name */ = /* old_name */ old_name;

#if	UseStaticMsgType
	InP->new_nameType = new_nameType;
#else	UseStaticMsgType
	InP->new_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->new_nameType.msg_type_size = 32;
	InP->new_nameType.msg_type_number = 1;
	InP->new_nameType.msg_type_inline = TRUE;
	InP->new_nameType.msg_type_longform = FALSE;
	InP->new_nameType.msg_type_deallocate = FALSE;
	InP->new_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->new_name /* new_name */ = /* new_name */ new_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2075;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2175)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_allocate */
mig_external kern_return_t port_allocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t *port_name
)
#else
	(task, port_name)
	task_t task;
	port_name_t *port_name;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t port_nameType;
		port_name_t port_name;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t port_nameCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2076;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2176)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->port_nameType != * (int *) &port_nameCheck)
#else	UseStaticMsgType
	if ((OutP->port_nameType.msg_type_inline != TRUE) ||
	    (OutP->port_nameType.msg_type_longform != FALSE) ||
	    (OutP->port_nameType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->port_nameType.msg_type_number != 1) ||
	    (OutP->port_nameType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*port_name /* port_name */ = /* *port_name */ OutP->port_name;

	return OutP->RetCode;
}

/* Routine port_deallocate */
mig_external kern_return_t port_deallocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name
)
#else
	(task, port_name)
	task_t task;
	port_name_t port_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t port_nameType;
		port_name_t port_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t port_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->port_nameType.msg_type_size = 32;
	InP->port_nameType.msg_type_number = 1;
	InP->port_nameType.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_longform = FALSE;
	InP->port_nameType.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_name /* port_name */ = /* port_name */ port_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2077;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2177)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_set_backlog */
mig_external kern_return_t port_set_backlog
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	int backlog
)
#else
	(task, port_name, backlog)
	task_t task;
	port_name_t port_name;
	int backlog;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t port_nameType;
		port_name_t port_name;
		msg_type_t backlogType;
		int backlog;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t port_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t backlogType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->port_nameType.msg_type_size = 32;
	InP->port_nameType.msg_type_number = 1;
	InP->port_nameType.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_longform = FALSE;
	InP->port_nameType.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_name /* port_name */ = /* port_name */ port_name;

#if	UseStaticMsgType
	InP->backlogType = backlogType;
#else	UseStaticMsgType
	InP->backlogType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->backlogType.msg_type_size = 32;
	InP->backlogType.msg_type_number = 1;
	InP->backlogType.msg_type_inline = TRUE;
	InP->backlogType.msg_type_longform = FALSE;
	InP->backlogType.msg_type_deallocate = FALSE;
	InP->backlogType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->backlog /* backlog */ = /* backlog */ backlog;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2078;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2178)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_status */
mig_external kern_return_t port_status
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_set_name_t *enabled,
	int *num_msgs,
	int *backlog,
	boolean_t *ownership,
	boolean_t *receive_rights
)
#else
	(task, port_name, enabled, num_msgs, backlog, ownership, receive_rights)
	task_t task;
	port_name_t port_name;
	port_set_name_t *enabled;
	int *num_msgs;
	int *backlog;
	boolean_t *ownership;
	boolean_t *receive_rights;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t port_nameType;
		port_name_t port_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t enabledType;
		port_set_name_t enabled;
		msg_type_t num_msgsType;
		int num_msgs;
		msg_type_t backlogType;
		int backlog;
		msg_type_t ownershipType;
		boolean_t ownership;
		msg_type_t receive_rightsType;
		boolean_t receive_rights;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t port_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t enabledCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t num_msgsCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t backlogCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t ownershipCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t receive_rightsCheck = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->port_nameType.msg_type_size = 32;
	InP->port_nameType.msg_type_number = 1;
	InP->port_nameType.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_longform = FALSE;
	InP->port_nameType.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_name /* port_name */ = /* port_name */ port_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2079;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2179)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 72) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->enabledType != * (int *) &enabledCheck)
#else	UseStaticMsgType
	if ((OutP->enabledType.msg_type_inline != TRUE) ||
	    (OutP->enabledType.msg_type_longform != FALSE) ||
	    (OutP->enabledType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->enabledType.msg_type_number != 1) ||
	    (OutP->enabledType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*enabled /* enabled */ = /* *enabled */ OutP->enabled;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->num_msgsType != * (int *) &num_msgsCheck)
#else	UseStaticMsgType
	if ((OutP->num_msgsType.msg_type_inline != TRUE) ||
	    (OutP->num_msgsType.msg_type_longform != FALSE) ||
	    (OutP->num_msgsType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->num_msgsType.msg_type_number != 1) ||
	    (OutP->num_msgsType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*num_msgs /* num_msgs */ = /* *num_msgs */ OutP->num_msgs;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->backlogType != * (int *) &backlogCheck)
#else	UseStaticMsgType
	if ((OutP->backlogType.msg_type_inline != TRUE) ||
	    (OutP->backlogType.msg_type_longform != FALSE) ||
	    (OutP->backlogType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->backlogType.msg_type_number != 1) ||
	    (OutP->backlogType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*backlog /* backlog */ = /* *backlog */ OutP->backlog;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->ownershipType != * (int *) &ownershipCheck)
#else	UseStaticMsgType
	if ((OutP->ownershipType.msg_type_inline != TRUE) ||
	    (OutP->ownershipType.msg_type_longform != FALSE) ||
	    (OutP->ownershipType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->ownershipType.msg_type_number != 1) ||
	    (OutP->ownershipType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*ownership /* ownership */ = /* *ownership */ OutP->ownership;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->receive_rightsType != * (int *) &receive_rightsCheck)
#else	UseStaticMsgType
	if ((OutP->receive_rightsType.msg_type_inline != TRUE) ||
	    (OutP->receive_rightsType.msg_type_longform != FALSE) ||
	    (OutP->receive_rightsType.msg_type_name != MSG_TYPE_BOOLEAN) ||
	    (OutP->receive_rightsType.msg_type_number != 1) ||
	    (OutP->receive_rightsType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*receive_rights /* receive_rights */ = /* *receive_rights */ OutP->receive_rights;

	return OutP->RetCode;
}

/* Routine port_set_allocate */
mig_external kern_return_t port_set_allocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t *set_name
)
#else
	(task, set_name)
	task_t task;
	port_set_name_t *set_name;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t set_nameType;
		port_set_name_t set_name;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t set_nameCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2080;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2180)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->set_nameType != * (int *) &set_nameCheck)
#else	UseStaticMsgType
	if ((OutP->set_nameType.msg_type_inline != TRUE) ||
	    (OutP->set_nameType.msg_type_longform != FALSE) ||
	    (OutP->set_nameType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->set_nameType.msg_type_number != 1) ||
	    (OutP->set_nameType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*set_name /* set_name */ = /* *set_name */ OutP->set_name;

	return OutP->RetCode;
}

/* Routine port_set_deallocate */
mig_external kern_return_t port_set_deallocate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name
)
#else
	(task, set_name)
	task_t task;
	port_set_name_t set_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t set_nameType;
		port_set_name_t set_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t set_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->set_nameType = set_nameType;
#else	UseStaticMsgType
	InP->set_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->set_nameType.msg_type_size = 32;
	InP->set_nameType.msg_type_number = 1;
	InP->set_nameType.msg_type_inline = TRUE;
	InP->set_nameType.msg_type_longform = FALSE;
	InP->set_nameType.msg_type_deallocate = FALSE;
	InP->set_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->set_name /* set_name */ = /* set_name */ set_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2081;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2181)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_set_add */
mig_external kern_return_t port_set_add
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name,
	port_name_t port_name
)
#else
	(task, set_name, port_name)
	task_t task;
	port_set_name_t set_name;
	port_name_t port_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t set_nameType;
		port_set_name_t set_name;
		msg_type_t port_nameType;
		port_name_t port_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t set_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t port_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->set_nameType = set_nameType;
#else	UseStaticMsgType
	InP->set_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->set_nameType.msg_type_size = 32;
	InP->set_nameType.msg_type_number = 1;
	InP->set_nameType.msg_type_inline = TRUE;
	InP->set_nameType.msg_type_longform = FALSE;
	InP->set_nameType.msg_type_deallocate = FALSE;
	InP->set_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->set_name /* set_name */ = /* set_name */ set_name;

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->port_nameType.msg_type_size = 32;
	InP->port_nameType.msg_type_number = 1;
	InP->port_nameType.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_longform = FALSE;
	InP->port_nameType.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_name /* port_name */ = /* port_name */ port_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2082;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2182)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_set_remove */
mig_external kern_return_t port_set_remove
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name
)
#else
	(task, port_name)
	task_t task;
	port_name_t port_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t port_nameType;
		port_name_t port_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t port_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->port_nameType.msg_type_size = 32;
	InP->port_nameType.msg_type_number = 1;
	InP->port_nameType.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_longform = FALSE;
	InP->port_nameType.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_name /* port_name */ = /* port_name */ port_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2083;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2183)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_set_status */
mig_external kern_return_t port_set_status
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name,
	port_name_array_t *members,
	unsigned int *membersCnt
)
#else
	(task, set_name, members, membersCnt)
	task_t task;
	port_set_name_t set_name;
	port_name_array_t *members;
	unsigned int *membersCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t set_nameType;
		port_set_name_t set_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t membersType;
		port_name_array_t members;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t set_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->set_nameType = set_nameType;
#else	UseStaticMsgType
	InP->set_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->set_nameType.msg_type_size = 32;
	InP->set_nameType.msg_type_number = 1;
	InP->set_nameType.msg_type_inline = TRUE;
	InP->set_nameType.msg_type_longform = FALSE;
	InP->set_nameType.msg_type_deallocate = FALSE;
	InP->set_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->set_name /* set_name */ = /* set_name */ set_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2084;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2184)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->membersType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->membersType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->membersType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->membersType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*members /* members */ = /* *members */ OutP->members;

	*membersCnt /* membersType.msg_type_long_number */ = /* *membersCnt */ OutP->membersType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine port_insert_send */
mig_external kern_return_t port_insert_send
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_t my_port,
	port_name_t his_name
)
#else
	(task, my_port, his_name)
	task_t task;
	port_t my_port;
	port_name_t his_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t my_portType;
		port_t my_port;
		msg_type_t his_nameType;
		port_name_t his_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t my_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t his_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->my_portType = my_portType;
#else	UseStaticMsgType
	InP->my_portType.msg_type_name = MSG_TYPE_PORT;
	InP->my_portType.msg_type_size = 32;
	InP->my_portType.msg_type_number = 1;
	InP->my_portType.msg_type_inline = TRUE;
	InP->my_portType.msg_type_longform = FALSE;
	InP->my_portType.msg_type_deallocate = FALSE;
	InP->my_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->my_port /* my_port */ = /* my_port */ my_port;

#if	UseStaticMsgType
	InP->his_nameType = his_nameType;
#else	UseStaticMsgType
	InP->his_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->his_nameType.msg_type_size = 32;
	InP->his_nameType.msg_type_number = 1;
	InP->his_nameType.msg_type_inline = TRUE;
	InP->his_nameType.msg_type_longform = FALSE;
	InP->his_nameType.msg_type_deallocate = FALSE;
	InP->his_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->his_name /* his_name */ = /* his_name */ his_name;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2085;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2185)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_extract_send */
mig_external kern_return_t port_extract_send
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t his_name,
	port_t *his_port
)
#else
	(task, his_name, his_port)
	task_t task;
	port_name_t his_name;
	port_t *his_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t his_nameType;
		port_name_t his_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t his_portType;
		port_t his_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t his_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t his_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->his_nameType = his_nameType;
#else	UseStaticMsgType
	InP->his_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->his_nameType.msg_type_size = 32;
	InP->his_nameType.msg_type_number = 1;
	InP->his_nameType.msg_type_inline = TRUE;
	InP->his_nameType.msg_type_longform = FALSE;
	InP->his_nameType.msg_type_deallocate = FALSE;
	InP->his_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->his_name /* his_name */ = /* his_name */ his_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2086;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2186)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->his_portType != * (int *) &his_portCheck)
#else	UseStaticMsgType
	if ((OutP->his_portType.msg_type_inline != TRUE) ||
	    (OutP->his_portType.msg_type_longform != FALSE) ||
	    (OutP->his_portType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->his_portType.msg_type_number != 1) ||
	    (OutP->his_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*his_port /* his_port */ = /* *his_port */ OutP->his_port;

	return OutP->RetCode;
}

/* Routine port_insert_receive */
mig_external kern_return_t port_insert_receive
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_t my_port,
	port_name_t his_name
)
#else
	(task, my_port, his_name)
	task_t task;
	port_t my_port;
	port_name_t his_name;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t my_portType;
		port_t my_port;
		msg_type_t his_nameType;
		port_name_t his_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t my_portType = {
		/* msg_type_name = */		MSG_TYPE_PORT_ALL,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t his_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->my_portType = my_portType;
#else	UseStaticMsgType
	InP->my_portType.msg_type_name = MSG_TYPE_PORT_ALL;
	InP->my_portType.msg_type_size = 32;
	InP->my_portType.msg_type_number = 1;
	InP->my_portType.msg_type_inline = TRUE;
	InP->my_portType.msg_type_longform = FALSE;
	InP->my_portType.msg_type_deallocate = FALSE;
	InP->my_portType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->my_port /* my_port */ = /* my_port */ my_port;

#if	UseStaticMsgType
	InP->his_nameType = his_nameType;
#else	UseStaticMsgType
	InP->his_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->his_nameType.msg_type_size = 32;
	InP->his_nameType.msg_type_number = 1;
	InP->his_nameType.msg_type_inline = TRUE;
	InP->his_nameType.msg_type_longform = FALSE;
	InP->his_nameType.msg_type_deallocate = FALSE;
	InP->his_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->his_name /* his_name */ = /* his_name */ his_name;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2087;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2187)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine port_extract_receive */
mig_external kern_return_t port_extract_receive
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t his_name,
	port_t *his_port
)
#else
	(task, his_name, his_port)
	task_t task;
	port_name_t his_name;
	port_t *his_port;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t his_nameType;
		port_name_t his_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t his_portType;
		port_t his_port;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t his_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t his_portCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT_ALL,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->his_nameType = his_nameType;
#else	UseStaticMsgType
	InP->his_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->his_nameType.msg_type_size = 32;
	InP->his_nameType.msg_type_number = 1;
	InP->his_nameType.msg_type_inline = TRUE;
	InP->his_nameType.msg_type_longform = FALSE;
	InP->his_nameType.msg_type_deallocate = FALSE;
	InP->his_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->his_name /* his_name */ = /* his_name */ his_name;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2088;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2188)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->his_portType != * (int *) &his_portCheck)
#else	UseStaticMsgType
	if ((OutP->his_portType.msg_type_inline != TRUE) ||
	    (OutP->his_portType.msg_type_longform != FALSE) ||
	    (OutP->his_portType.msg_type_name != MSG_TYPE_PORT_ALL) ||
	    (OutP->his_portType.msg_type_number != 1) ||
	    (OutP->his_portType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*his_port /* his_port */ = /* *his_port */ OutP->his_port;

	return OutP->RetCode;
}

/* Routine vm_map */
mig_external kern_return_t vm_map
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t size,
	vm_address_t mask,
	boolean_t anywhere,
	memory_object_t memory_object,
	vm_offset_t offset,
	boolean_t copy,
	vm_prot_t cur_protection,
	vm_prot_t max_protection,
	vm_inherit_t inheritance
)
#else
	(target_task, address, size, mask, anywhere, memory_object, offset, copy, cur_protection, max_protection, inheritance)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t size;
	vm_address_t mask;
	boolean_t anywhere;
	memory_object_t memory_object;
	vm_offset_t offset;
	boolean_t copy;
	vm_prot_t cur_protection;
	vm_prot_t max_protection;
	vm_inherit_t inheritance;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t maskType;
		vm_address_t mask;
		msg_type_t anywhereType;
		boolean_t anywhere;
		msg_type_t memory_objectType;
		memory_object_t memory_object;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t copyType;
		boolean_t copy;
		msg_type_t cur_protectionType;
		vm_prot_t cur_protection;
		msg_type_t max_protectionType;
		vm_prot_t max_protection;
		msg_type_t inheritanceType;
		vm_inherit_t inheritance;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t addressType;
		vm_address_t address;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 104;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t maskType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t anywhereType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t memory_objectType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t offsetType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t copyType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t cur_protectionType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t max_protectionType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t inheritanceType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t addressCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* *address */ = /* address */ *address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->maskType = maskType;
#else	UseStaticMsgType
	InP->maskType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->maskType.msg_type_size = 32;
	InP->maskType.msg_type_number = 1;
	InP->maskType.msg_type_inline = TRUE;
	InP->maskType.msg_type_longform = FALSE;
	InP->maskType.msg_type_deallocate = FALSE;
	InP->maskType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->mask /* mask */ = /* mask */ mask;

#if	UseStaticMsgType
	InP->anywhereType = anywhereType;
#else	UseStaticMsgType
	InP->anywhereType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->anywhereType.msg_type_size = 32;
	InP->anywhereType.msg_type_number = 1;
	InP->anywhereType.msg_type_inline = TRUE;
	InP->anywhereType.msg_type_longform = FALSE;
	InP->anywhereType.msg_type_deallocate = FALSE;
	InP->anywhereType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->anywhere /* anywhere */ = /* anywhere */ anywhere;

#if	UseStaticMsgType
	InP->memory_objectType = memory_objectType;
#else	UseStaticMsgType
	InP->memory_objectType.msg_type_name = MSG_TYPE_PORT;
	InP->memory_objectType.msg_type_size = 32;
	InP->memory_objectType.msg_type_number = 1;
	InP->memory_objectType.msg_type_inline = TRUE;
	InP->memory_objectType.msg_type_longform = FALSE;
	InP->memory_objectType.msg_type_deallocate = FALSE;
	InP->memory_objectType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->memory_object /* memory_object */ = /* memory_object */ memory_object;

#if	UseStaticMsgType
	InP->offsetType = offsetType;
#else	UseStaticMsgType
	InP->offsetType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->offsetType.msg_type_size = 32;
	InP->offsetType.msg_type_number = 1;
	InP->offsetType.msg_type_inline = TRUE;
	InP->offsetType.msg_type_longform = FALSE;
	InP->offsetType.msg_type_deallocate = FALSE;
	InP->offsetType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->offset /* offset */ = /* offset */ offset;

#if	UseStaticMsgType
	InP->copyType = copyType;
#else	UseStaticMsgType
	InP->copyType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->copyType.msg_type_size = 32;
	InP->copyType.msg_type_number = 1;
	InP->copyType.msg_type_inline = TRUE;
	InP->copyType.msg_type_longform = FALSE;
	InP->copyType.msg_type_deallocate = FALSE;
	InP->copyType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->copy /* copy */ = /* copy */ copy;

#if	UseStaticMsgType
	InP->cur_protectionType = cur_protectionType;
#else	UseStaticMsgType
	InP->cur_protectionType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->cur_protectionType.msg_type_size = 32;
	InP->cur_protectionType.msg_type_number = 1;
	InP->cur_protectionType.msg_type_inline = TRUE;
	InP->cur_protectionType.msg_type_longform = FALSE;
	InP->cur_protectionType.msg_type_deallocate = FALSE;
	InP->cur_protectionType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->cur_protection /* cur_protection */ = /* cur_protection */ cur_protection;

#if	UseStaticMsgType
	InP->max_protectionType = max_protectionType;
#else	UseStaticMsgType
	InP->max_protectionType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->max_protectionType.msg_type_size = 32;
	InP->max_protectionType.msg_type_number = 1;
	InP->max_protectionType.msg_type_inline = TRUE;
	InP->max_protectionType.msg_type_longform = FALSE;
	InP->max_protectionType.msg_type_deallocate = FALSE;
	InP->max_protectionType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->max_protection /* max_protection */ = /* max_protection */ max_protection;

#if	UseStaticMsgType
	InP->inheritanceType = inheritanceType;
#else	UseStaticMsgType
	InP->inheritanceType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->inheritanceType.msg_type_size = 32;
	InP->inheritanceType.msg_type_number = 1;
	InP->inheritanceType.msg_type_inline = TRUE;
	InP->inheritanceType.msg_type_longform = FALSE;
	InP->inheritanceType.msg_type_deallocate = FALSE;
	InP->inheritanceType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->inheritance /* inheritance */ = /* inheritance */ inheritance;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2089;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2189)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->addressType != * (int *) &addressCheck)
#else	UseStaticMsgType
	if ((OutP->addressType.msg_type_inline != TRUE) ||
	    (OutP->addressType.msg_type_longform != FALSE) ||
	    (OutP->addressType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->addressType.msg_type_number != 1) ||
	    (OutP->addressType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*address /* address */ = /* *address */ OutP->address;

	return OutP->RetCode;
}

/* SimpleRoutine memory_object_data_error */
mig_external kern_return_t memory_object_data_error
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size,
	kern_return_t error_value
)
#else
	(memory_control, offset, size, error_value)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
	kern_return_t error_value;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t error_valueType;
		kern_return_t error_value;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 48;

#if	UseStaticMsgType
	static msg_type_t offsetType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t error_valueType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->offsetType = offsetType;
#else	UseStaticMsgType
	InP->offsetType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->offsetType.msg_type_size = 32;
	InP->offsetType.msg_type_number = 1;
	InP->offsetType.msg_type_inline = TRUE;
	InP->offsetType.msg_type_longform = FALSE;
	InP->offsetType.msg_type_deallocate = FALSE;
	InP->offsetType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->offset /* offset */ = /* offset */ offset;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->error_valueType = error_valueType;
#else	UseStaticMsgType
	InP->error_valueType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->error_valueType.msg_type_size = 32;
	InP->error_valueType.msg_type_number = 1;
	InP->error_valueType.msg_type_inline = TRUE;
	InP->error_valueType.msg_type_longform = FALSE;
	InP->error_valueType.msg_type_deallocate = FALSE;
	InP->error_valueType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->error_value /* error_value */ = /* error_value */ error_value;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2090;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* SimpleRoutine memory_object_set_attributes */
mig_external kern_return_t memory_object_set_attributes
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t object_ready,
	boolean_t may_cache,
	memory_object_copy_strategy_t copy_strategy
)
#else
	(memory_control, object_ready, may_cache, copy_strategy)
	memory_object_control_t memory_control;
	boolean_t object_ready;
	boolean_t may_cache;
	memory_object_copy_strategy_t copy_strategy;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t object_readyType;
		boolean_t object_ready;
		msg_type_t may_cacheType;
		boolean_t may_cache;
		msg_type_t copy_strategyType;
		memory_object_copy_strategy_t copy_strategy;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 48;

#if	UseStaticMsgType
	static msg_type_t object_readyType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t may_cacheType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t copy_strategyType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->object_readyType = object_readyType;
#else	UseStaticMsgType
	InP->object_readyType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->object_readyType.msg_type_size = 32;
	InP->object_readyType.msg_type_number = 1;
	InP->object_readyType.msg_type_inline = TRUE;
	InP->object_readyType.msg_type_longform = FALSE;
	InP->object_readyType.msg_type_deallocate = FALSE;
	InP->object_readyType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->object_ready /* object_ready */ = /* object_ready */ object_ready;

#if	UseStaticMsgType
	InP->may_cacheType = may_cacheType;
#else	UseStaticMsgType
	InP->may_cacheType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->may_cacheType.msg_type_size = 32;
	InP->may_cacheType.msg_type_number = 1;
	InP->may_cacheType.msg_type_inline = TRUE;
	InP->may_cacheType.msg_type_longform = FALSE;
	InP->may_cacheType.msg_type_deallocate = FALSE;
	InP->may_cacheType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->may_cache /* may_cache */ = /* may_cache */ may_cache;

#if	UseStaticMsgType
	InP->copy_strategyType = copy_strategyType;
#else	UseStaticMsgType
	InP->copy_strategyType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->copy_strategyType.msg_type_size = 32;
	InP->copy_strategyType.msg_type_number = 1;
	InP->copy_strategyType.msg_type_inline = TRUE;
	InP->copy_strategyType.msg_type_longform = FALSE;
	InP->copy_strategyType.msg_type_deallocate = FALSE;
	InP->copy_strategyType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->copy_strategy /* copy_strategy */ = /* copy_strategy */ copy_strategy;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2091;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* SimpleRoutine memory_object_destroy */
mig_external kern_return_t memory_object_destroy
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	kern_return_t reason
)
#else
	(memory_control, reason)
	memory_object_control_t memory_control;
	kern_return_t reason;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t reasonType;
		kern_return_t reason;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t reasonType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->reasonType = reasonType;
#else	UseStaticMsgType
	InP->reasonType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->reasonType.msg_type_size = 32;
	InP->reasonType.msg_type_number = 1;
	InP->reasonType.msg_type_inline = TRUE;
	InP->reasonType.msg_type_longform = FALSE;
	InP->reasonType.msg_type_deallocate = FALSE;
	InP->reasonType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->reason /* reason */ = /* reason */ reason;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2092;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* SimpleRoutine memory_object_data_supply */
mig_external kern_return_t memory_object_data_supply
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	pointer_t data,
	unsigned int dataCnt,
	boolean_t dealloc_data,
	vm_prot_t lock_value,
	boolean_t precious,
	port_t reply_to
)
#else
	(memory_control, offset, data, dataCnt, dealloc_data, lock_value, precious, reply_to)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	pointer_t data;
	unsigned int dataCnt;
	boolean_t dealloc_data;
	vm_prot_t lock_value;
	boolean_t precious;
	port_t reply_to;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t offsetType;
		vm_offset_t offset;
		msg_type_long_t dataType;
		pointer_t data;
		msg_type_t dealloc_dataType;
		boolean_t dealloc_data;
		msg_type_t lock_valueType;
		vm_prot_t lock_value;
		msg_type_t preciousType;
		boolean_t precious;
		msg_type_t reply_toType;
		port_t reply_to;
	} Request;

	union {
		Request In;
	} Mess;

	register Request *InP = &Mess.In;

	unsigned int msg_size = 80;

#if	UseStaticMsgType
	static msg_type_t offsetType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_long_t dataType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		FALSE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	TRUE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_BYTE,
		/* msg_type_long_size = */	8,
		/* msg_type_long_number = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t dealloc_dataType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t lock_valueType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t preciousType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t reply_toType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->offsetType = offsetType;
#else	UseStaticMsgType
	InP->offsetType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->offsetType.msg_type_size = 32;
	InP->offsetType.msg_type_number = 1;
	InP->offsetType.msg_type_inline = TRUE;
	InP->offsetType.msg_type_longform = FALSE;
	InP->offsetType.msg_type_deallocate = FALSE;
	InP->offsetType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->offset /* offset */ = /* offset */ offset;

#if	UseStaticMsgType
	InP->dataType = dataType;
#else	UseStaticMsgType
	InP->dataType.msg_type_long_name = MSG_TYPE_BYTE;
	InP->dataType.msg_type_long_size = 8;
	InP->dataType.msg_type_header.msg_type_inline = FALSE;
	InP->dataType.msg_type_header.msg_type_longform = TRUE;
	InP->dataType.msg_type_header.msg_type_deallocate = TRUE;
	InP->dataType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->data /* data */ = /* data */ data;

	InP->dataType.msg_type_long_number /* dataCnt */ = /* dataType.msg_type_long_number */ dataCnt;

#if	UseStaticMsgType
	InP->dealloc_dataType = dealloc_dataType;
#else	UseStaticMsgType
	InP->dealloc_dataType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->dealloc_dataType.msg_type_size = 32;
	InP->dealloc_dataType.msg_type_number = 1;
	InP->dealloc_dataType.msg_type_inline = TRUE;
	InP->dealloc_dataType.msg_type_longform = FALSE;
	InP->dealloc_dataType.msg_type_deallocate = FALSE;
	InP->dealloc_dataType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->dealloc_data /* dealloc_data */ = /* dealloc_data */ dealloc_data;

#if	UseStaticMsgType
	InP->lock_valueType = lock_valueType;
#else	UseStaticMsgType
	InP->lock_valueType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->lock_valueType.msg_type_size = 32;
	InP->lock_valueType.msg_type_number = 1;
	InP->lock_valueType.msg_type_inline = TRUE;
	InP->lock_valueType.msg_type_longform = FALSE;
	InP->lock_valueType.msg_type_deallocate = FALSE;
	InP->lock_valueType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->lock_value /* lock_value */ = /* lock_value */ lock_value;

#if	UseStaticMsgType
	InP->preciousType = preciousType;
#else	UseStaticMsgType
	InP->preciousType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->preciousType.msg_type_size = 32;
	InP->preciousType.msg_type_number = 1;
	InP->preciousType.msg_type_inline = TRUE;
	InP->preciousType.msg_type_longform = FALSE;
	InP->preciousType.msg_type_deallocate = FALSE;
	InP->preciousType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->precious /* precious */ = /* precious */ precious;

#if	UseStaticMsgType
	InP->reply_toType = reply_toType;
#else	UseStaticMsgType
	InP->reply_toType.msg_type_name = MSG_TYPE_PORT;
	InP->reply_toType.msg_type_size = 32;
	InP->reply_toType.msg_type_number = 1;
	InP->reply_toType.msg_type_inline = TRUE;
	InP->reply_toType.msg_type_longform = FALSE;
	InP->reply_toType.msg_type_deallocate = FALSE;
	InP->reply_toType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->reply_to /* reply_to */ = /* reply_to */ reply_to;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL;
	InP->Head.msg_request_port = memory_control;
	InP->Head.msg_reply_port = PORT_NULL;
	InP->Head.msg_id = 2093;

	return msg_send(&InP->Head, MSG_OPTION_NONE, 0);
}

/* Routine port_set_backup */
mig_external kern_return_t port_set_backup
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_t backup,
	port_t *previous
)
#else
	(task, port_name, backup, previous)
	task_t task;
	port_name_t port_name;
	port_t backup;
	port_t *previous;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t port_nameType;
		port_name_t port_name;
		msg_type_t backupType;
		port_t backup;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t previousType;
		port_t previous;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t port_nameType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t backupType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t previousCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->port_nameType = port_nameType;
#else	UseStaticMsgType
	InP->port_nameType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->port_nameType.msg_type_size = 32;
	InP->port_nameType.msg_type_number = 1;
	InP->port_nameType.msg_type_inline = TRUE;
	InP->port_nameType.msg_type_longform = FALSE;
	InP->port_nameType.msg_type_deallocate = FALSE;
	InP->port_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->port_name /* port_name */ = /* port_name */ port_name;

#if	UseStaticMsgType
	InP->backupType = backupType;
#else	UseStaticMsgType
	InP->backupType.msg_type_name = MSG_TYPE_PORT;
	InP->backupType.msg_type_size = 32;
	InP->backupType.msg_type_number = 1;
	InP->backupType.msg_type_inline = TRUE;
	InP->backupType.msg_type_longform = FALSE;
	InP->backupType.msg_type_deallocate = FALSE;
	InP->backupType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->backup /* backup */ = /* backup */ backup;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2098;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2198)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->previousType != * (int *) &previousCheck)
#else	UseStaticMsgType
	if ((OutP->previousType.msg_type_inline != TRUE) ||
	    (OutP->previousType.msg_type_longform != FALSE) ||
	    (OutP->previousType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->previousType.msg_type_number != 1) ||
	    (OutP->previousType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*previous /* previous */ = /* *previous */ OutP->previous;

	return OutP->RetCode;
}

/* Routine vm_machine_attribute */
mig_external kern_return_t vm_machine_attribute
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	vm_machine_attribute_t attribute,
	vm_machine_attribute_val_t *value
)
#else
	(target_task, address, size, attribute, value)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	vm_machine_attribute_t attribute;
	vm_machine_attribute_val_t *value;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t addressType;
		vm_address_t address;
		msg_type_t sizeType;
		vm_size_t size;
		msg_type_t attributeType;
		vm_machine_attribute_t attribute;
		msg_type_t valueType;
		vm_machine_attribute_val_t value;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t valueType;
		vm_machine_attribute_val_t value;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 56;

#if	UseStaticMsgType
	static msg_type_t addressType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t attributeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t valueType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t valueCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->addressType = addressType;
#else	UseStaticMsgType
	InP->addressType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->addressType.msg_type_size = 32;
	InP->addressType.msg_type_number = 1;
	InP->addressType.msg_type_inline = TRUE;
	InP->addressType.msg_type_longform = FALSE;
	InP->addressType.msg_type_deallocate = FALSE;
	InP->addressType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->address /* address */ = /* address */ address;

#if	UseStaticMsgType
	InP->sizeType = sizeType;
#else	UseStaticMsgType
	InP->sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->sizeType.msg_type_size = 32;
	InP->sizeType.msg_type_number = 1;
	InP->sizeType.msg_type_inline = TRUE;
	InP->sizeType.msg_type_longform = FALSE;
	InP->sizeType.msg_type_deallocate = FALSE;
	InP->sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->size /* size */ = /* size */ size;

#if	UseStaticMsgType
	InP->attributeType = attributeType;
#else	UseStaticMsgType
	InP->attributeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->attributeType.msg_type_size = 32;
	InP->attributeType.msg_type_number = 1;
	InP->attributeType.msg_type_inline = TRUE;
	InP->attributeType.msg_type_longform = FALSE;
	InP->attributeType.msg_type_deallocate = FALSE;
	InP->attributeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->attribute /* attribute */ = /* attribute */ attribute;

#if	UseStaticMsgType
	InP->valueType = valueType;
#else	UseStaticMsgType
	InP->valueType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->valueType.msg_type_size = 32;
	InP->valueType.msg_type_number = 1;
	InP->valueType.msg_type_inline = TRUE;
	InP->valueType.msg_type_longform = FALSE;
	InP->valueType.msg_type_deallocate = FALSE;
	InP->valueType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->value /* *value */ = /* value */ *value;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = target_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2099;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2199)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->valueType != * (int *) &valueCheck)
#else	UseStaticMsgType
	if ((OutP->valueType.msg_type_inline != TRUE) ||
	    (OutP->valueType.msg_type_longform != FALSE) ||
	    (OutP->valueType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->valueType.msg_type_number != 1) ||
	    (OutP->valueType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*value /* value */ = /* *value */ OutP->value;

	return OutP->RetCode;
}
@EOF@

echo "libmach/mach_debugUser.c"
cat >libmach/mach_debugUser.c <<'@EOF@'
#include "mach_debug_interface.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_mach_debug
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine host_ipc_statistics */
mig_external kern_return_t host_ipc_statistics
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	ipc_statistics_t *statistics
)
#else
	(task, statistics)
	task_t task;
	ipc_statistics_t *statistics;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t statisticsType;
		ipc_statistics_t statistics;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t statisticsCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		15,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 3000;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 3100)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 96) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->statisticsType != * (int *) &statisticsCheck)
#else	UseStaticMsgType
	if ((OutP->statisticsType.msg_type_inline != TRUE) ||
	    (OutP->statisticsType.msg_type_longform != FALSE) ||
	    (OutP->statisticsType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->statisticsType.msg_type_number != 15) ||
	    (OutP->statisticsType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*statistics /* statistics */ = /* *statistics */ OutP->statistics;

	return OutP->RetCode;
}

/* Routine host_ipc_statistics_reset */
mig_external kern_return_t host_ipc_statistics_reset
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task
)
#else
	(task)
	task_t task;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 3001;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 3101)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine host_callout_info */
mig_external kern_return_t host_callout_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	callout_info_array_t *info,
	unsigned int *infoCnt
)
#else
	(task, info, infoCnt)
	task_t task;
	callout_info_array_t *info;
	unsigned int *infoCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t infoType;
		callout_info_array_t info;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 3002;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 3102)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->infoType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->infoType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->infoType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->infoType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*info /* info */ = /* *info */ OutP->info;

	*infoCnt /* infoType.msg_type_long_number 3 */ = /* *infoCnt */ OutP->infoType.msg_type_long_number / 3;

	return OutP->RetCode;
}

/* Routine host_callout_statistics */
mig_external kern_return_t host_callout_statistics
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	callout_statistics_t *statistics
)
#else
	(task, statistics)
	task_t task;
	callout_statistics_t *statistics;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t statisticsType;
		callout_statistics_t statistics;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t statisticsCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		10,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 3003;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 3103)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 76) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->statisticsType != * (int *) &statisticsCheck)
#else	UseStaticMsgType
	if ((OutP->statisticsType.msg_type_inline != TRUE) ||
	    (OutP->statisticsType.msg_type_longform != FALSE) ||
	    (OutP->statisticsType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->statisticsType.msg_type_number != 10) ||
	    (OutP->statisticsType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*statistics /* statistics */ = /* *statistics */ OutP->statistics;

	return OutP->RetCode;
}

/* Routine host_callout_statistics_reset */
mig_external kern_return_t host_callout_statistics_reset
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task
)
#else
	(task)
	task_t task;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 3004;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 3104)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine host_zone_info */
mig_external kern_return_t host_zone_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	zone_name_array_t *names,
	unsigned int *namesCnt,
	zone_info_array_t *info,
	unsigned int *infoCnt
)
#else
	(task, names, namesCnt, info, infoCnt)
	task_t task;
	zone_name_array_t *names;
	unsigned int *namesCnt;
	zone_info_array_t *info;
	unsigned int *infoCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t namesType;
		zone_name_array_t names;
		msg_type_long_t infoType;
		zone_info_array_t info;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 3005;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 3105)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 64) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->namesType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->namesType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->namesType.msg_type_long_name != MSG_TYPE_CHAR) ||
	    (OutP->namesType.msg_type_long_size != 8))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*names /* names */ = /* *names */ OutP->names;

	*namesCnt /* namesType.msg_type_long_number 80 */ = /* *namesCnt */ OutP->namesType.msg_type_long_number / 80;

#if	TypeCheck
	if ((OutP->infoType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->infoType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->infoType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->infoType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*info /* info */ = /* *info */ OutP->info;

	*infoCnt /* infoType.msg_type_long_number 8 */ = /* *infoCnt */ OutP->infoType.msg_type_long_number / 8;

	return OutP->RetCode;
}

/* Routine host_ipc_bucket_info */
mig_external kern_return_t host_ipc_bucket_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	ipc_bucket_info_array_t *TLinfo,
	unsigned int *TLinfoCnt,
	ipc_bucket_info_array_t *TPinfo,
	unsigned int *TPinfoCnt
)
#else
	(task, TLinfo, TLinfoCnt, TPinfo, TPinfoCnt)
	task_t task;
	ipc_bucket_info_array_t *TLinfo;
	unsigned int *TLinfoCnt;
	ipc_bucket_info_array_t *TPinfo;
	unsigned int *TPinfoCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t TLinfoType;
		ipc_bucket_info_array_t TLinfo;
		msg_type_long_t TPinfoType;
		ipc_bucket_info_array_t TPinfo;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 3006;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 3106)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 64) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->TLinfoType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->TLinfoType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->TLinfoType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->TLinfoType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*TLinfo /* TLinfo */ = /* *TLinfo */ OutP->TLinfo;

	*TLinfoCnt /* TLinfoType.msg_type_long_number */ = /* *TLinfoCnt */ OutP->TLinfoType.msg_type_long_number;

#if	TypeCheck
	if ((OutP->TPinfoType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->TPinfoType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->TPinfoType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->TPinfoType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*TPinfo /* TPinfo */ = /* *TPinfo */ OutP->TPinfo;

	*TPinfoCnt /* TPinfoType.msg_type_long_number */ = /* *TPinfoCnt */ OutP->TPinfoType.msg_type_long_number;

	return OutP->RetCode;
}
@EOF@

echo "libmach/monitorUser.c"
cat >libmach/monitorUser.c <<'@EOF@'
#include "monitor.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_monitor
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine monitor_create */
mig_external kern_return_t monitor_create
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t this_task,
	monitor_t *new_monitor,
	int *requested_size
)
#else
	(this_task, new_monitor, requested_size)
	task_t this_task;
	monitor_t *new_monitor;
	int *requested_size;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t requested_sizeType;
		int requested_size;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t new_monitorType;
		monitor_t new_monitor;
		msg_type_t requested_sizeType;
		int requested_size;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t requested_sizeType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_monitorCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t requested_sizeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->requested_sizeType = requested_sizeType;
#else	UseStaticMsgType
	InP->requested_sizeType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->requested_sizeType.msg_type_size = 32;
	InP->requested_sizeType.msg_type_number = 1;
	InP->requested_sizeType.msg_type_inline = TRUE;
	InP->requested_sizeType.msg_type_longform = FALSE;
	InP->requested_sizeType.msg_type_deallocate = FALSE;
	InP->requested_sizeType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->requested_size /* *requested_size */ = /* requested_size */ *requested_size;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = this_task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2800;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2900)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->new_monitorType != * (int *) &new_monitorCheck)
#else	UseStaticMsgType
	if ((OutP->new_monitorType.msg_type_inline != TRUE) ||
	    (OutP->new_monitorType.msg_type_longform != FALSE) ||
	    (OutP->new_monitorType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->new_monitorType.msg_type_number != 1) ||
	    (OutP->new_monitorType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*new_monitor /* new_monitor */ = /* *new_monitor */ OutP->new_monitor;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->requested_sizeType != * (int *) &requested_sizeCheck)
#else	UseStaticMsgType
	if ((OutP->requested_sizeType.msg_type_inline != TRUE) ||
	    (OutP->requested_sizeType.msg_type_longform != FALSE) ||
	    (OutP->requested_sizeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->requested_sizeType.msg_type_number != 1) ||
	    (OutP->requested_sizeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*requested_size /* requested_size */ = /* *requested_size */ OutP->requested_size;

	return OutP->RetCode;
}

/* Routine monitor_terminate */
mig_external kern_return_t monitor_terminate
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor
)
#else
	(this_monitor)
	monitor_t this_monitor;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = this_monitor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2801;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2901)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine monitor_resume */
mig_external kern_return_t monitor_resume
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor
)
#else
	(this_monitor)
	monitor_t this_monitor;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = this_monitor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2802;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2902)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine monitor_suspend */
mig_external kern_return_t monitor_suspend
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor
)
#else
	(this_monitor)
	monitor_t this_monitor;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = this_monitor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2803;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2903)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_monitor */
mig_external kern_return_t thread_monitor
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor,
	int monitor_id,
	thread_t this_thread
)
#else
	(this_monitor, monitor_id, this_thread)
	monitor_t this_monitor;
	int monitor_id;
	thread_t this_thread;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t monitor_idType;
		int monitor_id;
		msg_type_t this_threadType;
		thread_t this_thread;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t monitor_idType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t this_threadType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->monitor_idType = monitor_idType;
#else	UseStaticMsgType
	InP->monitor_idType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->monitor_idType.msg_type_size = 32;
	InP->monitor_idType.msg_type_number = 1;
	InP->monitor_idType.msg_type_inline = TRUE;
	InP->monitor_idType.msg_type_longform = FALSE;
	InP->monitor_idType.msg_type_deallocate = FALSE;
	InP->monitor_idType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->monitor_id /* monitor_id */ = /* monitor_id */ monitor_id;

#if	UseStaticMsgType
	InP->this_threadType = this_threadType;
#else	UseStaticMsgType
	InP->this_threadType.msg_type_name = MSG_TYPE_PORT;
	InP->this_threadType.msg_type_size = 32;
	InP->this_threadType.msg_type_number = 1;
	InP->this_threadType.msg_type_inline = TRUE;
	InP->this_threadType.msg_type_longform = FALSE;
	InP->this_threadType.msg_type_deallocate = FALSE;
	InP->this_threadType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->this_thread /* this_thread */ = /* this_thread */ this_thread;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = this_monitor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2804;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2904)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_unmonitor */
mig_external kern_return_t thread_unmonitor
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor,
	thread_t this_thread
)
#else
	(this_monitor, this_thread)
	monitor_t this_monitor;
	thread_t this_thread;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t this_threadType;
		thread_t this_thread;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t this_threadType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->this_threadType = this_threadType;
#else	UseStaticMsgType
	InP->this_threadType.msg_type_name = MSG_TYPE_PORT;
	InP->this_threadType.msg_type_size = 32;
	InP->this_threadType.msg_type_number = 1;
	InP->this_threadType.msg_type_inline = TRUE;
	InP->this_threadType.msg_type_longform = FALSE;
	InP->this_threadType.msg_type_deallocate = FALSE;
	InP->this_threadType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->this_thread /* this_thread */ = /* this_thread */ this_thread;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = this_monitor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2805;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2905)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine monitor_read */
mig_external kern_return_t monitor_read
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor,
	kern_mon_buffer_t buffer,
	unsigned int *bufferCnt
)
#else
	(this_monitor, buffer, bufferCnt)
	monitor_t this_monitor;
	kern_mon_buffer_t buffer;
	unsigned int *bufferCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t bufferType;
		kern_mon_data_t buffer[320];
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = this_monitor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2806;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2906)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size < 44) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->bufferType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->bufferType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->bufferType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->bufferType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
	msg_size_delta = (4 * OutP->bufferType.msg_type_long_number);
	if (msg_size != 44 + msg_size_delta)
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->bufferType.msg_type_long_number / 6 > *bufferCnt) {
		bcopy((char *) OutP->buffer, (char *) buffer, 24 * *bufferCnt);
		*bufferCnt /* bufferType.msg_type_long_number 6 */ = /* *bufferCnt */ OutP->bufferType.msg_type_long_number / 6;
		return MIG_ARRAY_TOO_LARGE;
	}
	bcopy((char *) OutP->buffer, (char *) buffer, 4 * OutP->bufferType.msg_type_long_number);

	*bufferCnt /* bufferType.msg_type_long_number 6 */ = /* *bufferCnt */ OutP->bufferType.msg_type_long_number / 6;

	OutP = &Mess.Out;
	return OutP->RetCode;
}
@EOF@

echo "libmach/mach_hostUser.c"
cat >libmach/mach_hostUser.c <<'@EOF@'
#include "mach_host.h"
#include <:mach:message.h>
#include <:mach:mach_types.h>
#include <:mach:mig_errors.h>
#include <:mach:msg_type.h>
#if	!defined(KERNEL) && !defined(MIG_NO_STRINGS)
#include <strings.h>
#endif
/* LINTLIBRARY */

extern port_t mig_get_reply_port();
extern void mig_dealloc_reply_port();

#ifndef	mig_internal
#define	mig_internal	static
#endif

#ifndef	TypeCheck
#define	TypeCheck 1
#endif

#ifndef	UseExternRCSId
#ifdef	hc
#define	UseExternRCSId		1
#endif
#endif

#ifndef	UseStaticMsgType
#if	!defined(hc) || defined(__STDC__)
#define	UseStaticMsgType	1
#endif
#endif

#define msg_request_port	msg_remote_port
#define msg_reply_port		msg_local_port

mig_external void init_mach_host
#if	(defined(__STDC__) || defined(c_plusplus))
	(port_t rep_port)
#else
	(rep_port)
	port_t rep_port;
#endif
{
#ifdef	lint
	rep_port++;
#endif
}

/* Routine host_processors */
mig_external kern_return_t host_processors
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host_priv,
	processor_array_t *processor_list,
	unsigned int *processor_listCnt
)
#else
	(host_priv, processor_list, processor_listCnt)
	host_priv_t host_priv;
	processor_array_t *processor_list;
	unsigned int *processor_listCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t processor_listType;
		processor_array_t processor_list;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host_priv;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2600;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2700)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->processor_listType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->processor_listType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->processor_listType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->processor_listType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*processor_list /* processor_list */ = /* *processor_list */ OutP->processor_list;

	*processor_listCnt /* processor_listType.msg_type_long_number */ = /* *processor_listCnt */ OutP->processor_listType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine host_info */
mig_external kern_return_t host_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	int flavor,
	host_info_t host_info_out,
	unsigned int *host_info_outCnt
)
#else
	(host, flavor, host_info_out, host_info_outCnt)
	host_t host;
	int flavor;
	host_info_t host_info_out;
	unsigned int *host_info_outCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t flavorType;
		int flavor;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t host_info_outType;
		int host_info_out[1024];
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t flavorType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->flavorType = flavorType;
#else	UseStaticMsgType
	InP->flavorType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->flavorType.msg_type_size = 32;
	InP->flavorType.msg_type_number = 1;
	InP->flavorType.msg_type_inline = TRUE;
	InP->flavorType.msg_type_longform = FALSE;
	InP->flavorType.msg_type_deallocate = FALSE;
	InP->flavorType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->flavor /* flavor */ = /* flavor */ flavor;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2601;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2701)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size < 44) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->host_info_outType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->host_info_outType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->host_info_outType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->host_info_outType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
	msg_size_delta = (4 * OutP->host_info_outType.msg_type_long_number);
	if (msg_size != 44 + msg_size_delta)
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->host_info_outType.msg_type_long_number / 1 > *host_info_outCnt) {
		bcopy((char *) OutP->host_info_out, (char *) host_info_out, 4 * *host_info_outCnt);
		*host_info_outCnt /* host_info_outType.msg_type_long_number 1 */ = /* *host_info_outCnt */ OutP->host_info_outType.msg_type_long_number / 1;
		return MIG_ARRAY_TOO_LARGE;
	}
	bcopy((char *) OutP->host_info_out, (char *) host_info_out, 4 * OutP->host_info_outType.msg_type_long_number);

	*host_info_outCnt /* host_info_outType.msg_type_long_number */ = /* *host_info_outCnt */ OutP->host_info_outType.msg_type_long_number;

	OutP = &Mess.Out;
	return OutP->RetCode;
}

/* Routine processor_info */
mig_external kern_return_t processor_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	int flavor,
	host_t *host,
	processor_info_t processor_info_out,
	unsigned int *processor_info_outCnt
)
#else
	(processor, flavor, host, processor_info_out, processor_info_outCnt)
	processor_t processor;
	int flavor;
	host_t *host;
	processor_info_t processor_info_out;
	unsigned int *processor_info_outCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t flavorType;
		int flavor;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t hostType;
		host_t host;
		msg_type_long_t processor_info_outType;
		int processor_info_out[1024];
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t flavorType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t hostCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->flavorType = flavorType;
#else	UseStaticMsgType
	InP->flavorType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->flavorType.msg_type_size = 32;
	InP->flavorType.msg_type_number = 1;
	InP->flavorType.msg_type_inline = TRUE;
	InP->flavorType.msg_type_longform = FALSE;
	InP->flavorType.msg_type_deallocate = FALSE;
	InP->flavorType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->flavor /* flavor */ = /* flavor */ flavor;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2602;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2702)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size < 52) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->hostType != * (int *) &hostCheck)
#else	UseStaticMsgType
	if ((OutP->hostType.msg_type_inline != TRUE) ||
	    (OutP->hostType.msg_type_longform != FALSE) ||
	    (OutP->hostType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->hostType.msg_type_number != 1) ||
	    (OutP->hostType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*host /* host */ = /* *host */ OutP->host;

#if	TypeCheck
	if ((OutP->processor_info_outType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->processor_info_outType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->processor_info_outType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->processor_info_outType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
	msg_size_delta = (4 * OutP->processor_info_outType.msg_type_long_number);
	if (msg_size != 52 + msg_size_delta)
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->processor_info_outType.msg_type_long_number / 1 > *processor_info_outCnt) {
		bcopy((char *) OutP->processor_info_out, (char *) processor_info_out, 4 * *processor_info_outCnt);
		*processor_info_outCnt /* processor_info_outType.msg_type_long_number 1 */ = /* *processor_info_outCnt */ OutP->processor_info_outType.msg_type_long_number / 1;
		return MIG_ARRAY_TOO_LARGE;
	}
	bcopy((char *) OutP->processor_info_out, (char *) processor_info_out, 4 * OutP->processor_info_outType.msg_type_long_number);

	*processor_info_outCnt /* processor_info_outType.msg_type_long_number */ = /* *processor_info_outCnt */ OutP->processor_info_outType.msg_type_long_number;

	OutP = &Mess.Out;
	return OutP->RetCode;
}

/* Routine processor_start */
mig_external kern_return_t processor_start
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor
)
#else
	(processor)
	processor_t processor;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2603;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2703)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_exit */
mig_external kern_return_t processor_exit
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor
)
#else
	(processor)
	processor_t processor;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2604;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2704)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_control */
mig_external kern_return_t processor_control
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	processor_info_t processor_cmd,
	unsigned int processor_cmdCnt
)
#else
	(processor, processor_cmd, processor_cmdCnt)
	processor_t processor;
	processor_info_t processor_cmd;
	unsigned int processor_cmdCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_long_t processor_cmdType;
		int processor_cmd[1024];
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 36;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_long_t processor_cmdType = {
	{
		/* msg_type_name = */		0,
		/* msg_type_size = */		0,
		/* msg_type_number = */		0,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	TRUE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	},
		/* msg_type_long_name = */	MSG_TYPE_INTEGER_32,
		/* msg_type_long_size = */	32,
		/* msg_type_long_number = */	1024
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->processor_cmdType = processor_cmdType;
#else	UseStaticMsgType
	InP->processor_cmdType.msg_type_long_name = MSG_TYPE_INTEGER_32;
	InP->processor_cmdType.msg_type_long_size = 32;
	InP->processor_cmdType.msg_type_header.msg_type_inline = TRUE;
	InP->processor_cmdType.msg_type_header.msg_type_longform = TRUE;
	InP->processor_cmdType.msg_type_header.msg_type_deallocate = FALSE;
	InP->processor_cmdType.msg_type_header.msg_type_unused = 0;
#endif	UseStaticMsgType

	if (processor_cmdCnt > 1024)
		return MIG_ARRAY_TOO_LARGE;
	bcopy((char *) processor_cmd, (char *) InP->processor_cmd, 4 * processor_cmdCnt);

	InP->processor_cmdType.msg_type_long_number /* processor_cmdCnt */ = /* processor_cmdType.msg_type_long_number */ processor_cmdCnt;

	msg_size_delta = (4 * processor_cmdCnt);
	msg_size += msg_size_delta;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2605;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2705)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_set_default */
mig_external kern_return_t processor_set_default
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	processor_set_name_t *default_set
)
#else
	(host, default_set)
	host_t host;
	processor_set_name_t *default_set;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t default_setType;
		processor_set_name_t default_set;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t default_setCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2606;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2706)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->default_setType != * (int *) &default_setCheck)
#else	UseStaticMsgType
	if ((OutP->default_setType.msg_type_inline != TRUE) ||
	    (OutP->default_setType.msg_type_longform != FALSE) ||
	    (OutP->default_setType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->default_setType.msg_type_number != 1) ||
	    (OutP->default_setType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*default_set /* default_set */ = /* *default_set */ OutP->default_set;

	return OutP->RetCode;
}

/* Routine xxx_processor_set_default_priv */
mig_external kern_return_t xxx_processor_set_default_priv
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host,
	processor_set_t *default_set
)
#else
	(host, default_set)
	host_priv_t host;
	processor_set_t *default_set;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t default_setType;
		processor_set_t default_set;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t default_setCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2607;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2707)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->default_setType != * (int *) &default_setCheck)
#else	UseStaticMsgType
	if ((OutP->default_setType.msg_type_inline != TRUE) ||
	    (OutP->default_setType.msg_type_longform != FALSE) ||
	    (OutP->default_setType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->default_setType.msg_type_number != 1) ||
	    (OutP->default_setType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*default_set /* default_set */ = /* *default_set */ OutP->default_set;

	return OutP->RetCode;
}

/* Routine processor_set_create */
mig_external kern_return_t processor_set_create
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	processor_set_t *new_set,
	processor_set_name_t *new_name
)
#else
	(host, new_set, new_name)
	host_t host;
	processor_set_t *new_set;
	processor_set_name_t *new_name;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t new_setType;
		processor_set_t new_set;
		msg_type_t new_nameType;
		processor_set_name_t new_name;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_setCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t new_nameCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2608;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2708)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->new_setType != * (int *) &new_setCheck)
#else	UseStaticMsgType
	if ((OutP->new_setType.msg_type_inline != TRUE) ||
	    (OutP->new_setType.msg_type_longform != FALSE) ||
	    (OutP->new_setType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->new_setType.msg_type_number != 1) ||
	    (OutP->new_setType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*new_set /* new_set */ = /* *new_set */ OutP->new_set;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->new_nameType != * (int *) &new_nameCheck)
#else	UseStaticMsgType
	if ((OutP->new_nameType.msg_type_inline != TRUE) ||
	    (OutP->new_nameType.msg_type_longform != FALSE) ||
	    (OutP->new_nameType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->new_nameType.msg_type_number != 1) ||
	    (OutP->new_nameType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*new_name /* new_name */ = /* *new_name */ OutP->new_name;

	return OutP->RetCode;
}

/* Routine processor_set_destroy */
mig_external kern_return_t processor_set_destroy
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t set
)
#else
	(set)
	processor_set_t set;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = set;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2609;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2709)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_set_info */
mig_external kern_return_t processor_set_info
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_name_t set_name,
	int flavor,
	host_t *host,
	processor_set_info_t info_out,
	unsigned int *info_outCnt
)
#else
	(set_name, flavor, host, info_out, info_outCnt)
	processor_set_name_t set_name;
	int flavor;
	host_t *host;
	processor_set_info_t info_out;
	unsigned int *info_outCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t flavorType;
		int flavor;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t hostType;
		host_t host;
		msg_type_long_t info_outType;
		int info_out[1024];
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;
	unsigned int msg_size_delta;

#if	UseStaticMsgType
	static msg_type_t flavorType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t hostCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->flavorType = flavorType;
#else	UseStaticMsgType
	InP->flavorType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->flavorType.msg_type_size = 32;
	InP->flavorType.msg_type_number = 1;
	InP->flavorType.msg_type_inline = TRUE;
	InP->flavorType.msg_type_longform = FALSE;
	InP->flavorType.msg_type_deallocate = FALSE;
	InP->flavorType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->flavor /* flavor */ = /* flavor */ flavor;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = set_name;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2610;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2710)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size < 52) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->hostType != * (int *) &hostCheck)
#else	UseStaticMsgType
	if ((OutP->hostType.msg_type_inline != TRUE) ||
	    (OutP->hostType.msg_type_longform != FALSE) ||
	    (OutP->hostType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->hostType.msg_type_number != 1) ||
	    (OutP->hostType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*host /* host */ = /* *host */ OutP->host;

#if	TypeCheck
	if ((OutP->info_outType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->info_outType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->info_outType.msg_type_long_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->info_outType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
	msg_size_delta = (4 * OutP->info_outType.msg_type_long_number);
	if (msg_size != 52 + msg_size_delta)
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->info_outType.msg_type_long_number / 1 > *info_outCnt) {
		bcopy((char *) OutP->info_out, (char *) info_out, 4 * *info_outCnt);
		*info_outCnt /* info_outType.msg_type_long_number 1 */ = /* *info_outCnt */ OutP->info_outType.msg_type_long_number / 1;
		return MIG_ARRAY_TOO_LARGE;
	}
	bcopy((char *) OutP->info_out, (char *) info_out, 4 * OutP->info_outType.msg_type_long_number);

	*info_outCnt /* info_outType.msg_type_long_number */ = /* *info_outCnt */ OutP->info_outType.msg_type_long_number;

	OutP = &Mess.Out;
	return OutP->RetCode;
}

/* Routine processor_assign */
mig_external kern_return_t processor_assign
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	processor_set_t new_set,
	boolean_t wait
)
#else
	(processor, new_set, wait)
	processor_t processor;
	processor_set_t new_set;
	boolean_t wait;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t new_setType;
		processor_set_t new_set;
		msg_type_t waitType;
		boolean_t wait;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t new_setType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t waitType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->new_setType = new_setType;
#else	UseStaticMsgType
	InP->new_setType.msg_type_name = MSG_TYPE_PORT;
	InP->new_setType.msg_type_size = 32;
	InP->new_setType.msg_type_number = 1;
	InP->new_setType.msg_type_inline = TRUE;
	InP->new_setType.msg_type_longform = FALSE;
	InP->new_setType.msg_type_deallocate = FALSE;
	InP->new_setType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->new_set /* new_set */ = /* new_set */ new_set;

#if	UseStaticMsgType
	InP->waitType = waitType;
#else	UseStaticMsgType
	InP->waitType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->waitType.msg_type_size = 32;
	InP->waitType.msg_type_number = 1;
	InP->waitType.msg_type_inline = TRUE;
	InP->waitType.msg_type_longform = FALSE;
	InP->waitType.msg_type_deallocate = FALSE;
	InP->waitType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->wait /* wait */ = /* wait */ wait;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2611;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2711)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_get_assignment */
mig_external kern_return_t processor_get_assignment
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	processor_set_name_t *assigned_set
)
#else
	(processor, assigned_set)
	processor_t processor;
	processor_set_name_t *assigned_set;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t assigned_setType;
		processor_set_name_t assigned_set;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t assigned_setCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2612;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2712)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->assigned_setType != * (int *) &assigned_setCheck)
#else	UseStaticMsgType
	if ((OutP->assigned_setType.msg_type_inline != TRUE) ||
	    (OutP->assigned_setType.msg_type_longform != FALSE) ||
	    (OutP->assigned_setType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->assigned_setType.msg_type_number != 1) ||
	    (OutP->assigned_setType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*assigned_set /* assigned_set */ = /* *assigned_set */ OutP->assigned_set;

	return OutP->RetCode;
}

/* Routine thread_assign */
mig_external kern_return_t thread_assign
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	processor_set_t new_set
)
#else
	(thread, new_set)
	thread_t thread;
	processor_set_t new_set;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t new_setType;
		processor_set_t new_set;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t new_setType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->new_setType = new_setType;
#else	UseStaticMsgType
	InP->new_setType.msg_type_name = MSG_TYPE_PORT;
	InP->new_setType.msg_type_size = 32;
	InP->new_setType.msg_type_number = 1;
	InP->new_setType.msg_type_inline = TRUE;
	InP->new_setType.msg_type_longform = FALSE;
	InP->new_setType.msg_type_deallocate = FALSE;
	InP->new_setType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->new_set /* new_set */ = /* new_set */ new_set;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2613;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2713)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_assign_default */
mig_external kern_return_t thread_assign_default
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread
)
#else
	(thread)
	thread_t thread;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2614;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2714)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_get_assignment */
mig_external kern_return_t thread_get_assignment
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	processor_set_name_t *assigned_set
)
#else
	(thread, assigned_set)
	thread_t thread;
	processor_set_name_t *assigned_set;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t assigned_setType;
		processor_set_name_t assigned_set;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t assigned_setCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2615;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2715)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->assigned_setType != * (int *) &assigned_setCheck)
#else	UseStaticMsgType
	if ((OutP->assigned_setType.msg_type_inline != TRUE) ||
	    (OutP->assigned_setType.msg_type_longform != FALSE) ||
	    (OutP->assigned_setType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->assigned_setType.msg_type_number != 1) ||
	    (OutP->assigned_setType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*assigned_set /* assigned_set */ = /* *assigned_set */ OutP->assigned_set;

	return OutP->RetCode;
}

/* Routine task_assign */
mig_external kern_return_t task_assign
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	processor_set_t new_set,
	boolean_t assign_threads
)
#else
	(task, new_set, assign_threads)
	task_t task;
	processor_set_t new_set;
	boolean_t assign_threads;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t new_setType;
		processor_set_t new_set;
		msg_type_t assign_threadsType;
		boolean_t assign_threads;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t new_setType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t assign_threadsType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->new_setType = new_setType;
#else	UseStaticMsgType
	InP->new_setType.msg_type_name = MSG_TYPE_PORT;
	InP->new_setType.msg_type_size = 32;
	InP->new_setType.msg_type_number = 1;
	InP->new_setType.msg_type_inline = TRUE;
	InP->new_setType.msg_type_longform = FALSE;
	InP->new_setType.msg_type_deallocate = FALSE;
	InP->new_setType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->new_set /* new_set */ = /* new_set */ new_set;

#if	UseStaticMsgType
	InP->assign_threadsType = assign_threadsType;
#else	UseStaticMsgType
	InP->assign_threadsType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->assign_threadsType.msg_type_size = 32;
	InP->assign_threadsType.msg_type_number = 1;
	InP->assign_threadsType.msg_type_inline = TRUE;
	InP->assign_threadsType.msg_type_longform = FALSE;
	InP->assign_threadsType.msg_type_deallocate = FALSE;
	InP->assign_threadsType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->assign_threads /* assign_threads */ = /* assign_threads */ assign_threads;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2616;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2716)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_assign_default */
mig_external kern_return_t task_assign_default
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	boolean_t assign_threads
)
#else
	(task, assign_threads)
	task_t task;
	boolean_t assign_threads;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t assign_threadsType;
		boolean_t assign_threads;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t assign_threadsType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->assign_threadsType = assign_threadsType;
#else	UseStaticMsgType
	InP->assign_threadsType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->assign_threadsType.msg_type_size = 32;
	InP->assign_threadsType.msg_type_number = 1;
	InP->assign_threadsType.msg_type_inline = TRUE;
	InP->assign_threadsType.msg_type_longform = FALSE;
	InP->assign_threadsType.msg_type_deallocate = FALSE;
	InP->assign_threadsType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->assign_threads /* assign_threads */ = /* assign_threads */ assign_threads;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2617;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2717)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_get_assignment */
mig_external kern_return_t task_get_assignment
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	processor_set_name_t *assigned_set
)
#else
	(task, assigned_set)
	task_t task;
	processor_set_name_t *assigned_set;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t assigned_setType;
		processor_set_name_t assigned_set;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t assigned_setCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2618;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2718)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->assigned_setType != * (int *) &assigned_setCheck)
#else	UseStaticMsgType
	if ((OutP->assigned_setType.msg_type_inline != TRUE) ||
	    (OutP->assigned_setType.msg_type_longform != FALSE) ||
	    (OutP->assigned_setType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->assigned_setType.msg_type_number != 1) ||
	    (OutP->assigned_setType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*assigned_set /* assigned_set */ = /* *assigned_set */ OutP->assigned_set;

	return OutP->RetCode;
}

/* Routine host_kernel_version */
mig_external kern_return_t host_kernel_version
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	kernel_version_t kernel_version
)
#else
	(host, kernel_version)
	host_t host;
	kernel_version_t kernel_version;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t kernel_versionType;
		kernel_version_t kernel_version;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2619;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2719)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 556) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->kernel_versionType.msg_type_header.msg_type_inline != TRUE) ||
	    (OutP->kernel_versionType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->kernel_versionType.msg_type_long_name != MSG_TYPE_STRING) ||
	    (OutP->kernel_versionType.msg_type_long_number != 1) ||
	    (OutP->kernel_versionType.msg_type_long_size != 4096))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	(void) mig_strncpy(kernel_version /* kernel_version */, /* kernel_version */ OutP->kernel_version, 512);
	kernel_version /* kernel_version */[511] = '\0';

	return OutP->RetCode;
}

/* Routine thread_priority */
mig_external kern_return_t thread_priority
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int priority,
	boolean_t set_max
)
#else
	(thread, priority, set_max)
	thread_t thread;
	int priority;
	boolean_t set_max;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t priorityType;
		int priority;
		msg_type_t set_maxType;
		boolean_t set_max;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t priorityType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t set_maxType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->priorityType = priorityType;
#else	UseStaticMsgType
	InP->priorityType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->priorityType.msg_type_size = 32;
	InP->priorityType.msg_type_number = 1;
	InP->priorityType.msg_type_inline = TRUE;
	InP->priorityType.msg_type_longform = FALSE;
	InP->priorityType.msg_type_deallocate = FALSE;
	InP->priorityType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->priority /* priority */ = /* priority */ priority;

#if	UseStaticMsgType
	InP->set_maxType = set_maxType;
#else	UseStaticMsgType
	InP->set_maxType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->set_maxType.msg_type_size = 32;
	InP->set_maxType.msg_type_number = 1;
	InP->set_maxType.msg_type_inline = TRUE;
	InP->set_maxType.msg_type_longform = FALSE;
	InP->set_maxType.msg_type_deallocate = FALSE;
	InP->set_maxType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->set_max /* set_max */ = /* set_max */ set_max;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2620;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2720)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_max_priority */
mig_external kern_return_t thread_max_priority
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	processor_set_t processor_set,
	int max_priority
)
#else
	(thread, processor_set, max_priority)
	thread_t thread;
	processor_set_t processor_set;
	int max_priority;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t processor_setType;
		processor_set_t processor_set;
		msg_type_t max_priorityType;
		int max_priority;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t processor_setType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t max_priorityType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->processor_setType = processor_setType;
#else	UseStaticMsgType
	InP->processor_setType.msg_type_name = MSG_TYPE_PORT;
	InP->processor_setType.msg_type_size = 32;
	InP->processor_setType.msg_type_number = 1;
	InP->processor_setType.msg_type_inline = TRUE;
	InP->processor_setType.msg_type_longform = FALSE;
	InP->processor_setType.msg_type_deallocate = FALSE;
	InP->processor_setType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->processor_set /* processor_set */ = /* processor_set */ processor_set;

#if	UseStaticMsgType
	InP->max_priorityType = max_priorityType;
#else	UseStaticMsgType
	InP->max_priorityType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->max_priorityType.msg_type_size = 32;
	InP->max_priorityType.msg_type_number = 1;
	InP->max_priorityType.msg_type_inline = TRUE;
	InP->max_priorityType.msg_type_longform = FALSE;
	InP->max_priorityType.msg_type_deallocate = FALSE;
	InP->max_priorityType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->max_priority /* max_priority */ = /* max_priority */ max_priority;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2621;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2721)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine task_priority */
mig_external kern_return_t task_priority
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int priority,
	boolean_t change_threads
)
#else
	(task, priority, change_threads)
	task_t task;
	int priority;
	boolean_t change_threads;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t priorityType;
		int priority;
		msg_type_t change_threadsType;
		boolean_t change_threads;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t priorityType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t change_threadsType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->priorityType = priorityType;
#else	UseStaticMsgType
	InP->priorityType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->priorityType.msg_type_size = 32;
	InP->priorityType.msg_type_number = 1;
	InP->priorityType.msg_type_inline = TRUE;
	InP->priorityType.msg_type_longform = FALSE;
	InP->priorityType.msg_type_deallocate = FALSE;
	InP->priorityType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->priority /* priority */ = /* priority */ priority;

#if	UseStaticMsgType
	InP->change_threadsType = change_threadsType;
#else	UseStaticMsgType
	InP->change_threadsType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->change_threadsType.msg_type_size = 32;
	InP->change_threadsType.msg_type_number = 1;
	InP->change_threadsType.msg_type_inline = TRUE;
	InP->change_threadsType.msg_type_longform = FALSE;
	InP->change_threadsType.msg_type_deallocate = FALSE;
	InP->change_threadsType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->change_threads /* change_threads */ = /* change_threads */ change_threads;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = task;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2622;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2722)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_set_max_priority */
mig_external kern_return_t processor_set_max_priority
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	int max_priority,
	boolean_t change_threads
)
#else
	(processor_set, max_priority, change_threads)
	processor_set_t processor_set;
	int max_priority;
	boolean_t change_threads;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t max_priorityType;
		int max_priority;
		msg_type_t change_threadsType;
		boolean_t change_threads;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t max_priorityType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t change_threadsType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->max_priorityType = max_priorityType;
#else	UseStaticMsgType
	InP->max_priorityType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->max_priorityType.msg_type_size = 32;
	InP->max_priorityType.msg_type_number = 1;
	InP->max_priorityType.msg_type_inline = TRUE;
	InP->max_priorityType.msg_type_longform = FALSE;
	InP->max_priorityType.msg_type_deallocate = FALSE;
	InP->max_priorityType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->max_priority /* max_priority */ = /* max_priority */ max_priority;

#if	UseStaticMsgType
	InP->change_threadsType = change_threadsType;
#else	UseStaticMsgType
	InP->change_threadsType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->change_threadsType.msg_type_size = 32;
	InP->change_threadsType.msg_type_number = 1;
	InP->change_threadsType.msg_type_inline = TRUE;
	InP->change_threadsType.msg_type_longform = FALSE;
	InP->change_threadsType.msg_type_deallocate = FALSE;
	InP->change_threadsType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->change_threads /* change_threads */ = /* change_threads */ change_threads;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor_set;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2623;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2723)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine thread_policy */
mig_external kern_return_t thread_policy
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int policy,
	int data
)
#else
	(thread, policy, data)
	thread_t thread;
	int policy;
	int data;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t policyType;
		int policy;
		msg_type_t dataType;
		int data;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t policyType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t dataType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->policyType = policyType;
#else	UseStaticMsgType
	InP->policyType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->policyType.msg_type_size = 32;
	InP->policyType.msg_type_number = 1;
	InP->policyType.msg_type_inline = TRUE;
	InP->policyType.msg_type_longform = FALSE;
	InP->policyType.msg_type_deallocate = FALSE;
	InP->policyType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->policy /* policy */ = /* policy */ policy;

#if	UseStaticMsgType
	InP->dataType = dataType;
#else	UseStaticMsgType
	InP->dataType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->dataType.msg_type_size = 32;
	InP->dataType.msg_type_number = 1;
	InP->dataType.msg_type_inline = TRUE;
	InP->dataType.msg_type_longform = FALSE;
	InP->dataType.msg_type_deallocate = FALSE;
	InP->dataType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->data /* data */ = /* data */ data;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = thread;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2624;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2724)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_set_policy_enable */
mig_external kern_return_t processor_set_policy_enable
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	int policy
)
#else
	(processor_set, policy)
	processor_set_t processor_set;
	int policy;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t policyType;
		int policy;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t policyType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->policyType = policyType;
#else	UseStaticMsgType
	InP->policyType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->policyType.msg_type_size = 32;
	InP->policyType.msg_type_number = 1;
	InP->policyType.msg_type_inline = TRUE;
	InP->policyType.msg_type_longform = FALSE;
	InP->policyType.msg_type_deallocate = FALSE;
	InP->policyType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->policy /* policy */ = /* policy */ policy;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor_set;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2625;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2725)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_set_policy_disable */
mig_external kern_return_t processor_set_policy_disable
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	int policy,
	boolean_t change_threads
)
#else
	(processor_set, policy, change_threads)
	processor_set_t processor_set;
	int policy;
	boolean_t change_threads;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t policyType;
		int policy;
		msg_type_t change_threadsType;
		boolean_t change_threads;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 40;

#if	UseStaticMsgType
	static msg_type_t policyType = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t change_threadsType = {
		/* msg_type_name = */		MSG_TYPE_BOOLEAN,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->policyType = policyType;
#else	UseStaticMsgType
	InP->policyType.msg_type_name = MSG_TYPE_INTEGER_32;
	InP->policyType.msg_type_size = 32;
	InP->policyType.msg_type_number = 1;
	InP->policyType.msg_type_inline = TRUE;
	InP->policyType.msg_type_longform = FALSE;
	InP->policyType.msg_type_deallocate = FALSE;
	InP->policyType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->policy /* policy */ = /* policy */ policy;

#if	UseStaticMsgType
	InP->change_threadsType = change_threadsType;
#else	UseStaticMsgType
	InP->change_threadsType.msg_type_name = MSG_TYPE_BOOLEAN;
	InP->change_threadsType.msg_type_size = 32;
	InP->change_threadsType.msg_type_number = 1;
	InP->change_threadsType.msg_type_inline = TRUE;
	InP->change_threadsType.msg_type_longform = FALSE;
	InP->change_threadsType.msg_type_deallocate = FALSE;
	InP->change_threadsType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->change_threads /* change_threads */ = /* change_threads */ change_threads;

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor_set;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2626;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2726)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 32) || (msg_simple != TRUE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

	return OutP->RetCode;
}

/* Routine processor_set_tasks */
mig_external kern_return_t processor_set_tasks
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	task_array_t *task_list,
	unsigned int *task_listCnt
)
#else
	(processor_set, task_list, task_listCnt)
	processor_set_t processor_set;
	task_array_t *task_list;
	unsigned int *task_listCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t task_listType;
		task_array_t task_list;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor_set;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2627;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2727)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->task_listType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->task_listType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->task_listType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->task_listType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*task_list /* task_list */ = /* *task_list */ OutP->task_list;

	*task_listCnt /* task_listType.msg_type_long_number */ = /* *task_listCnt */ OutP->task_listType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine processor_set_threads */
mig_external kern_return_t processor_set_threads
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	thread_array_t *thread_list,
	unsigned int *thread_listCnt
)
#else
	(processor_set, thread_list, thread_listCnt)
	processor_set_t processor_set;
	thread_array_t *thread_list;
	unsigned int *thread_listCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t thread_listType;
		thread_array_t thread_list;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = processor_set;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2628;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2728)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->thread_listType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->thread_listType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->thread_listType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->thread_listType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*thread_list /* thread_list */ = /* *thread_list */ OutP->thread_list;

	*thread_listCnt /* thread_listType.msg_type_long_number */ = /* *thread_listCnt */ OutP->thread_listType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine host_processor_sets */
mig_external kern_return_t host_processor_sets
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	processor_set_name_array_t *processor_sets,
	unsigned int *processor_setsCnt
)
#else
	(host, processor_sets, processor_setsCnt)
	host_t host;
	processor_set_name_array_t *processor_sets;
	unsigned int *processor_setsCnt;
#endif
{
	typedef struct {
		msg_header_t Head;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_long_t processor_setsType;
		processor_set_name_array_t processor_sets;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 24;

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

	InP->Head.msg_simple = TRUE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2629;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2729)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 48) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
	if ((OutP->processor_setsType.msg_type_header.msg_type_inline != FALSE) ||
	    (OutP->processor_setsType.msg_type_header.msg_type_longform != TRUE) ||
	    (OutP->processor_setsType.msg_type_long_name != MSG_TYPE_PORT) ||
	    (OutP->processor_setsType.msg_type_long_size != 32))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*processor_sets /* processor_sets */ = /* *processor_sets */ OutP->processor_sets;

	*processor_setsCnt /* processor_setsType.msg_type_long_number */ = /* *processor_setsCnt */ OutP->processor_setsType.msg_type_long_number;

	return OutP->RetCode;
}

/* Routine host_processor_set_priv */
mig_external kern_return_t host_processor_set_priv
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host_priv,
	processor_set_name_t set_name,
	processor_set_t *set
)
#else
	(host_priv, set_name, set)
	host_priv_t host_priv;
	processor_set_name_t set_name;
	processor_set_t *set;
#endif
{
	typedef struct {
		msg_header_t Head;
		msg_type_t set_nameType;
		processor_set_name_t set_name;
	} Request;

	typedef struct {
		msg_header_t Head;
		msg_type_t RetCodeType;
		kern_return_t RetCode;
		msg_type_t setType;
		processor_set_t set;
	} Reply;

	union {
		Request In;
		Reply Out;
	} Mess;

	register Request *InP = &Mess.In;
	register Reply *OutP = &Mess.Out;

	msg_return_t msg_result;

#if	TypeCheck
	boolean_t msg_simple;
#endif	TypeCheck

	unsigned int msg_size = 32;

#if	UseStaticMsgType
	static msg_type_t set_nameType = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t RetCodeCheck = {
		/* msg_type_name = */		MSG_TYPE_INTEGER_32,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	static msg_type_t setCheck = {
		/* msg_type_name = */		MSG_TYPE_PORT,
		/* msg_type_size = */		32,
		/* msg_type_number = */		1,
		/* msg_type_inline = */		TRUE,
		/* msg_type_longform = */	FALSE,
		/* msg_type_deallocate = */	FALSE,
		/* msg_type_unused = */	0
	};
#endif	UseStaticMsgType

#if	UseStaticMsgType
	InP->set_nameType = set_nameType;
#else	UseStaticMsgType
	InP->set_nameType.msg_type_name = MSG_TYPE_PORT;
	InP->set_nameType.msg_type_size = 32;
	InP->set_nameType.msg_type_number = 1;
	InP->set_nameType.msg_type_inline = TRUE;
	InP->set_nameType.msg_type_longform = FALSE;
	InP->set_nameType.msg_type_deallocate = FALSE;
	InP->set_nameType.msg_type_unused = 0;
#endif	UseStaticMsgType

	InP->set_name /* set_name */ = /* set_name */ set_name;

	InP->Head.msg_simple = FALSE;
	InP->Head.msg_size = msg_size;
	InP->Head.msg_type = MSG_TYPE_NORMAL | MSG_TYPE_RPC;
	InP->Head.msg_request_port = host_priv;
	InP->Head.msg_reply_port = mig_get_reply_port();
	InP->Head.msg_id = 2630;

	msg_result = msg_rpc(&InP->Head, MSG_OPTION_NONE, sizeof(Reply), 0, 0);
	if (msg_result != RPC_SUCCESS) {
		if (msg_result == RCV_INVALID_PORT)
			mig_dealloc_reply_port();
		return msg_result;
	}

#if	TypeCheck
	msg_size = OutP->Head.msg_size;
	msg_simple = OutP->Head.msg_simple;
#endif	TypeCheck

	if (OutP->Head.msg_id != 2730)
		return MIG_REPLY_MISMATCH;

#if	TypeCheck
	if (((msg_size != 40) || (msg_simple != FALSE)) &&
	    ((msg_size != sizeof(death_pill_t)) ||
	     (msg_simple != TRUE) ||
	     (OutP->RetCode == KERN_SUCCESS)))
		return MIG_TYPE_ERROR;
#endif	TypeCheck

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->RetCodeType != * (int *) &RetCodeCheck)
#else	UseStaticMsgType
	if ((OutP->RetCodeType.msg_type_inline != TRUE) ||
	    (OutP->RetCodeType.msg_type_longform != FALSE) ||
	    (OutP->RetCodeType.msg_type_name != MSG_TYPE_INTEGER_32) ||
	    (OutP->RetCodeType.msg_type_number != 1) ||
	    (OutP->RetCodeType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	if (OutP->RetCode != KERN_SUCCESS)
		return OutP->RetCode;

#if	TypeCheck
#if	UseStaticMsgType
	if (* (int *) &OutP->setType != * (int *) &setCheck)
#else	UseStaticMsgType
	if ((OutP->setType.msg_type_inline != TRUE) ||
	    (OutP->setType.msg_type_longform != FALSE) ||
	    (OutP->setType.msg_type_name != MSG_TYPE_PORT) ||
	    (OutP->setType.msg_type_number != 1) ||
	    (OutP->setType.msg_type_size != 32))
#endif	UseStaticMsgType
		return MIG_TYPE_ERROR;
#endif	TypeCheck

	*set /* set */ = /* *set */ OutP->set;

	return OutP->RetCode;
}
@EOF@

echo "libmach/mach_interface.h"
cat >libmach/mach_interface.h <<'@EOF@'
#ifndef	_mach
#define	_mach

/* Module mach */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_mach
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>
#include <:mach:mach_types.h>
#include <:mach:mach_extra.h>

/* Routine xxx_port_allocate */
mig_external kern_return_t xxx_port_allocate
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t *my_port;
{ return xxx_port_allocate(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t *my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_deallocate */
mig_external kern_return_t xxx_port_deallocate
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t my_port;
{ return xxx_port_deallocate(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_enable */
mig_external kern_return_t xxx_port_enable
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t my_port;
{ return xxx_port_enable(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_disable */
mig_external kern_return_t xxx_port_disable
#if	defined(LINTLIBRARY)
    (target_task, my_port)
	task_t target_task;
	port_t my_port;
{ return xxx_port_disable(target_task, my_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port
);
#else
    ();
#endif
#endif

/* Routine xxx_port_select */
mig_external kern_return_t xxx_port_select
#if	defined(LINTLIBRARY)
    (target_task, port_list, port_listCnt)
	task_t target_task;
	port_array_t *port_list;
	unsigned int *port_listCnt;
{ return xxx_port_select(target_task, port_list, port_listCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t *port_list,
	unsigned int *port_listCnt
);
#else
    ();
#endif
#endif

/* Routine xxx_port_set_backlog */
mig_external kern_return_t xxx_port_set_backlog
#if	defined(LINTLIBRARY)
    (target_task, my_port, backlog)
	task_t target_task;
	port_t my_port;
	int backlog;
{ return xxx_port_set_backlog(target_task, my_port, backlog); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port,
	int backlog
);
#else
    ();
#endif
#endif

/* Routine xxx_port_status */
mig_external kern_return_t xxx_port_status
#if	defined(LINTLIBRARY)
    (target_task, my_port, enabled, num_msgs, backlog, ownership, receive_rights)
	task_t target_task;
	port_t my_port;
	boolean_t *enabled;
	int *num_msgs;
	int *backlog;
	boolean_t *ownership;
	boolean_t *receive_rights;
{ return xxx_port_status(target_task, my_port, enabled, num_msgs, backlog, ownership, receive_rights); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_t my_port,
	boolean_t *enabled,
	int *num_msgs,
	int *backlog,
	boolean_t *ownership,
	boolean_t *receive_rights
);
#else
    ();
#endif
#endif

/* Routine task_create */
mig_external kern_return_t task_create
#if	defined(LINTLIBRARY)
    (target_task, inherit_memory, child_task)
	task_t target_task;
	boolean_t inherit_memory;
	task_t *child_task;
{ return task_create(target_task, inherit_memory, child_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	boolean_t inherit_memory,
	task_t *child_task
);
#else
    ();
#endif
#endif

/* Routine task_terminate */
mig_external kern_return_t task_terminate
#if	defined(LINTLIBRARY)
    (target_task)
	task_t target_task;
{ return task_terminate(target_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
);
#else
    ();
#endif
#endif

/* Routine task_threads */
mig_external kern_return_t task_threads
#if	defined(LINTLIBRARY)
    (target_task, thread_list, thread_listCnt)
	task_t target_task;
	thread_array_t *thread_list;
	unsigned int *thread_listCnt;
{ return task_threads(target_task, thread_list, thread_listCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	thread_array_t *thread_list,
	unsigned int *thread_listCnt
);
#else
    ();
#endif
#endif

/* Routine thread_terminate */
mig_external kern_return_t thread_terminate
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_terminate(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine vm_allocate */
mig_external kern_return_t vm_allocate
#if	defined(LINTLIBRARY)
    (target_task, address, size, anywhere)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t size;
	boolean_t anywhere;
{ return vm_allocate(target_task, address, size, anywhere); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t size,
	boolean_t anywhere
);
#else
    ();
#endif
#endif

/* Routine vm_deallocate */
mig_external kern_return_t vm_deallocate
#if	defined(LINTLIBRARY)
    (target_task, address, size)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
{ return vm_deallocate(target_task, address, size); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size
);
#else
    ();
#endif
#endif

/* Routine vm_protect */
mig_external kern_return_t vm_protect
#if	defined(LINTLIBRARY)
    (target_task, address, size, set_maximum, new_protection)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	boolean_t set_maximum;
	vm_prot_t new_protection;
{ return vm_protect(target_task, address, size, set_maximum, new_protection); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	boolean_t set_maximum,
	vm_prot_t new_protection
);
#else
    ();
#endif
#endif

/* Routine vm_inherit */
mig_external kern_return_t vm_inherit
#if	defined(LINTLIBRARY)
    (target_task, address, size, new_inheritance)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	vm_inherit_t new_inheritance;
{ return vm_inherit(target_task, address, size, new_inheritance); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	vm_inherit_t new_inheritance
);
#else
    ();
#endif
#endif

/* Routine vm_read */
mig_external kern_return_t vm_read
#if	defined(LINTLIBRARY)
    (target_task, address, size, data, dataCnt)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	pointer_t *data;
	unsigned int *dataCnt;
{ return vm_read(target_task, address, size, data, dataCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	pointer_t *data,
	unsigned int *dataCnt
);
#else
    ();
#endif
#endif

/* Routine vm_write */
mig_external kern_return_t vm_write
#if	defined(LINTLIBRARY)
    (target_task, address, data, dataCnt)
	vm_task_t target_task;
	vm_address_t address;
	pointer_t data;
	unsigned int dataCnt;
{ return vm_write(target_task, address, data, dataCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	pointer_t data,
	unsigned int dataCnt
);
#else
    ();
#endif
#endif

/* Routine vm_copy */
mig_external kern_return_t vm_copy
#if	defined(LINTLIBRARY)
    (target_task, source_address, size, dest_address)
	vm_task_t target_task;
	vm_address_t source_address;
	vm_size_t size;
	vm_address_t dest_address;
{ return vm_copy(target_task, source_address, size, dest_address); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t source_address,
	vm_size_t size,
	vm_address_t dest_address
);
#else
    ();
#endif
#endif

/* Routine vm_region */
mig_external kern_return_t vm_region
#if	defined(LINTLIBRARY)
    (target_task, address, size, protection, max_protection, inheritance, is_shared, object_name, offset)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t *size;
	vm_prot_t *protection;
	vm_prot_t *max_protection;
	vm_inherit_t *inheritance;
	boolean_t *is_shared;
	memory_object_name_t *object_name;
	vm_offset_t *offset;
{ return vm_region(target_task, address, size, protection, max_protection, inheritance, is_shared, object_name, offset); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t *size,
	vm_prot_t *protection,
	vm_prot_t *max_protection,
	vm_inherit_t *inheritance,
	boolean_t *is_shared,
	memory_object_name_t *object_name,
	vm_offset_t *offset
);
#else
    ();
#endif
#endif

/* Routine vm_statistics */
mig_external kern_return_t vm_statistics
#if	defined(LINTLIBRARY)
    (target_task, vm_stats)
	vm_task_t target_task;
	vm_statistics_data_t *vm_stats;
{ return vm_statistics(target_task, vm_stats); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_statistics_data_t *vm_stats
);
#else
    ();
#endif
#endif

/* Routine task_by_unix_pid */
mig_external kern_return_t task_by_unix_pid
#if	defined(LINTLIBRARY)
    (target_task, process_id, result_task)
	task_t target_task;
	int process_id;
	task_t *result_task;
{ return task_by_unix_pid(target_task, process_id, result_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int process_id,
	task_t *result_task
);
#else
    ();
#endif
#endif

/* Routine mach_ports_register */
mig_external kern_return_t mach_ports_register
#if	defined(LINTLIBRARY)
    (target_task, init_port_set, init_port_setCnt)
	task_t target_task;
	port_array_t init_port_set;
	unsigned int init_port_setCnt;
{ return mach_ports_register(target_task, init_port_set, init_port_setCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t init_port_set,
	unsigned int init_port_setCnt
);
#else
    ();
#endif
#endif

/* Routine mach_ports_lookup */
mig_external kern_return_t mach_ports_lookup
#if	defined(LINTLIBRARY)
    (target_task, init_port_set, init_port_setCnt)
	task_t target_task;
	port_array_t *init_port_set;
	unsigned int *init_port_setCnt;
{ return mach_ports_lookup(target_task, init_port_set, init_port_setCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	port_array_t *init_port_set,
	unsigned int *init_port_setCnt
);
#else
    ();
#endif
#endif

/* Routine unix_pid */
mig_external kern_return_t unix_pid
#if	defined(LINTLIBRARY)
    (target_task, process_id)
	task_t target_task;
	int *process_id;
{ return unix_pid(target_task, process_id); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int *process_id
);
#else
    ();
#endif
#endif

/* Routine netipc_listen */
mig_external kern_return_t netipc_listen
#if	defined(LINTLIBRARY)
    (request_port, src_addr, dst_addr, src_port, dst_port, protocol, ipc_port)
	port_t request_port;
	int src_addr;
	int dst_addr;
	int src_port;
	int dst_port;
	int protocol;
	port_t ipc_port;
{ return netipc_listen(request_port, src_addr, dst_addr, src_port, dst_port, protocol, ipc_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	int src_addr,
	int dst_addr,
	int src_port,
	int dst_port,
	int protocol,
	port_t ipc_port
);
#else
    ();
#endif
#endif

/* Routine netipc_ignore */
mig_external kern_return_t netipc_ignore
#if	defined(LINTLIBRARY)
    (request_port, ipc_port)
	port_t request_port;
	port_t ipc_port;
{ return netipc_ignore(request_port, ipc_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	port_t ipc_port
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_provided */
mig_external kern_return_t memory_object_data_provided
#if	defined(LINTLIBRARY)
    (memory_control, offset, data, dataCnt, lock_value)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	pointer_t data;
	unsigned int dataCnt;
	vm_prot_t lock_value;
{ return memory_object_data_provided(memory_control, offset, data, dataCnt, lock_value); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	pointer_t data,
	unsigned int dataCnt,
	vm_prot_t lock_value
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_unavailable */
mig_external kern_return_t memory_object_data_unavailable
#if	defined(LINTLIBRARY)
    (memory_control, offset, size)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
{ return memory_object_data_unavailable(memory_control, offset, size); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size
);
#else
    ();
#endif
#endif

/* Routine memory_object_get_attributes */
mig_external kern_return_t memory_object_get_attributes
#if	defined(LINTLIBRARY)
    (memory_control, object_ready, may_cache, copy_strategy)
	memory_object_control_t memory_control;
	boolean_t *object_ready;
	boolean_t *may_cache;
	memory_object_copy_strategy_t *copy_strategy;
{ return memory_object_get_attributes(memory_control, object_ready, may_cache, copy_strategy); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t *object_ready,
	boolean_t *may_cache,
	memory_object_copy_strategy_t *copy_strategy
);
#else
    ();
#endif
#endif

/* Routine vm_set_default_memory_manager */
mig_external kern_return_t vm_set_default_memory_manager
#if	defined(LINTLIBRARY)
    (host, default_manager)
	host_priv_t host;
	memory_object_t *default_manager;
{ return vm_set_default_memory_manager(host, default_manager); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host,
	memory_object_t *default_manager
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_lock_request */
mig_external kern_return_t memory_object_lock_request
#if	defined(LINTLIBRARY)
    (memory_control, offset, size, should_clean, should_flush, lock_value, reply_to)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
	boolean_t should_clean;
	boolean_t should_flush;
	vm_prot_t lock_value;
	port_t reply_to;
{ return memory_object_lock_request(memory_control, offset, size, should_clean, should_flush, lock_value, reply_to); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size,
	boolean_t should_clean,
	boolean_t should_flush,
	vm_prot_t lock_value,
	port_t reply_to
);
#else
    ();
#endif
#endif

/* SimpleRoutine xxx_pager_cache */
mig_external kern_return_t xxx_pager_cache
#if	defined(LINTLIBRARY)
    (memory_control, should_cache)
	memory_object_control_t memory_control;
	boolean_t should_cache;
{ return xxx_pager_cache(memory_control, should_cache); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t should_cache
);
#else
    ();
#endif
#endif

/* Routine xxx_host_info */
mig_external kern_return_t xxx_host_info
#if	defined(LINTLIBRARY)
    (target_task, info)
	port_t target_task;
	machine_info_data_t *info;
{ return xxx_host_info(target_task, info); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t target_task,
	machine_info_data_t *info
);
#else
    ();
#endif
#endif

/* Routine xxx_slot_info */
mig_external kern_return_t xxx_slot_info
#if	defined(LINTLIBRARY)
    (target_task, slot, info)
	task_t target_task;
	int slot;
	machine_slot_data_t *info;
{ return xxx_slot_info(target_task, slot, info); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int slot,
	machine_slot_data_t *info
);
#else
    ();
#endif
#endif

/* Routine xxx_cpu_control */
mig_external kern_return_t xxx_cpu_control
#if	defined(LINTLIBRARY)
    (target_task, cpu, running)
	task_t target_task;
	int cpu;
	boolean_t running;
{ return xxx_cpu_control(target_task, cpu, running); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int cpu,
	boolean_t running
);
#else
    ();
#endif
#endif

/* Routine netport_init */
mig_external kern_return_t netport_init
#if	defined(LINTLIBRARY)
    (request_port)
	port_t request_port;
{ return netport_init(request_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port
);
#else
    ();
#endif
#endif

/* Routine netport_enter */
mig_external kern_return_t netport_enter
#if	defined(LINTLIBRARY)
    (request_port, netport, port, local)
	port_t request_port;
	network_port_t netport;
	port_t port;
	boolean_t local;
{ return netport_enter(request_port, netport, port, local); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	network_port_t netport,
	port_t port,
	boolean_t local
);
#else
    ();
#endif
#endif

/* Routine netport_remove */
mig_external kern_return_t netport_remove
#if	defined(LINTLIBRARY)
    (request_port, netport)
	port_t request_port;
	network_port_t netport;
{ return netport_remove(request_port, netport); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t request_port,
	network_port_t netport
);
#else
    ();
#endif
#endif

/* Routine task_suspend */
mig_external kern_return_t task_suspend
#if	defined(LINTLIBRARY)
    (target_task)
	task_t target_task;
{ return task_suspend(target_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
);
#else
    ();
#endif
#endif

/* Routine task_resume */
mig_external kern_return_t task_resume
#if	defined(LINTLIBRARY)
    (target_task)
	task_t target_task;
{ return task_resume(target_task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task
);
#else
    ();
#endif
#endif

/* Routine task_get_special_port */
mig_external kern_return_t task_get_special_port
#if	defined(LINTLIBRARY)
    (task, which_port, special_port)
	task_t task;
	int which_port;
	port_t *special_port;
{ return task_get_special_port(task, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int which_port,
	port_t *special_port
);
#else
    ();
#endif
#endif

/* Routine task_set_special_port */
mig_external kern_return_t task_set_special_port
#if	defined(LINTLIBRARY)
    (task, which_port, special_port)
	task_t task;
	int which_port;
	port_t special_port;
{ return task_set_special_port(task, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int which_port,
	port_t special_port
);
#else
    ();
#endif
#endif

/* Routine task_info */
mig_external kern_return_t task_info
#if	defined(LINTLIBRARY)
    (target_task, flavor, task_info_out, task_info_outCnt)
	task_t target_task;
	int flavor;
	task_info_t task_info_out;
	unsigned int *task_info_outCnt;
{ return task_info(target_task, flavor, task_info_out, task_info_outCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_task,
	int flavor,
	task_info_t task_info_out,
	unsigned int *task_info_outCnt
);
#else
    ();
#endif
#endif

/* Routine thread_create */
mig_external kern_return_t thread_create
#if	defined(LINTLIBRARY)
    (parent_task, child_thread)
	task_t parent_task;
	thread_t *child_thread;
{ return thread_create(parent_task, child_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t parent_task,
	thread_t *child_thread
);
#else
    ();
#endif
#endif

/* Routine thread_suspend */
mig_external kern_return_t thread_suspend
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_suspend(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine thread_resume */
mig_external kern_return_t thread_resume
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_resume(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine thread_abort */
mig_external kern_return_t thread_abort
#if	defined(LINTLIBRARY)
    (target_thread)
	thread_t target_thread;
{ return thread_abort(target_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread
);
#else
    ();
#endif
#endif

/* Routine thread_get_state */
mig_external kern_return_t thread_get_state
#if	defined(LINTLIBRARY)
    (target_thread, flavor, old_state, old_stateCnt)
	thread_t target_thread;
	int flavor;
	thread_state_t old_state;
	unsigned int *old_stateCnt;
{ return thread_get_state(target_thread, flavor, old_state, old_stateCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_state_t old_state,
	unsigned int *old_stateCnt
);
#else
    ();
#endif
#endif

/* Routine thread_set_state */
mig_external kern_return_t thread_set_state
#if	defined(LINTLIBRARY)
    (target_thread, flavor, new_state, new_stateCnt)
	thread_t target_thread;
	int flavor;
	thread_state_t new_state;
	unsigned int new_stateCnt;
{ return thread_set_state(target_thread, flavor, new_state, new_stateCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_state_t new_state,
	unsigned int new_stateCnt
);
#else
    ();
#endif
#endif

/* Routine thread_get_special_port */
mig_external kern_return_t thread_get_special_port
#if	defined(LINTLIBRARY)
    (thread, which_port, special_port)
	thread_t thread;
	int which_port;
	port_t *special_port;
{ return thread_get_special_port(thread, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int which_port,
	port_t *special_port
);
#else
    ();
#endif
#endif

/* Routine thread_set_special_port */
mig_external kern_return_t thread_set_special_port
#if	defined(LINTLIBRARY)
    (thread, which_port, special_port)
	thread_t thread;
	int which_port;
	port_t special_port;
{ return thread_set_special_port(thread, which_port, special_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int which_port,
	port_t special_port
);
#else
    ();
#endif
#endif

/* Routine thread_info */
mig_external kern_return_t thread_info
#if	defined(LINTLIBRARY)
    (target_thread, flavor, thread_info_out, thread_info_outCnt)
	thread_t target_thread;
	int flavor;
	thread_info_t thread_info_out;
	unsigned int *thread_info_outCnt;
{ return thread_info(target_thread, flavor, thread_info_out, thread_info_outCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t target_thread,
	int flavor,
	thread_info_t thread_info_out,
	unsigned int *thread_info_outCnt
);
#else
    ();
#endif
#endif

/* Routine task_set_emulation */
mig_external kern_return_t task_set_emulation
#if	defined(LINTLIBRARY)
    (target_port, routine_entry_pt, routine_number)
	task_t target_port;
	vm_address_t routine_entry_pt;
	int routine_number;
{ return task_set_emulation(target_port, routine_entry_pt, routine_number); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t target_port,
	vm_address_t routine_entry_pt,
	int routine_number
);
#else
    ();
#endif
#endif

/* Routine port_names */
mig_external kern_return_t port_names
#if	defined(LINTLIBRARY)
    (task, port_names_p, port_names_pCnt, port_types, port_typesCnt)
	task_t task;
	port_name_array_t *port_names_p;
	unsigned int *port_names_pCnt;
	port_type_array_t *port_types;
	unsigned int *port_typesCnt;
{ return port_names(task, port_names_p, port_names_pCnt, port_types, port_typesCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_array_t *port_names_p,
	unsigned int *port_names_pCnt,
	port_type_array_t *port_types,
	unsigned int *port_typesCnt
);
#else
    ();
#endif
#endif

/* Routine port_type */
mig_external kern_return_t port_type
#if	defined(LINTLIBRARY)
    (task, port_name, port_type_p)
	task_t task;
	port_name_t port_name;
	port_type_t *port_type_p;
{ return port_type(task, port_name, port_type_p); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_type_t *port_type_p
);
#else
    ();
#endif
#endif

/* Routine port_rename */
mig_external kern_return_t port_rename
#if	defined(LINTLIBRARY)
    (task, old_name, new_name)
	task_t task;
	port_name_t old_name;
	port_name_t new_name;
{ return port_rename(task, old_name, new_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t old_name,
	port_name_t new_name
);
#else
    ();
#endif
#endif

/* Routine port_allocate */
mig_external kern_return_t port_allocate
#if	defined(LINTLIBRARY)
    (task, port_name)
	task_t task;
	port_name_t *port_name;
{ return port_allocate(task, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t *port_name
);
#else
    ();
#endif
#endif

/* Routine port_deallocate */
mig_external kern_return_t port_deallocate
#if	defined(LINTLIBRARY)
    (task, port_name)
	task_t task;
	port_name_t port_name;
{ return port_deallocate(task, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name
);
#else
    ();
#endif
#endif

/* Routine port_set_backlog */
mig_external kern_return_t port_set_backlog
#if	defined(LINTLIBRARY)
    (task, port_name, backlog)
	task_t task;
	port_name_t port_name;
	int backlog;
{ return port_set_backlog(task, port_name, backlog); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	int backlog
);
#else
    ();
#endif
#endif

/* Routine port_status */
mig_external kern_return_t port_status
#if	defined(LINTLIBRARY)
    (task, port_name, enabled, num_msgs, backlog, ownership, receive_rights)
	task_t task;
	port_name_t port_name;
	port_set_name_t *enabled;
	int *num_msgs;
	int *backlog;
	boolean_t *ownership;
	boolean_t *receive_rights;
{ return port_status(task, port_name, enabled, num_msgs, backlog, ownership, receive_rights); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_set_name_t *enabled,
	int *num_msgs,
	int *backlog,
	boolean_t *ownership,
	boolean_t *receive_rights
);
#else
    ();
#endif
#endif

/* Routine port_set_allocate */
mig_external kern_return_t port_set_allocate
#if	defined(LINTLIBRARY)
    (task, set_name)
	task_t task;
	port_set_name_t *set_name;
{ return port_set_allocate(task, set_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t *set_name
);
#else
    ();
#endif
#endif

/* Routine port_set_deallocate */
mig_external kern_return_t port_set_deallocate
#if	defined(LINTLIBRARY)
    (task, set_name)
	task_t task;
	port_set_name_t set_name;
{ return port_set_deallocate(task, set_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name
);
#else
    ();
#endif
#endif

/* Routine port_set_add */
mig_external kern_return_t port_set_add
#if	defined(LINTLIBRARY)
    (task, set_name, port_name)
	task_t task;
	port_set_name_t set_name;
	port_name_t port_name;
{ return port_set_add(task, set_name, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name,
	port_name_t port_name
);
#else
    ();
#endif
#endif

/* Routine port_set_remove */
mig_external kern_return_t port_set_remove
#if	defined(LINTLIBRARY)
    (task, port_name)
	task_t task;
	port_name_t port_name;
{ return port_set_remove(task, port_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name
);
#else
    ();
#endif
#endif

/* Routine port_set_status */
mig_external kern_return_t port_set_status
#if	defined(LINTLIBRARY)
    (task, set_name, members, membersCnt)
	task_t task;
	port_set_name_t set_name;
	port_name_array_t *members;
	unsigned int *membersCnt;
{ return port_set_status(task, set_name, members, membersCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_set_name_t set_name,
	port_name_array_t *members,
	unsigned int *membersCnt
);
#else
    ();
#endif
#endif

/* Routine port_insert_send */
mig_external kern_return_t port_insert_send
#if	defined(LINTLIBRARY)
    (task, my_port, his_name)
	task_t task;
	port_t my_port;
	port_name_t his_name;
{ return port_insert_send(task, my_port, his_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_t my_port,
	port_name_t his_name
);
#else
    ();
#endif
#endif

/* Routine port_extract_send */
mig_external kern_return_t port_extract_send
#if	defined(LINTLIBRARY)
    (task, his_name, his_port)
	task_t task;
	port_name_t his_name;
	port_t *his_port;
{ return port_extract_send(task, his_name, his_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t his_name,
	port_t *his_port
);
#else
    ();
#endif
#endif

/* Routine port_insert_receive */
mig_external kern_return_t port_insert_receive
#if	defined(LINTLIBRARY)
    (task, my_port, his_name)
	task_t task;
	port_t my_port;
	port_name_t his_name;
{ return port_insert_receive(task, my_port, his_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_t my_port,
	port_name_t his_name
);
#else
    ();
#endif
#endif

/* Routine port_extract_receive */
mig_external kern_return_t port_extract_receive
#if	defined(LINTLIBRARY)
    (task, his_name, his_port)
	task_t task;
	port_name_t his_name;
	port_t *his_port;
{ return port_extract_receive(task, his_name, his_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t his_name,
	port_t *his_port
);
#else
    ();
#endif
#endif

/* Routine vm_map */
mig_external kern_return_t vm_map
#if	defined(LINTLIBRARY)
    (target_task, address, size, mask, anywhere, memory_object, offset, copy, cur_protection, max_protection, inheritance)
	vm_task_t target_task;
	vm_address_t *address;
	vm_size_t size;
	vm_address_t mask;
	boolean_t anywhere;
	memory_object_t memory_object;
	vm_offset_t offset;
	boolean_t copy;
	vm_prot_t cur_protection;
	vm_prot_t max_protection;
	vm_inherit_t inheritance;
{ return vm_map(target_task, address, size, mask, anywhere, memory_object, offset, copy, cur_protection, max_protection, inheritance); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t *address,
	vm_size_t size,
	vm_address_t mask,
	boolean_t anywhere,
	memory_object_t memory_object,
	vm_offset_t offset,
	boolean_t copy,
	vm_prot_t cur_protection,
	vm_prot_t max_protection,
	vm_inherit_t inheritance
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_error */
mig_external kern_return_t memory_object_data_error
#if	defined(LINTLIBRARY)
    (memory_control, offset, size, error_value)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	vm_size_t size;
	kern_return_t error_value;
{ return memory_object_data_error(memory_control, offset, size, error_value); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	vm_size_t size,
	kern_return_t error_value
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_set_attributes */
mig_external kern_return_t memory_object_set_attributes
#if	defined(LINTLIBRARY)
    (memory_control, object_ready, may_cache, copy_strategy)
	memory_object_control_t memory_control;
	boolean_t object_ready;
	boolean_t may_cache;
	memory_object_copy_strategy_t copy_strategy;
{ return memory_object_set_attributes(memory_control, object_ready, may_cache, copy_strategy); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	boolean_t object_ready,
	boolean_t may_cache,
	memory_object_copy_strategy_t copy_strategy
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_destroy */
mig_external kern_return_t memory_object_destroy
#if	defined(LINTLIBRARY)
    (memory_control, reason)
	memory_object_control_t memory_control;
	kern_return_t reason;
{ return memory_object_destroy(memory_control, reason); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	kern_return_t reason
);
#else
    ();
#endif
#endif

/* SimpleRoutine memory_object_data_supply */
mig_external kern_return_t memory_object_data_supply
#if	defined(LINTLIBRARY)
    (memory_control, offset, data, dataCnt, dealloc_data, lock_value, precious, reply_to)
	memory_object_control_t memory_control;
	vm_offset_t offset;
	pointer_t data;
	unsigned int dataCnt;
	boolean_t dealloc_data;
	vm_prot_t lock_value;
	boolean_t precious;
	port_t reply_to;
{ return memory_object_data_supply(memory_control, offset, data, dataCnt, dealloc_data, lock_value, precious, reply_to); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	memory_object_control_t memory_control,
	vm_offset_t offset,
	pointer_t data,
	unsigned int dataCnt,
	boolean_t dealloc_data,
	vm_prot_t lock_value,
	boolean_t precious,
	port_t reply_to
);
#else
    ();
#endif
#endif

/* Routine port_set_backup */
mig_external kern_return_t port_set_backup
#if	defined(LINTLIBRARY)
    (task, port_name, backup, previous)
	task_t task;
	port_name_t port_name;
	port_t backup;
	port_t *previous;
{ return port_set_backup(task, port_name, backup, previous); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	port_name_t port_name,
	port_t backup,
	port_t *previous
);
#else
    ();
#endif
#endif

/* Routine vm_machine_attribute */
mig_external kern_return_t vm_machine_attribute
#if	defined(LINTLIBRARY)
    (target_task, address, size, attribute, value)
	vm_task_t target_task;
	vm_address_t address;
	vm_size_t size;
	vm_machine_attribute_t attribute;
	vm_machine_attribute_val_t *value;
{ return vm_machine_attribute(target_task, address, size, attribute, value); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	vm_task_t target_task,
	vm_address_t address,
	vm_size_t size,
	vm_machine_attribute_t attribute,
	vm_machine_attribute_val_t *value
);
#else
    ();
#endif
#endif

#endif	_mach
@EOF@

echo "libmach/mach_debug_interface.h"
cat >libmach/mach_debug_interface.h <<'@EOF@'
#ifndef	_mach_debug
#define	_mach_debug

/* Module mach_debug */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_mach_debug
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>
#include <:mach:mach_types.h>
#include <:mach_debug:mach_debug_types.h>

/* Routine host_ipc_statistics */
mig_external kern_return_t host_ipc_statistics
#if	defined(LINTLIBRARY)
    (task, statistics)
	task_t task;
	ipc_statistics_t *statistics;
{ return host_ipc_statistics(task, statistics); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	ipc_statistics_t *statistics
);
#else
    ();
#endif
#endif

/* Routine host_ipc_statistics_reset */
mig_external kern_return_t host_ipc_statistics_reset
#if	defined(LINTLIBRARY)
    (task)
	task_t task;
{ return host_ipc_statistics_reset(task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task
);
#else
    ();
#endif
#endif

/* Routine host_callout_info */
mig_external kern_return_t host_callout_info
#if	defined(LINTLIBRARY)
    (task, info, infoCnt)
	task_t task;
	callout_info_array_t *info;
	unsigned int *infoCnt;
{ return host_callout_info(task, info, infoCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	callout_info_array_t *info,
	unsigned int *infoCnt
);
#else
    ();
#endif
#endif

/* Routine host_callout_statistics */
mig_external kern_return_t host_callout_statistics
#if	defined(LINTLIBRARY)
    (task, statistics)
	task_t task;
	callout_statistics_t *statistics;
{ return host_callout_statistics(task, statistics); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	callout_statistics_t *statistics
);
#else
    ();
#endif
#endif

/* Routine host_callout_statistics_reset */
mig_external kern_return_t host_callout_statistics_reset
#if	defined(LINTLIBRARY)
    (task)
	task_t task;
{ return host_callout_statistics_reset(task); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task
);
#else
    ();
#endif
#endif

/* Routine host_zone_info */
mig_external kern_return_t host_zone_info
#if	defined(LINTLIBRARY)
    (task, names, namesCnt, info, infoCnt)
	task_t task;
	zone_name_array_t *names;
	unsigned int *namesCnt;
	zone_info_array_t *info;
	unsigned int *infoCnt;
{ return host_zone_info(task, names, namesCnt, info, infoCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	zone_name_array_t *names,
	unsigned int *namesCnt,
	zone_info_array_t *info,
	unsigned int *infoCnt
);
#else
    ();
#endif
#endif

/* Routine host_ipc_bucket_info */
mig_external kern_return_t host_ipc_bucket_info
#if	defined(LINTLIBRARY)
    (task, TLinfo, TLinfoCnt, TPinfo, TPinfoCnt)
	task_t task;
	ipc_bucket_info_array_t *TLinfo;
	unsigned int *TLinfoCnt;
	ipc_bucket_info_array_t *TPinfo;
	unsigned int *TPinfoCnt;
{ return host_ipc_bucket_info(task, TLinfo, TLinfoCnt, TPinfo, TPinfoCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	ipc_bucket_info_array_t *TLinfo,
	unsigned int *TLinfoCnt,
	ipc_bucket_info_array_t *TPinfo,
	unsigned int *TPinfoCnt
);
#else
    ();
#endif
#endif

#endif	_mach_debug
@EOF@

echo "libmach/exc.h"
cat >libmach/exc.h <<'@EOF@'
#ifndef	_exc
#define	_exc

/* Module exc */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_exc
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>

/* Routine exception_raise */
mig_external kern_return_t exception_raise
#if	defined(LINTLIBRARY)
    (exception_port, clear_port, thread, task, exception, code, subcode)
	port_t exception_port;
	port_t clear_port;
	port_t thread;
	port_t task;
	int exception;
	int code;
	int subcode;
{ return exception_raise(exception_port, clear_port, thread, task, exception, code, subcode); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t exception_port,
	port_t clear_port,
	port_t thread,
	port_t task,
	int exception,
	int code,
	int subcode
);
#else
    ();
#endif
#endif

#endif	_exc
@EOF@

echo "libmach/ipcx.h"
cat >libmach/ipcx.h <<'@EOF@'
#ifndef	_ipcx
#define	_ipcx

/* Module ipcx */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_ipcx
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:servers:ipcx_types.h>

/* Routine startserver */
mig_external kern_return_t startserver
#if	defined(LINTLIBRARY)
    (mPort, userid, password, commandline, serverkport, serverdport)
	port_t mPort;
	a_string userid;
	a_string password;
	a_string commandline;
	port_t *serverkport;
	port_t *serverdport;
{ return startserver(mPort, userid, password, commandline, serverkport, serverdport); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t mPort,
	a_string userid,
	a_string password,
	a_string commandline,
	port_t *serverkport,
	port_t *serverdport
);
#else
    ();
#endif
#endif

#endif	_ipcx
@EOF@

echo "libmach/mach_host.h"
cat >libmach/mach_host.h <<'@EOF@'
#ifndef	_mach_host
#define	_mach_host

/* Module mach_host */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_mach_host
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>
#include <:mach:mach_types.h>

/* Routine host_processors */
mig_external kern_return_t host_processors
#if	defined(LINTLIBRARY)
    (host_priv, processor_list, processor_listCnt)
	host_priv_t host_priv;
	processor_array_t *processor_list;
	unsigned int *processor_listCnt;
{ return host_processors(host_priv, processor_list, processor_listCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host_priv,
	processor_array_t *processor_list,
	unsigned int *processor_listCnt
);
#else
    ();
#endif
#endif

/* Routine host_info */
mig_external kern_return_t host_info
#if	defined(LINTLIBRARY)
    (host, flavor, host_info_out, host_info_outCnt)
	host_t host;
	int flavor;
	host_info_t host_info_out;
	unsigned int *host_info_outCnt;
{ return host_info(host, flavor, host_info_out, host_info_outCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	int flavor,
	host_info_t host_info_out,
	unsigned int *host_info_outCnt
);
#else
    ();
#endif
#endif

/* Routine processor_info */
mig_external kern_return_t processor_info
#if	defined(LINTLIBRARY)
    (processor, flavor, host, processor_info_out, processor_info_outCnt)
	processor_t processor;
	int flavor;
	host_t *host;
	processor_info_t processor_info_out;
	unsigned int *processor_info_outCnt;
{ return processor_info(processor, flavor, host, processor_info_out, processor_info_outCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	int flavor,
	host_t *host,
	processor_info_t processor_info_out,
	unsigned int *processor_info_outCnt
);
#else
    ();
#endif
#endif

/* Routine processor_start */
mig_external kern_return_t processor_start
#if	defined(LINTLIBRARY)
    (processor)
	processor_t processor;
{ return processor_start(processor); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor
);
#else
    ();
#endif
#endif

/* Routine processor_exit */
mig_external kern_return_t processor_exit
#if	defined(LINTLIBRARY)
    (processor)
	processor_t processor;
{ return processor_exit(processor); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor
);
#else
    ();
#endif
#endif

/* Routine processor_control */
mig_external kern_return_t processor_control
#if	defined(LINTLIBRARY)
    (processor, processor_cmd, processor_cmdCnt)
	processor_t processor;
	processor_info_t processor_cmd;
	unsigned int processor_cmdCnt;
{ return processor_control(processor, processor_cmd, processor_cmdCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	processor_info_t processor_cmd,
	unsigned int processor_cmdCnt
);
#else
    ();
#endif
#endif

/* Routine processor_set_default */
mig_external kern_return_t processor_set_default
#if	defined(LINTLIBRARY)
    (host, default_set)
	host_t host;
	processor_set_name_t *default_set;
{ return processor_set_default(host, default_set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	processor_set_name_t *default_set
);
#else
    ();
#endif
#endif

/* Routine xxx_processor_set_default_priv */
mig_external kern_return_t xxx_processor_set_default_priv
#if	defined(LINTLIBRARY)
    (host, default_set)
	host_priv_t host;
	processor_set_t *default_set;
{ return xxx_processor_set_default_priv(host, default_set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host,
	processor_set_t *default_set
);
#else
    ();
#endif
#endif

/* Routine processor_set_create */
mig_external kern_return_t processor_set_create
#if	defined(LINTLIBRARY)
    (host, new_set, new_name)
	host_t host;
	processor_set_t *new_set;
	processor_set_name_t *new_name;
{ return processor_set_create(host, new_set, new_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	processor_set_t *new_set,
	processor_set_name_t *new_name
);
#else
    ();
#endif
#endif

/* Routine processor_set_destroy */
mig_external kern_return_t processor_set_destroy
#if	defined(LINTLIBRARY)
    (set)
	processor_set_t set;
{ return processor_set_destroy(set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t set
);
#else
    ();
#endif
#endif

/* Routine processor_set_info */
mig_external kern_return_t processor_set_info
#if	defined(LINTLIBRARY)
    (set_name, flavor, host, info_out, info_outCnt)
	processor_set_name_t set_name;
	int flavor;
	host_t *host;
	processor_set_info_t info_out;
	unsigned int *info_outCnt;
{ return processor_set_info(set_name, flavor, host, info_out, info_outCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_name_t set_name,
	int flavor,
	host_t *host,
	processor_set_info_t info_out,
	unsigned int *info_outCnt
);
#else
    ();
#endif
#endif

/* Routine processor_assign */
mig_external kern_return_t processor_assign
#if	defined(LINTLIBRARY)
    (processor, new_set, wait)
	processor_t processor;
	processor_set_t new_set;
	boolean_t wait;
{ return processor_assign(processor, new_set, wait); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	processor_set_t new_set,
	boolean_t wait
);
#else
    ();
#endif
#endif

/* Routine processor_get_assignment */
mig_external kern_return_t processor_get_assignment
#if	defined(LINTLIBRARY)
    (processor, assigned_set)
	processor_t processor;
	processor_set_name_t *assigned_set;
{ return processor_get_assignment(processor, assigned_set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_t processor,
	processor_set_name_t *assigned_set
);
#else
    ();
#endif
#endif

/* Routine thread_assign */
mig_external kern_return_t thread_assign
#if	defined(LINTLIBRARY)
    (thread, new_set)
	thread_t thread;
	processor_set_t new_set;
{ return thread_assign(thread, new_set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	processor_set_t new_set
);
#else
    ();
#endif
#endif

/* Routine thread_assign_default */
mig_external kern_return_t thread_assign_default
#if	defined(LINTLIBRARY)
    (thread)
	thread_t thread;
{ return thread_assign_default(thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread
);
#else
    ();
#endif
#endif

/* Routine thread_get_assignment */
mig_external kern_return_t thread_get_assignment
#if	defined(LINTLIBRARY)
    (thread, assigned_set)
	thread_t thread;
	processor_set_name_t *assigned_set;
{ return thread_get_assignment(thread, assigned_set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	processor_set_name_t *assigned_set
);
#else
    ();
#endif
#endif

/* Routine task_assign */
mig_external kern_return_t task_assign
#if	defined(LINTLIBRARY)
    (task, new_set, assign_threads)
	task_t task;
	processor_set_t new_set;
	boolean_t assign_threads;
{ return task_assign(task, new_set, assign_threads); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	processor_set_t new_set,
	boolean_t assign_threads
);
#else
    ();
#endif
#endif

/* Routine task_assign_default */
mig_external kern_return_t task_assign_default
#if	defined(LINTLIBRARY)
    (task, assign_threads)
	task_t task;
	boolean_t assign_threads;
{ return task_assign_default(task, assign_threads); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	boolean_t assign_threads
);
#else
    ();
#endif
#endif

/* Routine task_get_assignment */
mig_external kern_return_t task_get_assignment
#if	defined(LINTLIBRARY)
    (task, assigned_set)
	task_t task;
	processor_set_name_t *assigned_set;
{ return task_get_assignment(task, assigned_set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	processor_set_name_t *assigned_set
);
#else
    ();
#endif
#endif

/* Routine host_kernel_version */
mig_external kern_return_t host_kernel_version
#if	defined(LINTLIBRARY)
    (host, kernel_version)
	host_t host;
	kernel_version_t kernel_version;
{ return host_kernel_version(host, kernel_version); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	kernel_version_t kernel_version
);
#else
    ();
#endif
#endif

/* Routine thread_priority */
mig_external kern_return_t thread_priority
#if	defined(LINTLIBRARY)
    (thread, priority, set_max)
	thread_t thread;
	int priority;
	boolean_t set_max;
{ return thread_priority(thread, priority, set_max); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int priority,
	boolean_t set_max
);
#else
    ();
#endif
#endif

/* Routine thread_max_priority */
mig_external kern_return_t thread_max_priority
#if	defined(LINTLIBRARY)
    (thread, processor_set, max_priority)
	thread_t thread;
	processor_set_t processor_set;
	int max_priority;
{ return thread_max_priority(thread, processor_set, max_priority); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	processor_set_t processor_set,
	int max_priority
);
#else
    ();
#endif
#endif

/* Routine task_priority */
mig_external kern_return_t task_priority
#if	defined(LINTLIBRARY)
    (task, priority, change_threads)
	task_t task;
	int priority;
	boolean_t change_threads;
{ return task_priority(task, priority, change_threads); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t task,
	int priority,
	boolean_t change_threads
);
#else
    ();
#endif
#endif

/* Routine processor_set_max_priority */
mig_external kern_return_t processor_set_max_priority
#if	defined(LINTLIBRARY)
    (processor_set, max_priority, change_threads)
	processor_set_t processor_set;
	int max_priority;
	boolean_t change_threads;
{ return processor_set_max_priority(processor_set, max_priority, change_threads); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	int max_priority,
	boolean_t change_threads
);
#else
    ();
#endif
#endif

/* Routine thread_policy */
mig_external kern_return_t thread_policy
#if	defined(LINTLIBRARY)
    (thread, policy, data)
	thread_t thread;
	int policy;
	int data;
{ return thread_policy(thread, policy, data); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	thread_t thread,
	int policy,
	int data
);
#else
    ();
#endif
#endif

/* Routine processor_set_policy_enable */
mig_external kern_return_t processor_set_policy_enable
#if	defined(LINTLIBRARY)
    (processor_set, policy)
	processor_set_t processor_set;
	int policy;
{ return processor_set_policy_enable(processor_set, policy); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	int policy
);
#else
    ();
#endif
#endif

/* Routine processor_set_policy_disable */
mig_external kern_return_t processor_set_policy_disable
#if	defined(LINTLIBRARY)
    (processor_set, policy, change_threads)
	processor_set_t processor_set;
	int policy;
	boolean_t change_threads;
{ return processor_set_policy_disable(processor_set, policy, change_threads); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	int policy,
	boolean_t change_threads
);
#else
    ();
#endif
#endif

/* Routine processor_set_tasks */
mig_external kern_return_t processor_set_tasks
#if	defined(LINTLIBRARY)
    (processor_set, task_list, task_listCnt)
	processor_set_t processor_set;
	task_array_t *task_list;
	unsigned int *task_listCnt;
{ return processor_set_tasks(processor_set, task_list, task_listCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	task_array_t *task_list,
	unsigned int *task_listCnt
);
#else
    ();
#endif
#endif

/* Routine processor_set_threads */
mig_external kern_return_t processor_set_threads
#if	defined(LINTLIBRARY)
    (processor_set, thread_list, thread_listCnt)
	processor_set_t processor_set;
	thread_array_t *thread_list;
	unsigned int *thread_listCnt;
{ return processor_set_threads(processor_set, thread_list, thread_listCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	processor_set_t processor_set,
	thread_array_t *thread_list,
	unsigned int *thread_listCnt
);
#else
    ();
#endif
#endif

/* Routine host_processor_sets */
mig_external kern_return_t host_processor_sets
#if	defined(LINTLIBRARY)
    (host, processor_sets, processor_setsCnt)
	host_t host;
	processor_set_name_array_t *processor_sets;
	unsigned int *processor_setsCnt;
{ return host_processor_sets(host, processor_sets, processor_setsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_t host,
	processor_set_name_array_t *processor_sets,
	unsigned int *processor_setsCnt
);
#else
    ();
#endif
#endif

/* Routine host_processor_set_priv */
mig_external kern_return_t host_processor_set_priv
#if	defined(LINTLIBRARY)
    (host_priv, set_name, set)
	host_priv_t host_priv;
	processor_set_name_t set_name;
	processor_set_t *set;
{ return host_processor_set_priv(host_priv, set_name, set); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	host_priv_t host_priv,
	processor_set_name_t set_name,
	processor_set_t *set
);
#else
    ();
#endif
#endif

#endif	_mach_host
@EOF@

echo "libmach/monitor.h"
cat >libmach/monitor.h <<'@EOF@'
#ifndef	_monitor
#define	_monitor

/* Module monitor */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_monitor
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>
#include <:mach:mach_types.h>
#include <:mach:kernel_event.h>

/* Routine monitor_create */
mig_external kern_return_t monitor_create
#if	defined(LINTLIBRARY)
    (this_task, new_monitor, requested_size)
	task_t this_task;
	monitor_t *new_monitor;
	int *requested_size;
{ return monitor_create(this_task, new_monitor, requested_size); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	task_t this_task,
	monitor_t *new_monitor,
	int *requested_size
);
#else
    ();
#endif
#endif

/* Routine monitor_terminate */
mig_external kern_return_t monitor_terminate
#if	defined(LINTLIBRARY)
    (this_monitor)
	monitor_t this_monitor;
{ return monitor_terminate(this_monitor); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor
);
#else
    ();
#endif
#endif

/* Routine monitor_resume */
mig_external kern_return_t monitor_resume
#if	defined(LINTLIBRARY)
    (this_monitor)
	monitor_t this_monitor;
{ return monitor_resume(this_monitor); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor
);
#else
    ();
#endif
#endif

/* Routine monitor_suspend */
mig_external kern_return_t monitor_suspend
#if	defined(LINTLIBRARY)
    (this_monitor)
	monitor_t this_monitor;
{ return monitor_suspend(this_monitor); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor
);
#else
    ();
#endif
#endif

/* Routine thread_monitor */
mig_external kern_return_t thread_monitor
#if	defined(LINTLIBRARY)
    (this_monitor, monitor_id, this_thread)
	monitor_t this_monitor;
	int monitor_id;
	thread_t this_thread;
{ return thread_monitor(this_monitor, monitor_id, this_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor,
	int monitor_id,
	thread_t this_thread
);
#else
    ();
#endif
#endif

/* Routine thread_unmonitor */
mig_external kern_return_t thread_unmonitor
#if	defined(LINTLIBRARY)
    (this_monitor, this_thread)
	monitor_t this_monitor;
	thread_t this_thread;
{ return thread_unmonitor(this_monitor, this_thread); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor,
	thread_t this_thread
);
#else
    ();
#endif
#endif

/* Routine monitor_read */
mig_external kern_return_t monitor_read
#if	defined(LINTLIBRARY)
    (this_monitor, buffer, bufferCnt)
	monitor_t this_monitor;
	kern_mon_buffer_t buffer;
	unsigned int *bufferCnt;
{ return monitor_read(this_monitor, buffer, bufferCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	monitor_t this_monitor,
	kern_mon_buffer_t buffer,
	unsigned int *bufferCnt
);
#else
    ();
#endif
#endif

#endif	_monitor
@EOF@

echo "libmach/netmemstat.h"
cat >libmach/netmemstat.h <<'@EOF@'
#ifndef	_netmemstat
#define	_netmemstat

/* Module netmemstat */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_netmemstat
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:mach_types.h>
#include "netmemory_defs.h"

/* Routine paging_object_statistics */
mig_external kern_return_t paging_object_statistics
#if	defined(LINTLIBRARY)
    (paging_object, faults_per_page, faults_per_pageCnt, faults_total, faults_totalCnt)
	port_t paging_object;
	pointer_t *faults_per_page;
	unsigned int *faults_per_pageCnt;
	pointer_t *faults_total;
	unsigned int *faults_totalCnt;
{ return paging_object_statistics(paging_object, faults_per_page, faults_per_pageCnt, faults_total, faults_totalCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t paging_object,
	pointer_t *faults_per_page,
	unsigned int *faults_per_pageCnt,
	pointer_t *faults_total,
	unsigned int *faults_totalCnt
);
#else
    ();
#endif
#endif

#endif	_netmemstat
@EOF@

echo "libmach/env_mgr.h"
cat >libmach/env_mgr.h <<'@EOF@'
#ifndef	_env_mgr
#define	_env_mgr

/* Module env_mgr */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_env_mgr
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>
#include <:servers:emdefs.h>

/* Routine env_set_string */
mig_external kern_return_t env_set_string
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	env_str_val_t env_val;
{ return env_set_string(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	env_str_val_t env_val
);
#else
    ();
#endif
#endif

/* Routine env_get_string */
mig_external kern_return_t env_get_string
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	env_str_val_t env_val;
{ return env_get_string(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	env_str_val_t env_val
);
#else
    ();
#endif
#endif

/* Routine env_del_string */
mig_external kern_return_t env_del_string
#if	defined(LINTLIBRARY)
    (port, env_name)
	port_t port;
	env_name_t env_name;
{ return env_del_string(port, env_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name
);
#else
    ();
#endif
#endif

/* Routine env_set_port */
mig_external kern_return_t env_set_port
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	port_t env_val;
{ return env_set_port(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	port_t env_val
);
#else
    ();
#endif
#endif

/* Routine env_get_port */
mig_external kern_return_t env_get_port
#if	defined(LINTLIBRARY)
    (port, env_name, env_val)
	port_t port;
	env_name_t env_name;
	port_t *env_val;
{ return env_get_port(port, env_name, env_val); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name,
	port_t *env_val
);
#else
    ();
#endif
#endif

/* Routine env_del_port */
mig_external kern_return_t env_del_port
#if	defined(LINTLIBRARY)
    (port, env_name)
	port_t port;
	env_name_t env_name;
{ return env_del_port(port, env_name); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_t env_name
);
#else
    ();
#endif
#endif

/* Routine env_list_strings */
mig_external kern_return_t env_list_strings
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt)
	port_t port;
	env_name_list *env_names;
	unsigned int *env_namesCnt;
	env_str_list *env_string_vals;
	unsigned int *env_string_valsCnt;
{ return env_list_strings(port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list *env_names,
	unsigned int *env_namesCnt,
	env_str_list *env_string_vals,
	unsigned int *env_string_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_list_ports */
mig_external kern_return_t env_list_ports
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt)
	port_t port;
	env_name_list *env_names;
	unsigned int *env_namesCnt;
	port_array_t *env_ports_vals;
	unsigned int *env_ports_valsCnt;
{ return env_list_ports(port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list *env_names,
	unsigned int *env_namesCnt,
	port_array_t *env_ports_vals,
	unsigned int *env_ports_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_set_stlist */
mig_external kern_return_t env_set_stlist
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt)
	port_t port;
	env_name_list env_names;
	unsigned int env_namesCnt;
	env_str_list env_string_vals;
	unsigned int env_string_valsCnt;
{ return env_set_stlist(port, env_names, env_namesCnt, env_string_vals, env_string_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list env_names,
	unsigned int env_namesCnt,
	env_str_list env_string_vals,
	unsigned int env_string_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_set_ptlist */
mig_external kern_return_t env_set_ptlist
#if	defined(LINTLIBRARY)
    (port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt)
	port_t port;
	env_name_list env_names;
	unsigned int env_namesCnt;
	port_array_t env_ports_vals;
	unsigned int env_ports_valsCnt;
{ return env_set_ptlist(port, env_names, env_namesCnt, env_ports_vals, env_ports_valsCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	env_name_list env_names,
	unsigned int env_namesCnt,
	port_array_t env_ports_vals,
	unsigned int env_ports_valsCnt
);
#else
    ();
#endif
#endif

/* Routine env_copy_conn */
mig_external kern_return_t env_copy_conn
#if	defined(LINTLIBRARY)
    (port, new_env_port)
	port_t port;
	port_t *new_env_port;
{ return env_copy_conn(port, new_env_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
);
#else
    ();
#endif
#endif

/* Routine env_new_conn */
mig_external kern_return_t env_new_conn
#if	defined(LINTLIBRARY)
    (port, new_env_port)
	port_t port;
	port_t *new_env_port;
{ return env_new_conn(port, new_env_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
);
#else
    ();
#endif
#endif

/* Routine env_restrict_conn */
mig_external kern_return_t env_restrict_conn
#if	defined(LINTLIBRARY)
    (port, new_env_port)
	port_t port;
	port_t *new_env_port;
{ return env_restrict_conn(port, new_env_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port,
	port_t *new_env_port
);
#else
    ();
#endif
#endif

/* Routine env_disconnect */
mig_external kern_return_t env_disconnect
#if	defined(LINTLIBRARY)
    (port)
	port_t port;
{ return env_disconnect(port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t port
);
#else
    ();
#endif
#endif

#endif	_env_mgr
@EOF@

echo "libmach/netmemory_defs.h"
cat >libmach/netmemory_defs.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	netmemory_defs.h,v $
 * Revision 1.1  90/02/19  21:48:21  bww
 * 	Mach Release 2.5
 * 	[90/02/19  21:47:02  bww]
 * 
 * Revision 1.3  89/08/24  17:46:18  mrt
 * 	Cleanup
 * 
 * Revision 1.2  89/04/29  13:22:14  mrt
 * 	Clean up for Mach 2.5. Inlcuded servers/errorlib.h to define
 * 	errorcode base.
 * 	[89/04/29            mrt]
 * 
 */
/*
 *	File:	netmemory_defs.h
 *	Author:	Joseph S. Barrera III
 *
 *	Copyright (C) 1989, Joseph S. Barrera III
 *
 *	C definitions for netmemory mig interface.
 *
 */

#ifndef	NETMEMORY_DEFS
#define	NETMEMORY_DEFS		1

#include <:mach:error.h>
#include <:servers:errorlib.h>


#define	NETMEMORY_SUCCESS		ERR_SUCCESS
#define NETMEMORY_INVALID_ARGUMENT	(SERV_NETMEMORY_MOD | 0x1)
#define	NETMEMORY_RESOURCE_SHORTAGE	(SERV_NETMEMORY_MOD | 0x2)

typedef mach_error_t netmemory_return_t;

typedef struct fault_info {
    int read_faults;
    int write_faults;
    int protection_faults;
} fault_info_t;

#endif	/* NETMEMORY_DEFS */
@EOF@

echo "libmach/netmemory.h"
cat >libmach/netmemory.h <<'@EOF@'
#ifndef	_netmemory
#define	_netmemory

/* Module netmemory */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_netmemory
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:mach_types.h>
#include "netmemory_defs.h"

/* Routine netmemory_create */
mig_external kern_return_t netmemory_create
#if	defined(LINTLIBRARY)
    (server_port, object_size, paging_object, control_port)
	port_t server_port;
	vm_size_t object_size;
	port_t *paging_object;
	port_t *control_port;
{ return netmemory_create(server_port, object_size, paging_object, control_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	vm_size_t object_size,
	port_t *paging_object,
	port_t *control_port
);
#else
    ();
#endif
#endif

/* Routine netmemory_destroy */
mig_external kern_return_t netmemory_destroy
#if	defined(LINTLIBRARY)
    (control_port)
	port_t control_port;
{ return netmemory_destroy(control_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t control_port
);
#else
    ();
#endif
#endif

/* Routine netmemory_cache */
mig_external kern_return_t netmemory_cache
#if	defined(LINTLIBRARY)
    (server_port, paging_object, local_paging_object)
	port_t server_port;
	port_t paging_object;
	port_t *local_paging_object;
{ return netmemory_cache(server_port, paging_object, local_paging_object); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	port_t paging_object,
	port_t *local_paging_object
);
#else
    ();
#endif
#endif

/* Routine paging_object_server_statistics */
mig_external kern_return_t paging_object_server_statistics
#if	defined(LINTLIBRARY)
    (object_server, rusage, rusageCnt, faults_total, faults_totalCnt)
	port_t object_server;
	pointer_t *rusage;
	unsigned int *rusageCnt;
	pointer_t *faults_total;
	unsigned int *faults_totalCnt;
{ return paging_object_server_statistics(object_server, rusage, rusageCnt, faults_total, faults_totalCnt); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t object_server,
	pointer_t *rusage,
	unsigned int *rusageCnt,
	pointer_t *faults_total,
	unsigned int *faults_totalCnt
);
#else
    ();
#endif
#endif

/* Routine netmemory_cover */
mig_external kern_return_t netmemory_cover
#if	defined(LINTLIBRARY)
    (server_port, object_data, object_dataCnt, paging_object, control_port)
	port_t server_port;
	pointer_t object_data;
	unsigned int object_dataCnt;
	port_t *paging_object;
	port_t *control_port;
{ return netmemory_cover(server_port, object_data, object_dataCnt, paging_object, control_port); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	pointer_t object_data,
	unsigned int object_dataCnt,
	port_t *paging_object,
	port_t *control_port
);
#else
    ();
#endif
#endif

#endif	_netmemory
@EOF@

echo "libmach/netname.h"
cat >libmach/netname.h <<'@EOF@'
#ifndef	_netname
#define	_netname

/* Module netname */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_netname
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include "netname_defs.h"

/* Routine netname_check_in */
mig_external kern_return_t netname_check_in
#if	defined(LINTLIBRARY)
    (server_port, port_name, signature, port_id)
	port_t server_port;
	netname_name_t port_name;
	port_t signature;
	port_t port_id;
{ return netname_check_in(server_port, port_name, signature, port_id); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t port_name,
	port_t signature,
	port_t port_id
);
#else
    ();
#endif
#endif

/* Routine netname_look_up */
mig_external kern_return_t netname_look_up
#if	defined(LINTLIBRARY)
    (server_port, host_name, port_name, port_id)
	port_t server_port;
	netname_name_t host_name;
	netname_name_t port_name;
	port_t *port_id;
{ return netname_look_up(server_port, host_name, port_name, port_id); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t host_name,
	netname_name_t port_name,
	port_t *port_id
);
#else
    ();
#endif
#endif

/* Routine netname_check_out */
mig_external kern_return_t netname_check_out
#if	defined(LINTLIBRARY)
    (server_port, port_name, signature)
	port_t server_port;
	netname_name_t port_name;
	port_t signature;
{ return netname_check_out(server_port, port_name, signature); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t port_name,
	port_t signature
);
#else
    ();
#endif
#endif

/* Routine netname_version */
mig_external kern_return_t netname_version
#if	defined(LINTLIBRARY)
    (server_port, version)
	port_t server_port;
	netname_name_t version;
{ return netname_version(server_port, version); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t server_port,
	netname_name_t version
);
#else
    ();
#endif
#endif

#endif	_netname
@EOF@

echo "libmach/netname_defs.h"
cat >libmach/netname_defs.h <<'@EOF@'
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * $Log:	netname_defs.h,v $
 * Revision 1.1  90/02/19  21:53:40  bww
 * 	Mach Release 2.5
 * 	[90/02/19  21:47:02  bww]
 * 
 * Revision 1.7  89/05/02  11:13:45  dpj
 * 	Fixed all files to conform to standard copyright/log format
 * 
 * 28-Jul-88  Mary R. Thompson (mrt) at Carnegie Mellon
 *	Copied definitions of NAME_NOT_YOURS and NAME_NOT_CHECKED_IN
 *	from the old netname_defs.h so that old code would not break
 *
 *  8-Mar-88  Daniel Julin (dpj) at Carnegie-Mellon University
 *	Added NETNAME_INVALID_PORT.
 *
 * 28-Feb-88  Daniel Julin (dpj) at Carnegie-Mellon University
 *	Added NETNAME_PENDING.
 *
 * 23-Dec-86  Robert Sansom (rds) at Carnegie Mellon University
 *	Copied from the previous version of the network server.
 *
 */
/*
 * netname_defs.h
 *
 *
 * $ Header: netname_defs.h,v 1.7 89/05/02 11:13:45 dpj Exp $
 *
 */

/*
 * Definitions for the mig interface to the network name service.
 */


#ifndef	_NETNAME_DEFS_
#define	_NETNAME_DEFS_

#define NETNAME_SUCCESS		(0)
#define	NETNAME_PENDING		(-1)
#define NETNAME_NOT_YOURS	(1000)
#define NAME_NOT_YOURS		(1000)
#define NETNAME_NOT_CHECKED_IN	(1001)
#define NAME_NOT_CHECKED_IN	(1001)
#define NETNAME_NO_SUCH_HOST	(1002)
#define NETNAME_HOST_NOT_FOUND	(1003)
#define	NETNAME_INVALID_PORT	(1004)

typedef char netname_name_t[80];

#endif /* NETNAME_DEFS_ */
@EOF@

echo "libmach/service.h"
cat >libmach/service.h <<'@EOF@'
#ifndef	_service
#define	_service

/* Module service */

#include <:mach:kern_return.h>
#if	(defined(__STDC__) || defined(c_plusplus)) || defined(LINTLIBRARY)
#include <:mach:port.h>
#include <:mach:message.h>
#endif

#ifndef	mig_external
#define mig_external extern
#endif

mig_external void init_service
#if	(defined(__STDC__) || defined(c_plusplus))
    (port_t rep_port);
#else
    ();
#endif
#include <:mach:std_types.h>

/* Routine old_service_checkin */
mig_external kern_return_t old_service_checkin
#if	defined(LINTLIBRARY)
    (service_request, service_desired, service_granted)
	port_t service_request;
	port_t service_desired;
	port_t *service_granted;
{ return old_service_checkin(service_request, service_desired, service_granted); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t service_request,
	port_t service_desired,
	port_t *service_granted
);
#else
    ();
#endif
#endif

/* Routine service_checkin */
mig_external kern_return_t service_checkin
#if	defined(LINTLIBRARY)
    (service_request, service_desired, service_granted)
	port_t service_request;
	port_t service_desired;
	port_t *service_granted;
{ return service_checkin(service_request, service_desired, service_granted); }
#else
#if	(defined(__STDC__) || defined(c_plusplus))
(
	port_t service_request,
	port_t service_desired,
	port_t *service_granted
);
#else
    ();
#endif
#endif

#endif	_service
@EOF@

