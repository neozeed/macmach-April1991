\&
.sp 1
.ce 3
\s+1\fBChapter 8\fP\s-1

\s+1\fBEvents and Event-Handling Functions\fP\s-1
.sp 2
.nr H1 8
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.na
.LP
.XS
Chapter 8: Events and Event-Handling Functions 
.XE
A client application communicates with the X server through the connection you
establish with the 
.PN XOpenDisplay 
.IN "XOpenDisplay"
function.
A client application sends requests to the X server over this connection.
.IN "Requests" "" "@DEF@"
These requests are made by the Xlib functions that are 
called in the client application.
Many Xlib functions cause the X server to generate events,
and the user's typing or moving the pointer can generate events asynchronously.
The X server returns events to the client on the same connection.
.LP
This chapter begins with a discussion of the following topics associated with
events:
.IP \(bu 5
Event types
.IP \(bu 5
Event structures
.IP \(bu 5
Event mask
.IP \(bu 5
Event processing
.LP
It then discusses the Xlib functions you can use to:
.IP \(bu 5
Select events
.IP \(bu 5
Handle the output buffer and the event queue
.IP \(bu 5
Select events from the event queue 
.IP \(bu 5
Send and get events
.IP \(bu 5
Handle error events
.LE
.RE
.NT
Some toolkits use their own event-handling functions
and do not allow you to interchange these event-handling functions
with those in Xlib.
For further information, 
see the documentation supplied with the toolkit.
.NE
.LP
Most applications simply are event loops:
they wait for an event, decide what to do with it,
execute some amount of code that results in changes to the display,
and then wait for the next event.
.NH 2
Event Types
.XS
\*(SN Event Types 
.XE
.LP
.IN "Event" "types"
An event is data generated asynchronously by the X server as a result of some 
device activity or as side effects of a request sent by an Xlib function.
.IN "Event" 
Device-related events propagate from the source window to ancestor windows
until some client application has selected that event type 
or until the event is explicitly discarded.
The X server generally sends an event to a client application
only if the client has specifically asked to be informed of that event type, 
typically by setting the event-mask attribute of the window.
The mask can also be set when you create a window
or by changing the window's
event-mask.
You can also mask out events that would propagate to ancestor windows
by manipulating the
do-not-propagate mask of the window's attributes.
However,
.PN MappingNotify
events are always sent to all clients.
.IN "Input Control"
.IN "Output Control"
.LP
An event type describes a specific event generated by the X server.
For each event type, 
a corresponding constant name is defined in
.Pn < X11/X.h >,
which is used when referring to an event type.
.IN "Event" "categories"
The following table lists the event category 
and its associated event type or types. 
The processing associated with these events is discussed in section 8.4.
.LP
.\".CP T 1
.\"Event Categories and Event Types
.LP
.TS H
lw(2.25i) lw(3.5i).
_
.sp 6p
.TB
Event Category	Event Type
.sp 6p
_
.sp 6p
.TH
.R
T{
Keyboard events
T}	T{
.PN KeyPress ,
.PN KeyRelease
T}
.sp 6p
T{
Pointer events
T}	T{
.PN ButtonPress , 
.PN ButtonRelease  ,
.PN MotionNotify
T}
.sp 6p
T{
Window crossing events
T}	T{
.PN EnterNotify , 
.PN LeaveNotify
T}
.sp 6p
T{
Input focus events
T}	T{
.PN FocusIn , 
.PN FocusOut
T}
.sp 6p
T{
Keymap state notification event
T}	T{
.PN KeymapNotify
T}
.sp 6p
T{
Exposure events	
T}	T{
.PN Expose , 
.PN GraphicsExpose , 
.PN NoExpose
T}
.sp 6p
T{
Structure control events
T}	T{
.PN CirculateRequest , 
.PN ConfigureRequest , 
.PN MapRequest ,
.PN ResizeRequest
T}
.sp 6p
T{
Window state notification events
T}	T{
.PN CirculateNotify , 
.PN ConfigureNotify , 
.PN CreateNotify , 
.PN DestroyNotify , 
.PN GravityNotify , 
.PN MapNotify ,
.PN MappingNotify , 
.PN ReparentNotify , 
.PN UnmapNotify , 
.PN VisibilityNotify
T}
.sp 6p
T{
Colormap state notification event
T}	T{
.PN ColormapNotify
T}
.sp 6p
T{
Client communication events
T}	T{
.PN ClientMessage , 
.PN PropertyNotify , 
.PN SelectionClear , 
.PN SelectionNotify , 
.PN SelectionRequest
T}
.sp 6p
_
.TE
.\".LP
.\"Table 8-1 lists the event types and the Xlib functions that could cause
.\"the X server to generate that event type.
.\"The event types are listed alphabetically.
.\"Note that the error event is not listed in this table.
.\"For a list of the constants associated with an error event, see the Handling
.\"Errors section in this chapter.
.\".LP
.\".so eventtable
.NH 2
Event Structures
.XS
\*(SN Event Structures 
.XE
.LP
For each event type,
a corresponding structure is declared in
.Pn < X11/Xlib.h >.
All the event structures have the following common members:
.LP
.IN "XAnyEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
} XAnyEvent;
.De
.LP
The type member is set to the event type constant name that uniquely identifies
it.
For example, when the X server reports a
.PN GraphicsExpose
event to a client application, it sends an
.PN XGraphicsExposeEvent
structure with the type member set to
.PN GraphicsExpose .
The display member is set to a pointer to the display the event was read on.
The send_event member is set to
.PN True
if the event came from a
.PN SendEvent
protocol request.
The serial member is set from the serial number reported in the protocol
but expanded from the 16-bit least-significant bits to a full 32-bit value.
The window member is set to the window that is most useful to toolkit
dispatchers.
.LP
The X server can send events at any time in the input stream. 
Xlib stores any events received while waiting for a reply in an event queue 
for later use.
Xlib also provides functions that allow you to check events 
in the event queue (see section 8.7).
.LP
In addition to the individual structures declared for each event type, the
.PN XEvent
structure is a union of the individual structures declared for each event type.
Depending on the type,
you should access members of each event by using the 
.PN XEvent
union.
.LP
.IN "XEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef union _XEvent {
	int type;	/* must not be changed */
	XAnyEvent xany;
	XKeyEvent xkey;
	XButtonEvent xbutton;
	XMotionEvent xmotion;
	XCrossingEvent xcrossing;
	XFocusChangeEvent xfocus;
	XExposeEvent xexpose;
	XGraphicsExposeEvent xgraphicsexpose;
	XNoExposeEvent xnoexpose;
	XVisibilityEvent xvisibility;
	XCreateWindowEvent xcreatewindow;
	XDestroyWindowEvent xdestroywindow;
	XUnmapEvent xunmap;
	XMapEvent xmap;
	XMapRequestEvent xmaprequest;
	XReparentEvent xreparent;
	XConfigureEvent xconfigure;
	XGravityEvent xgravity;
	XResizeRequestEvent xresizerequest;
	XConfigureRequestEvent xconfigurerequest;
	XCirculateEvent xcirculate;
	XCirculateRequestEvent xcirculaterequest;
	XPropertyEvent xproperty;
	XSelectionClearEvent xselectionclear;
	XSelectionRequestEvent xselectionrequest;
	XSelectionEvent xselection;
	XColormapEvent xcolormap;
	XClientMessageEvent xclient;
	XMappingEvent xmapping;
	XErrorEvent xerror;
	XKeymapEvent xkeymap;
	long pad[24];
} XEvent;
.De
.LP
An
.PN XEvent
structure's first entry always is the type member,
which is set to the event type.
The second member always is the serial number of the protocol request
that generated the event.
The third member always is send_event,
which is a
.PN Bool
that indicates if the event was sent by a different client.
The fourth member always is a display,
which is the display that the event was read from.
Except for keymap events,
the fifth member always is a window,
which has been carefully selected to be useful to toolkit dispatchers.
To avoid breaking toolkits,
the order of these first five entries is not to change.
Most events also contain a time member,
which is the time at which an event occurred.
In addition, a pointer to the generic event must be cast before it
is used to access any other information in the structure.
.NH 2
Event Masks
.XS
\*(SN Event Masks
.XE
.LP
.IN "event mask" "" "@DEF@"
Clients select event reporting of most events relative to a window.
To do this, pass an event mask to an Xlib event-handling
function that takes an event_mask argument.
The bits of the event mask are defined in
.Pn < X11/X.h >.
Each bit in the event mask maps to an event mask name,
which describes the event or events you want the X server to
return to a client application.
.LP
Unless the client has specifically asked for them,
most events are not reported to clients when they are generated. 
Unless the client suppresses them by setting graphics-exposures in the GC to
.PN False ,
.PN GraphicsExpose 
and 
.PN NoExpose 
are reported by default as a result of
.PN XCopyPlane
and
.PN XCopyArea .
.PN SelectionClear ,
.PN SelectionRequest ,
.PN SelectionNotify ,
or
.PN ClientMessage
cannot be masked.
Selection related events are only sent to clients cooperating
with selections (see section 4.4).
When the keyboard or pointer mapping is changed,
.PN MappingNotify
is always sent to clients.
.LP
.\"Table 8-2 
The following table 
lists the event mask constants you can pass to
the event_mask argument and
the circumstances in which you would want to specify the
event mask:
.LP
.\" .CP T 2
.\"Event Mask Definitions
.TS H
lw(2i) lw(3.5i).
_
.sp 6p
.TB
Event Mask	Circumstances
.sp 6p
_
.sp 6p
.TH
.R
T{
.PN NoEventMask
T}	T{
No events wanted
T}
T{
.PN KeyPressMask
T}	T{
Keyboard down events wanted
T}
T{
.PN KeyReleaseMask
T}	T{
Keyboard up events wanted
T}
T{
.PN ButtonPressMask
T}	T{
Pointer button down events wanted
T}
T{
.PN ButtonReleaseMask
T}	T{
Pointer button up events wanted
T}
T{
.PN EnterWindowMask
T}	T{
Pointer window entry events wanted
T}
T{
.PN LeaveWindowMask
T}	T{
Pointer window leave events wanted
T}
T{
.PN PointerMotionMask
T}	T{
Pointer motion events wanted
T}
T{
.PN PointerMotionHintMask
T}	T{
Pointer motion hints wanted
T}
T{
.PN Button1MotionMask
T}	T{
Pointer motion while button 1 down
T}
T{
.PN Button2MotionMask
T}	T{
Pointer motion while button 2 down
T}
T{
.PN Button3MotionMask
T}	T{
Pointer motion while button 3 down
T}
T{
.PN Button4MotionMask
T}	T{
Pointer motion while button 4 down
T}
T{
.PN Button5MotionMask
T}	T{
Pointer motion while button 5 down
T}
T{
.PN ButtonMotionMask
T}	T{
Pointer motion while any button down
T}
T{
.PN KeymapStateMask
T}	T{
Keyboard state wanted at window entry and focus in
T}
T{
.PN ExposureMask
T}	T{
Any exposure wanted
T}
T{
.PN VisibilityChangeMask
T}	T{
Any change in visibility wanted
T}
T{
.PN StructureNotifyMask
T}	T{
Any change in window structure wanted
T}
T{
.PN ResizeRedirectMask
T}	T{
Redirect resize of this window
T}
T{
.PN SubstructureNotifyMask
T}	T{
Substructure notification wanted
T}
T{
.PN SubstructureRedirectMask
T}	T{
Redirect structure requests on children
T}
T{
.PN FocusChangeMask
T}	T{
Any change in input focus wanted
T}
T{
.PN PropertyChangeMask
T}	T{
Any change in property wanted
T}
T{
.PN ColormapChangeMask
T}	T{
Any change in colormap wanted
T}
T{
.PN OwnerGrabButtonMask
T}	T{
Automatic grabs should activate with owner_events set to 
.PN True
T}
.sp 6p
_
.TE
.LP
.NH 2
Event Processing
.XS
\*(SN Event Processing 
.XE
.LP
The event reported to a client application during event processing
depends on which event masks you provide as the event-mask attribute 
for a window.
For some event masks, there is a one-to-one correspondence between
the event mask constant and the event type constant.
For example, if you pass the event mask
.PN ButtonPressMask ,
the X server sends back only
.PN ButtonPress
events.
.IN "CurrentTime"
Most events contain a time member,
which is the time at which an event occurred.
.LP
In other cases, one event mask constant can map to several event type constants.
For example, if you pass the event mask
.PN SubstructureNotifyMask ,
the X server can send back
.PN CirculateNotify ,
.PN ConfigureNotify ,
.PN CreateNotify ,
.PN DestroyNotify ,
.PN GravityNotify ,
.PN MapNotify ,
.PN ReparentNotify ,
or
.PN UnmapNotify
events.
.LP
In another case, 
two event masks can map to one event type.
For example, 
if you pass either
.PN PointerMotionMask 
or
.PN ButtonMotionMask ,
the X server sends back
a
.PN MotionNotify
event.
.LP
The following table 
lists the event mask, 
its associated event type or types, 
and the structure name associated with the event type.
Some of these structures actually are typedefs to a generic structure
that is shared between two event types.
Note that N.A. appears in columns for which the information is not applicable.
.LP
.ps 9
.nr PS 9
.TS H
lw(1.5i) lw(1i) lw(1.5i) lw(1.5i).
_
.sp 6p
.TB
Event Mask	Event Type	Structure	Generic Structure
.sp 6p
_
.sp 6p
.TH
.R
ButtonMotionMask	MotionNotify	XPointerMovedEvent	XMotionEvent
Button1MotionMask		
Button2MotionMask		
Button3MotionMask		
Button4MotionMask		
Button5MotionMask		
.sp 6p
ButtonPressMask	ButtonPress	XButtonPressedEvent	XButtonEvent
.sp 6p
ButtonReleaseMask	ButtonRelease	XButtonReleasedEvent	XButtonEvent
.sp 6p
ColormapChangeMask	ColormapNotify	XColormapEvent
.sp 6p
EnterWindowMask	EnterNotify	XEnterWindowEvent	XCrossingEvent
.sp 6p
LeaveWindowMask	LeaveNotify	XLeaveWindowEvent	XCrossingEvent
.sp 6p
ExposureMask	Expose	XExposeEvent 
GCGraphicsExposures in GC	GraphicsExpose	XGraphicsExposeEvent
	NoExpose	XNoExposeEvent
.sp 6p
FocusChangeMask	FocusIn	XFocusInEvent	XFocusChangeEvent
	FocusOut	XFocusOutEvent	XFocusChangeEvent
.sp 6p
KeymapStateMask	KeymapNotify	XKeymapEvent
.sp 6p
KeyPressMask	KeyPress	XKeyPressedEvent	XKeyEvent
KeyReleaseMask	KeyRelease	XKeyReleasedEvent	XKeyEvent
.sp 6p
OwnerGrabButtonMask	N.A.	N.A.
.sp 6p
PointerMotionMask	MotionNotify	XPointerMovedEvent	XMotionEvent
PointerMotionHintMask	N.A.	N.A.
.sp 6p
PropertyChangeMask	PropertyNotify	XPropertyEvent
.sp 6p
ResizeRedirectMask	ResizeRequest	XResizeRequestEvent
.sp 6p
StructureNotifyMask	CirculateNotify	XCirculateEvent
	ConfigureNotify	XConfigureEvent
	DestroyNotify	XDestroyWindowEvent
	GravityNotify	XGravityEvent
	MapNotify	XMapEvent
	ReparentNotify	XReparentEvent
	UnmapNotify	XUnmapEvent
.sp 6p
SubstructureNotifyMask	CirculateNotify	XCirculateEvent
	ConfigureNotify	XConfigureEvent
	CreateNotify	XCreateWindowEvent
	DestroyNotify	XDestroyWindowEvent
	GravityNotify	XGravityEvent
	MapNotify	XMapEvent
	ReparentNotify	XReparentEvent
	UnmapNotify	XUnmapEvent
.sp 6p
SubstructureRedirectMask	CirculateRequest	XCirculateRequestEvent
	ConfigureRequest	XConfigureRequestEvent
	MapRequest	XMapRequestEvent
.sp 6p
N.A.	ClientMessage	XClientMessageEvent
.sp 6p
N.A.	MappingNotify	XMappingEvent
.sp 6p
N.A.	SelectionClear	XSelectionClearEvent
.sp 6p
N.A.	SelectionNotify	XSelectionEvent
.sp 6p
N.A.	SelectionRequest	XSelectionRequestEvent
.sp 6p
VisibilityChangeMask	VisibilityNotify	XVisibilityEvent
.sp 6p
_
.TE
.ps 11
.nr PS 11
.LP
The sections that follow describe the processing that occurs 
when you select the different event masks.
The sections are organized according to these processing categories:
.IP \(bu 5
Keyboard and pointer events
.IP \(bu 5
Window crossing events
.IP \(bu 5
Input focus events
.IP \(bu 5
Keymap state notification events
.IP \(bu 5
Exposure events
.IP \(bu 5
Window state notification events
.IP \(bu 5
Structure control events
.IP \(bu 5
Colormap state notification events
.IP \(bu 5
Client communication events
.NH 3
Keyboard and Pointer Events
.XS
\*(SN Keyboard and Pointer Events
.XE
.LP
This section discusses:
.IP \(bu 5
Pointer button events
.IP \(bu 5
Keyboard and pointer events
.NH 4
Pointer Button Events
.XS
\*(SN Pointer Button Events
.XE
.LP
The following describes the event processing that occurs when a pointer button 
press is processed with the pointer in some window w and 
when no active pointer grab is in progress.
.LP
The X server searches the ancestors of w from the root down,
looking for a passive grab to activate.
If no matching passive grab on the button exists,
the X server automatically starts an active grab for the client receiving
the event and sets the last-pointer-grab time to the current server time.
The effect is essentially equivalent to an
.PN XGrabButton
with these client passed arguments:
.TS H
lw(1.5i) lw(3.5i).
_
.sp 6p
.TB
Argument	Value
.sp 6p
_
.sp 6p
.TH
.R
T{
\fIw\fP
T}	T{
The event window 
T}
T{
\fIevent_mask\fP
T}	T{
The client's selected pointer events on the event window
T}
T{
\fIpointer_mode\fP
T}	T{
.PN GrabModeAsync
T}
T{
\fIkeyboard_mode\fP
T}	T{
.PN GrabModeAsync 
T}
T{
\fIowner_events\fP
T}	T{
.PN True ,
if the client has selected
.PN OwnerGrabButtonMask
on the event window,
otherwise
.PN False 
T}
T{
\fIconfine_to\fP
T}	T{
.PN None 
T}
T{
\fIcursor\fP
T}	T{
.PN None 
T}
.sp 6p
_
.TE
.LP
The active grab is automatically terminated when 
the logical state of the pointer has all buttons released.
Clients can modify the active grab by calling
.PN XUngrabPointer
and
.PN XChangeActivePointerGrab .
.NH 4
Keyboard and Pointer Events
.XS
\*(SN Keyboard and Pointer Events
.XE
.LP
.IN "Events" "ButtonPress"
.IN "Events" "ButtonRelease"
.IN "Events" "KeyPress"
.IN "Events" "KeyRelease"
.IN "Events" "MotionNotify"
This section discusses the processing that occurs for the
keyboard events
.PN KeyPress
and 
.PN KeyRelease 
and the pointer events
.PN ButtonPress ,
.PN ButtonRelease ,
and
.PN MotionNotify .
For information about the keyboard event-handling utilities,
see chapter 10.
.LP
.IN "KeyPress" "" "@DEF@"
.IN "KeyRelease" "" "@DEF@"
The X server reports
.PN KeyPress
or
.PN KeyRelease
events to clients wanting information about keys that logically change state.
Note that these events are generated for all keys, 
even those mapped to modifier bits.
.IN "ButtonPress" "" "@DEF@"
.IN "ButtonRelease" "" "@DEF@"
The X server reports
.PN ButtonPress
or
.PN ButtonRelease
events to clients wanting information about buttons that logically change state.
.LP
.IN "MotionNotify" "" "@DEF@"
The X server reports
.PN MotionNotify
events to clients wanting information about when the pointer logically moves.
The X server generates this event whenever the pointer is moved 
and the pointer motion begins and ends in the window.
The granularity of
.PN MotionNotify
events is not guaranteed, 
but a client that selects this event type is guaranteed
to receive at least one event when the pointer moves and then rests.
.LP
The generation of the logical changes lags the physical changes 
if device event processing is frozen.
.LP
To receive
.PN KeyPress ,
.PN KeyRelease ,
.PN ButtonPress ,
and
.PN ButtonRelease 
events, set 
.PN KeyPressMask ,
.PN KeyReleaseMask ,
.PN ButtonPressMask ,
and
.PN ButtonReleaseMask 
bits in the event-mask attribute of the window.
.LP
To receive 
.PN MotionNotify
events, set one or more of the following event 
masks bits in the event-mask attribute of the window.
.IP \(bu 5
.PN Button1MotionMask \ \-
.PN Button5MotionMask
.IP
The client application receives
.PN MotionNotify
events only when one or more of the specified buttons is pressed.
.IP \(bu 5
.PN ButtonMotionMask
.IP
The client application receives
.PN MotionNotify
events only when at least one button is pressed.
.IP \(bu 5
.PN PointerMotionMask
.IP
The client application receives 
.PN MotionNotify
events independent of the state of
the pointer buttons.
.IP \(bu 5
.PN PointerMotionHint
.IP
If
.PN PointerMotionHintMask
is selected in combination with one or more of the above masks, 
the X server is free to send only one
.PN MotionNotify
event (with the is_hint member  of the
.PN XPointerMovedEvent
structure set to
.PN NotifyHint )
to the client for the event window, 
until either the key or button state changes,
the pointer leaves the event window, or the client calls
.PN XQueryPointer
or
.PN XGetMotionEvents .
The server still may send
.PN MotionNotify
events without is_hint set to
.PN NotifyHint .
.LP
The source of the event is the viewable window that the pointer is in.
The window used by the X server to report these events depends on 
the window's position in the window hierarchy 
and whether any intervening window prohibits the generation of these events.
Starting with the source window, 
the X server searches up the window hierarchy until it locates the first 
window specified by a client as having an interest in these events.
If one of the intervening windows has its do-not-propagate-mask
set to prohibit generation of the event type,
the events of those types will be suppressed.
Clients can modify the actual window used for reporting by performing
active grabs and, in the case of keyboard events, by using the focus window.
.LP
The structures for these event types contain:
.LP
.IN "XButtonEvent" "" "@DEF@"
.IN "XButtonPressedEvent" "" "@DEF@"
.IN "XButtonReleasedEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* ButtonPress or ButtonRelease */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	/* ``event'' window it is reported relative to */
	Window root;	/* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;	/* milliseconds */
	int x, y;	/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	unsigned int button;	/* detail */
	Bool same_screen;	/* same screen flag */
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;
.De
.LP
.IN "XKeyEvent" "" "@DEF@"
.IN "XKeyPressedEvent" "" "@DEF@"
.IN "XKeyReleasedEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* KeyPress or KeyRelease */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	/* ``event'' window it is reported relative to */
	Window root;	/* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;	/* milliseconds */
	int x, y;	/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	unsigned int keycode;	/* detail */
	Bool same_screen;	/* same screen flag */
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;
.De
.LP
.IN "XMotionEvent" "" "@DEF@"
.IN "XPointerMovedEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* MotionNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	/* ``event'' window reported relative to */
	Window root;	/* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;	/* milliseconds */
	int x, y;	/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	char is_hint;	/* detail */
	Bool same_screen;	/* same screen flag */
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;
.De
.LP
These structures have the following common members:
window, root, subwindow, time, x, y, x_root, y_root, state, and same_screen.
The window member is set to the window on which the
event was generated and is referred to as the event window. 
As long as the conditions previously discussed are met,
this is the window used by the X server to report the event.
The root member is set to the source window's root window.
The x_root and y_root members are set to the pointer's coordinates
relative to the root window's origin at the time of the event.
.LP
The same_screen member is set to indicate whether the event 
window is on the same screen
as the root window and can be either
.PN True 
or
.PN False .
If
.PN True ,
the event and root windows are on the same screen.
If
.PN False ,
the event and root windows are not on the same screen.
.LP
If the source window is an inferior of the event window, 
the subwindow member of the structure is set to the child of the event window
that is the source member or an ancestor of it.
Otherwise, the X server sets the subwindow member to
.PN None .
The time member is set to the time when the event was generated 
and is expressed in milliseconds.
.LP
If the event window is on the same screen as the root window, 
the x and y members
are set to the coordinates relative to the event window's origin.
Otherwise, these members are set to zero.
.LP
The state member is set to indicate the logical state of the pointer buttons 
and modifier keys just prior to the event,
which is the bitwise inclusive OR of one or more of the
button or modifier key masks:
.PN Button1Mask ,
.PN Button2Mask ,
.PN Button3Mask ,
.PN Button4Mask ,
.PN Button5Mask ,
.PN ShiftMask ,
.PN LockMask ,
.PN ControlMask ,
.PN Mod1Mask ,
.PN Mod2Mask ,
.PN Mod3Mask ,
.PN Mod4Mask ,
and
.PN Mod5Mask .
.LP
Each of these structures also has a member that indicates the detail.
For the
.PN XKeyPressedEvent
and
.PN XKeyReleasedEvent
structures, this member is called keycode.
It is set to a number that represents a physical key on the keyboard.
The keycode is an arbitrary representation for any key on the keyboard
(see chapter 7).
.LP
For the
.PN XButtonPressedEvent
and
.PN XButtonReleasedEvent
structures, this member is called button.
It represents the pointer button that changed state and can be the
.PN Button1 ,
.PN Button2 ,
.PN Button3 ,
.PN Button4 ,
or
.PN Button5 
value.
For the
.PN XPointerMovedEvent
structure, this member is called is_hint.
It can be set to 
.PN NotifyNormal
or
.PN NotifyHint .
.NH 3
Window Entry/Exit Events
.XS
\*(SN Window Entry/Exit Events
.XE
.LP
.IN "Events" "EnterNotify"
.IN "Events" "LeaveNotify"
This section describes the processing that 
occurs for the window crossing events
.PN EnterNotify
and
.PN LeaveNotify .
.IN "EnterNotify" "" "@DEF@"
.IN "LeaveNotify" "" "@DEF@"
If a pointer motion or a window hierarchy change causes the
pointer to be in a different window than before, the X server reports
.PN EnterNotify
or
.PN LeaveNotify
events to clients who have selected for these events.
All 
.PN EnterNotify
and 
.PN LeaveNotify
events caused by a hierarchy change are
generated after any hierarchy event
.Pn ( UnmapNotify ,
.PN MapNotify ,
.PN ConfigureNotify ,
.PN GravityNotify ,
.PN CirculateNotify )
caused by that change;
however, the X protocol does not constrain the ordering of 
.PN EnterNotify 
and 
.PN LeaveNotify 
events with respect to
.PN FocusOut , 
.PN VisibilityNotify ,
and 
.PN Expose 
events.
.LP
This contrasts with
.PN MotionNotify
events, which are also generated when the pointer moves
but only when the pointer motion begins and ends in a single window.
An
.PN EnterNotify
or
.PN LeaveNotify
event also can be generated when some client application calls
.PN XGrabPointer
and
.PN XUngrabPointer .
.LP
To receive
.PN EnterNotify
or
.PN LeaveNotify
events, set the
.PN EnterWindowMask
or
.PN LeaveWindowMask
bits of the event-mask attribute of the window.
.LP
The structure for these event types contains:
.LP
.IN "XCrossingEvent" "" "@DEF@"
.IN "XEnterWindowEvent" "" "@DEF@"
.IN "XLeaveWindowEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* EnterNotify or LeaveNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	/* ``event'' window reported relative to */
	Window root;	/* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;	/* milliseconds */
	int x, y;	/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	int mode;	/* NotifyNormal, NotifyGrab, NotifyUngrab */
	int detail;
		/*
	 	* NotifyAncestor, NotifyVirtual, NotifyInferior, 
	 	* NotifyNonlinear,NotifyNonlinearVirtual
	 	*/
	Bool same_screen;	/* same screen flag */
	Bool focus;	/* boolean focus */
	unsigned int state;	/* key or button mask */
} XCrossingEvent;
typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;
.De
.LP
The window member is set to the window on which the
.PN EnterNotify
or
.PN LeaveNotify
event was generated and is referred to as the event window. 
This is the window used by the X server to report the event, 
and is relative to the root
window on which the event occurred. 
The root member is set to the root window of the screen
on which the event occurred.
.LP
For a
.PN LeaveNotify 
event,
if a child of the event window contains the initial position of the pointer,
the subwindow component is set to that child.
Otherwise, the X server sets the subwindow member to
.PN None .
For an
.PN EnterNotify 
event, if a child of the event window contains the final pointer position, 
the subwindow component is set to that child or
.PN None .
.LP
The time member is set to the time when the event was generated
and is expressed in milliseconds.
The x and y members are set to the coordinates of the pointer position in 
the event window.
This position is always the pointer's final position,
not its initial position.
If the event window is on the same
screen as the root window, x and y are the pointer coordinates
relative to the event window's origin. 
Otherwise, x and y are set to zero.
The x_root and y_root members are set to the pointer's coordinates relative to the
root window's origin at the time of the event.
.LP
The same_screen member is set to indicate whether the event window is on the same screen
as the root window and can be either
.PN True 
or
.PN False .
If
.PN True ,
the event and root windows are on the same screen.
If
.PN False ,
the event and root windows are not on the same screen.
.LP
The focus member is set to indicate whether the event window is the focus window or an
inferior of the focus window.
The X server can set this member to either
.PN True 
or
.PN False .
If
.PN True ,
the event window is the focus window or an inferior of the focus window.
If
.PN False ,
the event window is not the focus window or an inferior of the focus window.
.LP
The state member is set to indicate the state of the pointer buttons and
modifier keys just prior to the
event.
The X server can set this member to the bitwise inclusive OR of one 
or more of the button or modifier key masks:
.PN Button1Mask ,
.PN Button2Mask ,
.PN Button3Mask ,
.PN Button4Mask ,
.PN Button5Mask ,
.PN ShiftMask ,
.PN LockMask ,
.PN ControlMask ,
.PN Mod1Mask ,
.PN Mod2Mask ,
.PN Mod3Mask ,
.PN Mod4Mask ,
.PN Mod5Mask .
.LP
The mode member is set to indicate whether the events are normal events, 
pseudo-motion events
when a grab activates, or pseudo-motion events when a grab deactivates.
The X server can set this member to 
.PN NotifyNormal ,
.PN NotifyGrab ,
or
.PN NotifyUngrab .
.LP
The detail member is set to indicate the notify detail and can be
.PN NotifyAncestor ,
.PN NotifyVirtual ,
.PN NotifyInferior ,
.PN NotifyNonlinear ,
or
.PN NotifyNonlinearVirtual .
.NH 4 
Normal Entry/Exit Events
.XS
\*(SN Normal Entry/Exit Events
.XE
.LP
.PN EnterNotify
and
.PN LeaveNotify
events are generated when the pointer moves from
one window to another window.
Normal events are identified by
.PN XEnterWindowEvent
or
.PN XLeaveWindowEvent
structures whose mode member is set to
.PN NotifyNormal .
.IP \(bu 5
When the pointer moves from window A to window B and A is an inferior of B, 
the X server does the following:
.RS
.IP \- 5
It generates a
.PN LeaveNotify
event on window A, with the detail member of the
.PN XLeaveWindowEvent
structure set to
.PN NotifyAncestor .
.IP \- 5
It generates a
.PN LeaveNotify
event on each window between window A and window B, exclusive,
with the detail member of each
.PN XLeaveWindowEvent
structure set to
.PN NotifyVirtual .
.IP \- 5
It generates an
.PN EnterNotify
event on window B, with the detail member of the 
.PN XEnterWindowEvent
structure set to
.PN NotifyInferior .
.RE
.IP \(bu 5
When the pointer moves from window A to window B and B is an inferior of A,
the X server does the following:
.RS
.IP \- 5
It generates a
.PN LeaveNotify
event on window A,
with the detail member of the
.PN XLeaveWindowEvent
structure set to
.PN NotifyInferior .
.IP \- 5
It generates an
.PN EnterNotify
event on each window between window A and window B, exclusive, with the 
detail member of each 
.PN XEnterWindowEvent
structure set to
.PN NotifyVirtual . 
.IP \- 5
It generates an
.PN EnterNotify
event on window B, with the detail member of the 
.PN XEnterWindowEvent
structure set to
.PN NotifyAncestor .
.RE
.IP \(bu 5
When the pointer moves from window A to window B 
and window C is their least common ancestor, 
the X server does the following:
.RS
.IP \- 5
It generates a
.PN LeaveNotify
event on window A,
with the detail member of the
.PN XLeaveWindowEvent
structure set to 
.PN NotifyNonlinear .
.IP \- 5
It generates a
.PN LeaveNotify
event on each window between window A and window C, exclusive,
with the detail member of each
.PN XLeaveWindowEvent
structure set to
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates an
.PN EnterNotify
event on each window between window C and window B, exclusive, 
with the detail member of each
.PN XEnterWindowEvent
structure set to
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates an
.PN EnterNotify
event on window B, with the detail member of the 
.PN XEnterWindowEvent
structure set to 
.PN NotifyNonlinear .
.RE
.IP \(bu 5
When the pointer moves from window A to window B on different screens, 
the X server does the following:
.RS
.IP \- 5
It generates a
.PN LeaveNotify
event on window A,
with the detail member of the
.PN XLeaveWindowEvent
structure set to 
.PN NotifyNonlinear .
.IP \- 5
If window A is not a root window,
it generates a
.PN LeaveNotify
event on each window above window A up to and including its root,
with the detail member of each
.PN XLeaveWindowEvent
structure set to 
.PN NotifyNonlinearVirtual .
.IP \- 5
If window B is not a root window,
it generates an
.PN EnterNotify
event on each window from window B's root down to but not including
window B, with the detail member of each
.PN XEnterWindowEvent
structure set to 
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates an
.PN EnterNotify
event on window B, with the detail member of the
.PN XEnterWindowEvent
structure set to 
.PN NotifyNonlinear .
.RE
.\".SH 3
.NH 4 
Grab and Ungrab Entry/Exit Events
.XS
\*(SN Grab and Ungrab Entry/Exit Events
.XE
.LP
Pseudo-motion mode
.PN EnterNotify
and
.PN LeaveNotify
events are generated when a pointer grab activates or deactivates.
Events in which the pointer grab activates
are identified by
.PN XEnterWindowEvent
or
.PN XLeaveWindowEvent
structures whose mode member is set to 
.PN NotifyGrab .
Events in which the pointer grab deactivates
are identified by
.PN XEnterWindowEvent
or
.PN XLeaveWindowEvent
structures whose mode member is set to 
.PN NotifyUngrab
(see
.PN XGrabPointer ).
.IP \(bu 5
When a pointer grab activates after any initial warp into a confine_to
window and before generating any actual
.PN ButtonPress
event that activates the grab, 
G is the grab_window for the grab, 
and P is the window the pointer is in, 
the X server does the following:
.RS
.IP \- 5
It generates
.PN EnterNotify
and
.PN LeaveNotify
events (see section 8.4.2.1)
with the mode members of the 
.PN XEnterWindowEvent
and
.PN XLeaveWindowEvent
structures set to 
.PN NotifyGrab .
These events are generated
as if the pointer were to suddenly warp from
its current position in P to some position in G.
However, the pointer does not warp, and the X server uses the pointer position 
as both the initial and final positions for the events.
.RE
.IP \(bu 5
When a pointer grab deactivates after generating any actual
.PN ButtonRelease
event that deactivates the grab, 
G is the grab_window for the grab,
and P is the window the pointer is in, 
the X server does the following:
.RS
.IP \- 5
It generates
.PN EnterNotify
and
.PN LeaveNotify
events (see section 8.4.2.1)
with the mode members of the
.PN XEnterWindowEvent
and
.PN XLeaveWindowEvent
structures set to 
.PN NotifyUngrab .
These events are generated as if the pointer were to suddenly warp from
some position in G to its current position in P.
However, the pointer does not warp, and the X server uses the
current pointer position as both the
initial and final positions for the events.
.RE
.NH 3
Input Focus Events
.XS
\*(SN Input Focus Events 
.XE
.LP
.IN "Events" "FocusIn"
.IN "Events" "FocusOut"
This section describes the processing that occurs for the input focus events
.PN FocusIn
and
.PN FocusOut .
.IN "FocusIn" "" "@DEF@"
.IN "FocusOut" "" "@DEF@"
The X server can report
.PN FocusIn
or
.PN FocusOut
events to clients wanting information about when the input focus changes.
The keyboard is always attached to some window 
(typically, the root window or a top-level window), 
which is called the focus window.
The focus window and the position of the pointer determine the window that
receives keyboard input.
Clients may need to know when the input focus changes
to control highlighting of areas on the screen.
.LP
To receive
.PN FocusIn
or
.PN FocusOut
events, set the
.PN FocusChangeMask
bit in the event-mask attribute of the window. 
.LP
The structure for these event types contains:
.LP
.IN "XFocusChangeEvent" "" "@DEF@"
.IN "XFocusInEvent" "" "@DEF@"
.IN "XFocusOutEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* FocusIn or FocusOut */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	/* window of event */
	int mode;	/* NotifyNormal, NotifyGrab, NotifyUngrab */
	int detail;
		/*
	 	* NotifyAncestor, NotifyVirtual, NotifyInferior, 
	 	* NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
	 	* NotifyPointerRoot, NotifyDetailNone 
	 	*/
} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;
.De
.LP
The window member is set to the window on which the
.PN FocusIn
or
.PN FocusOut
event was generated.
This is the window used by the X server to report the event. 
The mode member is set to indicate whether the focus events 
are normal focus events, 
focus events while grabbed,
focus events
when a grab activates, or focus events when a grab deactivates.
The X server can set the mode member to 
.PN NotifyNormal ,
.PN NotifyWhileGrabbed ,
.PN NotifyGrab ,
or
.PN NotifyUngrab .
.LP
All 
.PN FocusOut
events caused by a window unmap are generated after any
.PN UnmapNotify
event; however, the X protocol does not constrain the ordering of 
.PN FocusOut
events with respect to
generated 
.PN EnterNotify ,
.PN LeaveNotify ,
.PN VisibilityNotify ,
and
.PN Expose
events.
.LP
Depending on the event mode,
the detail member is set to indicate the notify detail and can be
.PN NotifyAncestor ,
.PN NotifyVirtual ,
.PN NotifyInferior ,
.PN NotifyNonlinear ,
.PN NotifyNonlinearVirtual ,
.PN NotifyPointer ,
.PN NotifyPointerRoot ,
or
.PN NotifyDetailNone .
.NH 4 
Normal Focus Events and Focus Events While Grabbed 
.XS
\*(SN Normal Focus Events and Focus Events While Grabbed 
.XE
.LP
Normal focus events are identified by
.PN XFocusInEvent
or
.PN XFocusOutEvent
structures whose mode member is set to 
.PN NotifyNormal .
Focus events while grabbed are identified by
.PN XFocusInEvent
or
.PN XFocusOutEvent
structures whose mode member is set to 
.PN NotifyWhileGrabbed .
The X server processes normal focus and focus events while grabbed according to 
the following:
.IP \(bu 5
When the focus moves from window A to window B, A is an inferior of B, 
and the pointer is in window P, 
the X server does the following:
.RS
.IP \- 5
It generates a
.PN FocusOut
event on window A, with the detail member of the
.PN XFocusOutEvent
structure set to 
.PN NotifyAncestor . 
.IP \- 5
It generates a
.PN FocusOut
event on each window between window A and window B, exclusive,
with the detail member of each
.PN XFocusOutEvent
structure set to 
.PN NotifyVirtual .
.IP \- 5
It generates a
.PN FocusIn
event on window B, with the detail member of the 
.PN XFocusOutEvent
structure set to 
.PN NotifyInferior .
.IP \- 5
If window P is an inferior of window B
but window P is not window A or an inferior or ancestor of window A,
it generates a
.PN FocusIn
event on each window below window B, down to and including window P, 
with the detail member of each 
.PN XFocusInEvent
structure set to 
.PN NotifyPointer .
.RE
.IP \(bu 5
When the focus moves from window A to window B, B is an inferior of A, 
and the pointer is in window P, 
the X server does the following:
.RS
.IP \- 5
If window P is an inferior of window A
but P is not an inferior of window B or an ancestor of B,
it generates a
.PN FocusOut
event on each window from window P up to but not including window A,
with the detail member of each 
.PN XFocusOutEvent
structure set to  
.PN NotifyPointer .
.IP \- 5
It generates a
.PN FocusOut
event on window A,
with the detail member of the
.PN XFocusOutEvent
structure set to  
.PN NotifyInferior . 
.IP \- 5
It generates a
.PN FocusIn
event on each window between window A and window B, exclusive, with the 
detail member of each 
.PN XFocusInEvent
structure set to  
.PN NotifyVirtual . 
.IP \- 5
It generates a
.PN FocusIn
event on window B, with the detail member of the 
.PN XFocusInEvent
structure set to  
.PN NotifyAncestor .
.RE
.IP \(bu 5
When the focus moves from window A to window B, 
window C is their least common ancestor, 
and the pointer is in window P, 
the X server does the following:
.RS
.IP \- 5
If window P is an inferior of window A,
it generates a
.PN FocusOut
event on each window from window P up to but not including window A, 
with the detail member of the 
.PN XFocusOutEvent
structure set to  
.PN NotifyPointer .
.IP \- 5
It generates a
.PN FocusOut
event on window A,
with the detail member of the
.PN XFocusOutEvent
structure set to  
.PN NotifyNonlinear .
.IP \- 5
It generates a
.PN FocusOut
event on each window between window A and window C, exclusive,
with the detail member of each
.PN XFocusOutEvent
structure set to  
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates a
.PN FocusIn
event on each window between C and B, exclusive,
with the detail member of each
.PN XFocusInEvent
structure set to  
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates a
.PN FocusIn
event on window B, with the detail member of the 
.PN XFocusInEvent
structure set to  
.PN NotifyNonlinear .
.IP \- 5
If window P is an inferior of window B, it generates a
.PN FocusIn
event on each window below window B down to and including window P, 
with the detail member of the 
.PN XFocusInEvent
structure set to  
.PN NotifyPointer .
.RE
.IP \(bu 5
When the focus moves from window A to window B on different screens 
and the pointer is in window P, 
the X server does the following:
.RS
.IP \- 5
If window P is an inferior of window A, it generates a
.PN FocusOut
event on each window from window P up to but not including window A, 
with the detail member of each 
.PN XFocusOutEvent
structure set to  
.PN NotifyPointer .
.IP \- 5
It generates a
.PN FocusOut
event on window A,
with the detail member of the
.PN XFocusOutEvent
structure set to  
.PN NotifyNonlinear .
.IP \- 5
If window A is not a root window,
it generates a
.PN FocusOut
event on each window above window A up to and including its root, 
with the detail member of each
.PN XFocusOutEvent
structure set to  
.PN NotifyNonlinearVirtual .
.IP \- 5
If window B is not a root window,
it generates a
.PN FocusIn
event on each window from window B's root down to but not including
window B, with the detail member of each
.PN XFocusInEvent
structure set to  
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates a
.PN FocusIn
event on window B, with the detail member of each 
.PN XFocusInEvent
structure set to  
.PN NotifyNonlinear .
.IP \- 5
If window P is an inferior of window B, it generates a
.PN FocusIn
event on each window below window B down to and including window P, 
with the detail member of each 
.PN XFocusInEvent
structure set to  
.PN NotifyPointer .
.RE
.IP \(bu 5
When the focus moves from window A to 
.PN PointerRoot
(events sent to the window under the pointer)
or
.PN None 
(discard), and the pointer is in window P,
the X server does the following:
.RS
.IP \- 5
If window P is an inferior of window A, it generates a
.PN FocusOut
event on each window from window P up to but not including window A, 
with the detail member of each 
.PN XFocusOutEvent
structure set to  
.PN NotifyPointer .
.IP \- 5
It generates a
.PN FocusOut
event on window A, with the detail member of the
.PN XFocusOutEvent
structure set to
.PN NotifyNonlinear .
.IP \- 5
If window A is not a root window,
it generates a
.PN FocusOut
event on each window above window A up to and including its root, 
with the detail member of each
.PN XFocusOutEvent
structure set to
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates a
.PN FocusIn
event on the root window of all screens, with the detail member of each
.PN XFocusInEvent
structure set to
.PN NotifyPointerRoot
(or
.PN NotifyDetailNone ).
.IP \- 5
If the new focus is
.PN PointerRoot ,
it generates a
.PN FocusIn
event on each window from window P's root down to and including window P, 
with the detail member of each
.PN XFocusInEvent
structure set to
.PN NotifyPointer .
.RE
.IP \(bu 5
When the focus moves from 
.PN PointerRoot
(events sent to the window under the pointer)
or
.PN None 
to window A, and the pointer is in window P, 
the X server does the following: 
.RS
.IP \- 5
If the old focus is
.PN PointerRoot ,
it generates a
.PN FocusOut
event on each window from window P up to and including window P's root, 
with the detail member of each
.PN XFocusOutEvent
structure set to
.PN NotifyPointer .
.IP \- 5
It generates a
.PN FocusOut
event on all root windows,
with the detail member of each
.PN XFocusOutEvent
structure set to
.PN NotifyPointerRoot
(or
.PN NotifyDetailNone ).
.IP \- 5
If window A is not a root window,
it generates a
.PN FocusIn
event on each window from window A's root down to but not including window A,
with the detail member of each
.PN XFocusInEvent
structure set to
.PN NotifyNonlinearVirtual .
.IP \- 5
It generates a
.PN FocusIn
event on window A,
with the detail member of the 
.PN XFocusInEvent
structure set to  
.PN NotifyNonlinear .
.IP \- 5
If window P is an inferior of window A, it generates a
.PN FocusIn
event on each window below window A down to and including window P, 
with the detail member of each 
.PN XFocusInEvent
structure set to  
.PN NotifyPointer .
.RE
.IP \(bu 5
When the focus moves from 
.PN PointerRoot
(events sent to the window under the pointer)
to
.PN None
(or vice versa), and the pointer is in window P, 
the X server does the following:
.RS
.IP \- 5
If the old focus is
.PN PointerRoot ,
it generates a
.PN FocusOut
event on each window from window P up to and including window P's root, 
with the detail member of each
.PN XFocusOutEvent
structure set to
.PN NotifyPointer .
.IP \- 5
It generates a
.PN FocusOut
event on all root windows,
with the detail member of each 
.PN XFocusOutEvent
structure set to either
.PN NotifyPointerRoot
or
.PN NotifyDetailNone . 
.IP \- 5
It generates a
.PN FocusIn
event on all root windows,
with the detail member of each
.PN XFocusInEvent
structure set to
.PN NotifyDetailNone 
or
.PN NotifyPointerRoot .
.IP \- 5
If the new focus is
.PN PointerRoot ,
it generates a
.PN FocusIn
event on each window from window P's root down to and including window P, 
with the detail member of each
.PN XFocusInEvent
structure set to
.PN NotifyPointer .
.RE
.\".SH 3
.NH 4 
Focus Events Generated by Grabs
.XS
\*(SN Focus Events Generated by Grabs 
.XE
.LP
Focus events in which the keyboard grab activates
are identified by
.PN XFocusInEvent
or
.PN XFocusOutEvent
structures whose mode member is set to 
.PN NotifyGrab .
Focus events in which the keyboard grab deactivates
are identified by
.PN XFocusInEvent
or
.PN XFocusOutEvent
structures whose mode member is set to 
.PN NotifyUngrab 
(see 
.PN XGrabKeyboard ).
.IP \(bu 5
When a keyboard grab activates before generating any actual 
.PN KeyPress
event that activates the grab,
G is the grab_window, and F is the current focus, 
the X server does the following:
.RS
.IP \- 5
It generates 
.PN FocusIn
and
.PN FocusOut
events, with the mode members of the 
.PN XFocusInEvent
and
.PN XFocusOutEvent
structures set to 
.PN NotifyGrab .
These events are generated
as if the focus were to change from
F to G.
.RE
.IP \(bu 5
When a keyboard grab deactivates after generating any actual
.PN KeyRelease
event that deactivates the grab,
G is the grab_window, and F is the current focus,
the X server does the following:
.RS
.IP \- 5
It generates 
.PN FocusIn
and
.PN FocusOut
events, with the mode members of the 
.PN XFocusInEvent
and
.PN XFocusOutEvent
structures set to
.PN NotifyUngrab .
These events are generated
as if the focus were to change from
G to F.
.RE
.NH 3
Key Map State Notification Events
.XS
\*(SN Key Map State Notification Events
.XE
.LP
.IN "Events" "KeymapNotify"
.IN "KeymapNotify" "" "@DEF@"
The X server can report
.PN KeymapNotify
events to clients that want information about changes in their keyboard state.
.LP
To receive
.PN KeymapNotify
events, set the
.PN KeymapStateMask
bit in the event-mask attribute of the window. 
The X server generates this event immediately after every
.PN EnterNotify
and
.PN FocusIn
event.
.LP
The structure for this event type contains:
.LP
.IN "XKeymapEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
/* generated on EnterWindow and FocusIn when KeymapState selected */
typedef struct {
	int type;	/* KeymapNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	char key_vector[32];
} XKeymapEvent;	
.De
.LP
The window member is not used but is present to aid some toolkits.
The key_vector member is set to the bit vector of the keyboard.
Each bit set to 1 indicates that the corresponding key 
is currently pressed.
The vector is represented as 32 bytes.
Byte N (from 0) contains the bits for keys 8N to 8N + 7 
with the least-significant bit in the byte representing key 8N.
.NH 3
Exposure Events
.XS
\*(SN Exposure Events
.XE
.LP
The X protocol does not guarantee to preserve the contents of window 
regions when
the windows are obscured or reconfigured.
Some implementations may preserve the contents of windows.
Other implementations are free to destroy the contents of windows
when exposed.
X expects client applications to assume the responsibility for
restoring the contents of an exposed window region. 
(An exposed window region describes a formerly obscured window whose 
region becomes visible.) 
Therefore, the X server sends 
.PN Expose 
events describing the window and the region of the window that has been exposed.
A naive client application usually redraws the entire window. 
A more sophisticated client application redraws only the exposed region.
.NH 4
Expose Events
.XS
\*(SN Expose Events
.XE
.LP
.IN "Events" "Expose"
.IN "Expose" "" "@DEF@"
The X server can report
.PN Expose
events to clients wanting information about when the contents of window regions
have been lost.
The circumstances in which the X server generates
.PN Expose
events are not as definite as those for other events.
However, the X server never generates
.PN Expose
events on windows whose class you specified as
.PN InputOnly .
The X server can generate
.PN Expose
events when no valid contents are available for regions of a window
and either the regions are visible, 
the regions are viewable and the server is (perhaps newly) maintaining 
backing store on the window,
or the window is not viewable but the server is (perhaps newly) honoring the
window's backing-store attribute of
.PN Always
or
.PN WhenMapped .
The regions decompose into an (arbitrary) set of rectangles,
and an
.PN Expose
event is generated for each rectangle.
For any given window,
the X server guarantees to report contiguously 
all of the regions exposed by some action that causes 
.PN Expose 
events, such as raising a window.
.LP
To receive
.PN Expose
events, set the
.PN ExposureMask
bit in the event-mask attribute of the window. 
.LP
The structure for this event type contains:
.LP
.IN "XExposeEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* Expose */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int x, y;
	int width, height;
	int count;	/* if nonzero, at least this many more */
} XExposeEvent;
.De
.LP
The window member is set to the exposed (damaged) window.
The x and y members are set to the coordinates relative to the window's origin
and indicate the upper-left corner of the rectangle.
The width and height members are set to the size (extent) of the rectangle.
The count member is set to the number of
.PN Expose
events that are to follow.
If count is zero, no more
.PN Expose
events follow for this window.
However, if count is nonzero, at least that number of 
.PN Expose 
events (and possibly more) follow for this window.
Simple applications that do not want to optimize redisplay by distinguishing
between subareas of its window can just ignore all
.PN Expose
events with nonzero counts and perform full redisplays
on events with zero counts.
.NH 4
GraphicsExpose and NoExpose Events
.XS
\*(SN GraphicsExpose and NoExpose Events
.XE
.LP
.IN "Events" "GraphicsExpose"
.IN "Events" "NoExpose"
.IN "GraphicsExpose" "" "@DEF@"
The X server can report
.PN GraphicsExpose
events to clients wanting information about when a destination region could not
be computed during certain graphics requests:
.PN XCopyArea
or
.PN XCopyPlane .
The X server generates this event whenever a destination region could not be
computed due to an obscured or out-of-bounds source region.
In addition, the X server guarantees to report contiguously all of the regions exposed by
some graphics request 
(for example, copying an area of a drawable to a destination
drawable).
.LP
.IN "NoExpose" "" "@DEF@"
The X server generates a
.PN NoExpose
event whenever a graphics request that might
produce a
.PN GraphicsExpose
event does not produce any.
In other words, the client is really asking for a
.PN GraphicsExpose
event but instead receives a
.PN NoExpose
event.
.LP
To receive
.PN GraphicsExpose
or
.PN NoExpose
events, you must first set the graphics-exposure 
attribute of the graphics context to
.PN True .
You also can set the graphics-expose attribute when creating a graphics
context using
.PN XCreateGC 
or by calling
.PN XSetGraphicsExposures .
.LP
The structures for these event types contain:
.LP
.IN "XGraphicsExposeEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* GraphicsExpose */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Drawable drawable;
	int x, y;
	int width, height;
	int count;	/* if nonzero, at least this many more */
	int major_code;	/* core is CopyArea or CopyPlane */
	int minor_code;	/* not defined in the core */
} XGraphicsExposeEvent;
.De
.LP
.IN "XNoExposeEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* NoExpose */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Drawable drawable;
	int major_code;	/* core is CopyArea or CopyPlane */
	int minor_code;	/* not defined in the core */
} XNoExposeEvent;
.De
.LP
Both structures have these common members: drawable, major_code, and minor_code.
The drawable member is set to the drawable of the destination region on 
which the graphics request was to be performed.
The major_code member is set to the graphics request initiated by the client
and can be either
.PN X_CopyArea
or
.PN X_CopyPlane .
If it is
.PN X_CopyArea ,
a call to
.PN XCopyArea
initiated the request.
If it is
.PN X_CopyPlane ,
a call to
.PN XCopyPlane
initiated the request.
These constants are defined in 
.Pn < X11/Xproto.h >.
The minor_code member,
like the major_code member, 
indicates which graphics request was initiated by
the client. 
However, the minor_code member is not defined by the core
X protocol and will be zero in these cases, 
although it may be used by an extension.
.LP
The 
.PN XGraphicsExposeEvent
structure has these additional members: x, y, width, height, and count. 
The x and y members are set to the coordinates relative to the drawable's origin
and indicate the upper-left corner of the rectangle.
The width and height members are set to the size (extent) of the rectangle.
The count member is set to the number of
.PN GraphicsExpose
events to follow.
If count is zero, no more
.PN GraphicsExpose
events follow for this window.
However, if count is nonzero, at least that number of
.PN GraphicsExpose
events (and possibly more) are to follow for this window.
.NH 3
Window State Change Events 
.XS
\*(SN Window State Change Events
.XE
.LP
The following sections discuss:
.IP \(bu 5
.PN CirculateNotify
events
.IP \(bu 5
.PN ConfigureNotify
events
.IP \(bu 5
.PN CreateNotify 
events
.IP \(bu 5
.PN DestroyNotify
events
.IP \(bu 5
.PN GravityNotify
events
.IP \(bu 5
.PN MapNotify
events
.IP \(bu 5
.PN MappingNotify
events
.IP \(bu 5
.PN ReparentNotify 
events
.IP \(bu 5
.PN UnmapNotify
events
.IP \(bu 5
.PN VisibilityNotify
events
.\" .SH 3
.NH 4
CirculateNotify Events
.XS
\*(SN CirculateNotify Events
.XE
.LP
.IN "Events" "CirculateNotify"
.IN "CirculateNotify" "" "@DEF@"
The X server can report
.PN CirculateNotify
events to clients wanting information about when a window changes 
its position in the stack.
The X server generates this event type whenever a window is actually restacked 
as a result of a client application calling
.PN XCirculateSubwindows ,
.PN XCirculateSubwindowsUp ,
or
.PN XCirculateSubwindowsDown .
.LP
To receive 
.PN CirculateNotify
events, set the
.PN StructureNotifyMask
bit in the event-mask attribute of the window
or the
.PN SubstructureNotifyMask
bit in the event-mask attribute of the parent window
(in which case, circulating any child generates an event).
.LP
The structure for this event type contains:
.LP
.IN "XCirculateEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* CirculateNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int place;	/* PlaceOnTop, PlaceOnBottom */
} XCirculateEvent;
.De
.LP
The event member is set either to the restacked window or to its parent,
depending on whether
.PN StructureNotify
or
.PN SubstructureNotify
was selected.
The window member is set to the window that was restacked.
The place member is set to the window's position after the restack occurs and
is either
.PN PlaceOnTop
or
.PN PlaceOnBottom .
If it is
.PN PlaceOnTop ,
the window is now on top of all siblings.
If it is
.PN PlaceOnBottom ,
the window is now below all siblings.
.NH 4
ConfigureNotify Events
.XS
\*(SN ConfigureNotify Events
.XE
.LP
.IN "Events" "ConfigureNotify"
.IN "ConfigureNotify" "" "@DEF@"
The X server can report
.PN ConfigureNotify
events to clients wanting information about actual changes to a window's
state, such as size, position, border, and stacking order.
The X server generates this event type whenever one of the following configure 
window requests made by a client application actually completes:
.IP \(bu 5
A window's size, position, border, and/or stacking order is reconfigured 
by calling
.PN XConfigureWindow .
.IP \(bu 5
The window's position in the stacking order is changed by calling
.PN XLowerWindow ,
.PN XRaiseWindow ,
or
.PN XRestackWindows .
.IP \(bu 5
A window is moved by calling
.PN XMoveWindow .
.IP \(bu 5
A window's size is changed by calling
.PN XResizeWindow .
.IP \(bu 5
A window's size and location is changed by calling
.PN XMoveResizeWindow .
.IP \(bu 5
A window is mapped and its position in the stacking order is changed
by calling
.PN XMapRaised .
.IP \(bu 5
A window's border width is changed by calling
.PN XSetWindowBorderWidth .
.LP
To receive 
.PN ConfigureNotify
events, set the
.PN StructureNotifyMask
bit in the event-mask attribute of the window or the
.PN SubstructureNotifyMask
bit in the event-mask attribute of the parent window
(in which case, configuring any child generates an event).
.LP
The structure for this event type contains:
.LP
.IN "XConfigureEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* ConfigureNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int x, y;
	int width, height;
	int border_width;
	Window above;
	Bool override_redirect;
} XConfigureEvent;
.De
.LP
The event member is set either to the reconfigured window or to its parent,
depending on whether
.PN StructureNotify
or
.PN SubstructureNotify
was selected.
The window member is set to the window whose size, position, 
border, and/or stacking
order was changed.
.LP
The x and y members are set to the coordinates relative to the parent window's 
origin and indicate the position of the upper-left outside corner of the window.
The width and height members are set to the inside size of the window, 
not including
the border.
The border_width member is set to the width of the window's border, in pixels.
.LP
The above member is set to the sibling window and is used 
for stacking operations.
If the X server sets this member to
.PN None ,
the window whose state was changed is on the bottom of the stack
with respect to sibling windows.
However, if this member is set to a sibling window, 
the window whose state was changed is placed on top of this sibling window.
.LP
The override_redirect member is set to the override-redirect attribute of the
window.
Window manager clients normally should ignore this window if the 
override_redirect member
is
.PN True .
.NH 4
CreateNotify Events
.XS
\*(SN CreateNotify Events
.XE
.LP
.IN "Events" "CreateNotify"
.IN "CreateNotify" "" "@DEF@"
The X server can report
.PN CreateNotify
events to clients wanting information about creation of windows.
The X server generates this event whenever a client
application creates a window by calling
.PN XCreateWindow
or
.PN XCreateSimpleWindow .
.LP
To receive 
.PN CreateNotify
events, set the
.PN SubstructureNotifyMask
bit in the event-mask attribute of the window.
Creating any children then generates an event.
.LP
The structure for the event type contains:
.LP
.IN "XCreateWindowEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* CreateNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;	/* parent of the window */
	Window window;	/* window id of window created */
	int x, y;	/* window location */
	int width, height;	/* size of window */
	int border_width;	/* border width */
	Bool override_redirect;	/* creation should be overridden */
} XCreateWindowEvent;
.De
.LP
The parent member is set to the created window's parent.
The window member specifies the created window.
The x and y members are set to the created window's coordinates relative 
to the parent window's origin and indicate the position of the upper-left 
outside corner of the created window.
The width and height members are set to the inside size of the created window 
(not including the border) and are always nonzero.
The border_width member is set to the width of the created window's border, in pixels.
The override_redirect member is set to the override-redirect attribute of the
window.
Window manager clients normally should ignore this window 
if the override_redirect member is
.PN True .
.NH 4
DestroyNotify Events
.XS
\*(SN DestroyNotify Events
.XE
.LP
.IN "Events" "DestroyNotify"
.IN "DestroyNotify" "" "@DEF@"
The X server can report
.PN DestroyNotify
events to clients wanting information about which windows are destroyed.
The X server generates this event whenever a client application destroys a 
window by calling
.PN XDestroyWindow
or
.PN XDestroySubwindows .
.LP
The ordering of the 
.PN DestroyNotify 
events is such that for any given window, 
.PN DestroyNotify
is generated on all inferiors of the window
before being generated on the window itself.  
The X protocol does not constrain the ordering among
siblings and across subhierarchies.
.LP
To receive 
.PN DestroyNotify
events, set the
.PN StructureNotifyMask
bit in the event-mask attribute of the window or the
.PN SubstructureNotifyMask
bit in the event-mask attribute of the parent window
(in which case, destroying any child generates an event).
.LP
The structure for this event type contains:
.LP
.IN "XDestroyWindowEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* DestroyNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
} XDestroyWindowEvent;
.De
.LP
The event member is set either to the destroyed window or to its parent,
depending on whether
.PN StructureNotify
or 
.PN SubstructureNotify
was selected.
The window member is set to the window that is destroyed.
.NH 4
GravityNotify Events
.XS
\*(SN GravityNotify Events
.XE
.LP
.IN "Events" "GravityNotify"
.IN "GravityNotify" "" "@DEF@"
The X server can report
.PN GravityNotify
events to clients wanting information about when a window is moved because of a
change in the size of its parent.
The X server generates this event whenever a client
application actually moves a child window as a result of resizing its parent by calling
.PN XConfigureWindow ,
.PN XMoveResizeWindow ,
or
.PN XResizeWindow . 
.LP
To receive 
.PN GravityNotify
events, set the
.PN StructureNotifyMask
bit in the event-mask attribute of the window or the
.PN SubstructureNotifyMask
bit in the event-mask attribute of the parent window
(in which case, any child that is moved because its parent has been resized
generates an event).
.LP
The structure for this event type contains:
.LP
.IN "XGravityEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* GravityNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int x, y;
} XGravityEvent;
.De
.LP
The event member is set either to the window that was moved or to its parent,
depending on whether
.PN StructureNotify
or
.PN SubstructureNotify
was selected.
The window member is set to the child window that was moved.
The x and y members are set to the coordinates relative to the 
new parent window's origin
and indicate the position of the upper-left outside corner of the 
window.
.NH 4
MapNotify Events
.XS
\*(SN MapNotify Events
.XE
.LP
.IN "Events" "MapNotify"
.IN "MapNotify" "" "@DEF@"
The X server can report
.PN MapNotify
events to clients wanting information about which windows are mapped.
The X server generates this event type whenever a client application changes the
window's state from unmapped to mapped by calling
.PN XMapWindow ,
.PN XMapRaised ,
.PN XMapSubwindows ,
.PN XReparentWindow ,
or as a result of save-set processing.
.LP
To receive 
.PN MapNotify
events, set the
.PN StructureNotifyMask
bit in the event-mask attribute of the window or the
.PN SubstructureNotifyMask
bit in the event-mask attribute of the parent window
(in which case, mapping any child generates an event).
.LP
The structure for this event type contains:
.LP
.IN "XMapEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* MapNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	Bool override_redirect;	/* boolean, is override set... */
} XMapEvent;
.De
.LP
The event member is set either to the window that was mapped or to its parent,
depending on whether
.PN StructureNotify
or
.PN SubstructureNotify
was selected.
The window member is set to the window that was mapped.
The override_redirect member is set to the override-redirect attribute
of the window.
Window manager clients normally should ignore this window 
if the override-redirect attribute is
.PN True ,
because these events usually are generated from pop-ups,
which override structure control.
.NH 4
MappingNotify Events
.XS
\*(SN MappingNotify Events
.XE
.LP
.IN "Events" "MappingNotify"
.IN "MappingNotify" "" "@DEF@"
The X server reports
.PN MappingNotify
events to all clients.
There is no mechanism to express disinterest in this event.
The X server generates this event type whenever a client application 
successfully calls:
.IP \(bu 5
.PN XSetModifierMapping
to indicate which KeyCodes are to be used as modifiers
.IP \(bu 5
.PN XChangeKeyboardMapping
to change the keyboard mapping
.IP \(bu 5
.PN XSetPointerMapping
to set the pointer mapping
.LP
The structure for this event type contains:
.LP
.IN "XMappingEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* MappingNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	/* unused */
	int request;	/* one of MappingModifier, MappingKeyboard,
		   MappingPointer */
	int first_keycode;	/* first keycode */
	int count;	/* defines range of change w. first_keycode*/
} XMappingEvent;
.De
.LP
The request member is set to indicate the kind of mapping change that occurred
and can be
.PN MappingModifier ,
.PN MappingKeyboard ,
.PN MappingPointer .
If it is
.PN MappingModifier ,
the modifier mapping was changed.
If it is
.PN MappingKeyboard ,
the keyboard mapping was changed.
If it is
.PN MappingPointer ,
the pointer button mapping was changed. 
The first_keycode and count members are set only 
if the request member was set to
.PN MappingKeyboard .
The number in first_keycode represents the first number in the range 
of the altered mapping, 
and count represents the number of keycodes altered.
.LP
To update the client application's knowledge of the keyboard,
you should call
.PN XRefreshKeyboardMapping . 
.NH 4
ReparentNotify Events
.XS
\*(SN ReparentNotify Events
.XE
.LP
.IN "Events" "ReparentNotify"
.IN "ReparentNotify" "" "@DEF@"
The X server can report
.PN ReparentNotify
events to clients wanting information about changing a window's parent.
The X server generates this event whenever a client
application calls
.PN XReparentWindow 
and the window is actually reparented.
.LP
To receive 
.PN ReparentNotify
events, set the
.PN StructureNotifyMask
bit in the event-mask attribute of the window or the
.PN SubstructureNotifyMask
bit in the event-mask attribute of either the old or the new parent window
(in which case, reparenting any child generates an event).
.LP
The structure for this event type contains:
.LP
.IN "XReparentEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* ReparentNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	Window parent;
	int x, y;
	Bool override_redirect;
} XReparentEvent;
.De
.LP
The event member is set either to the reparented window
or to the old or the new parent, depending on whether
.PN StructureNotify
or
.PN SubstructureNotify
was selected. 
The window member is set to the window that was reparented.
The parent member is set to the new parent window.
The x and y members are set to the reparented window's coordinates relative 
to the new parent window's
origin and define the upper-left outer corner of the reparented window.
The override_redirect member is set to the override-redirect attribute of the
window specified by the window member.
Window manager clients normally should ignore this window 
if the override_redirect member is
.PN True .
.NH 4
UnmapNotify Events
.XS
\*(SN UnmapNotify Events
.XE
.LP
.IN "Events" "UnmapNotify"
.IN "UnmapNotify" "" "@DEF@"
The X server can report
.PN UnmapNotify
events to clients wanting information about which windows are unmapped.
The X server generates this event type whenever a client application changes the
window's state from mapped to unmapped.
.LP
To receive 
.PN UnmapNotify
events, set the
.PN StructureNotifyMask
bit in the event-mask attribute of the window or the
.PN SubstructureNotifyMask
bit in the event-mask attribute of the parent window
(in which case, unmapping any child window generates an event).
.LP
The structure for this event type contains:
.LP
.IN "XUnmapEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* UnmapNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	Bool from_configure;
} XUnmapEvent;
.De
.LP
The event member is set either to the unmapped window or to its parent,
depending on whether
.PN StructureNotify
or
.PN SubstructureNotify
was selected.
This is the window used by the X server to report the event.
The window member is set to the window that was unmapped.
The from_configure member is set to
.PN True 
if the event was generated as a result of a resizing of the window's parent when
the window itself had a win_gravity of
.PN UnmapGravity .
.NH 4
VisibilityNotify Events
.XS
\*(SN VisibilityNotify Events
.XE
.LP
.IN "Events" "VisibilityNotify"
.IN "VisibilityNotify" "" "@DEF@"
The X server can report
.PN VisibilityNotify
events to clients wanting any change in the visibility of the specified window.
A region of a window is visible if someone looking at the screen can
actually see it.
The X server generates this event whenever the visibility changes state. 
However, this event is never generated for windows whose class is
.PN InputOnly .
.LP
All 
.PN VisibilityNotify
events caused by a hierarchy change are generated
after any hierarchy event
.Pn ( UnmapNotify , 
.PN MapNotify , 
.PN ConfigureNotify ,
.PN GravityNotify ,
.PN CirculateNotify )
caused by that change.  Any
.PN VisibilityNotify
event on a given window is generated before any
.PN Expose 
events on that window, but it is not required that all
.PN VisibilityNotify
events on all windows be generated before all 
.PN Expose
events on all windows.  
The X protocol does not constrain the ordering of 
.PN VisibilityNotify
events with
respect to 
.PN FocusOut , 
.PN EnterNotify ,
and 
.PN LeaveNotify
events.
.LP
To receive 
.PN VisibilityNotify
events, set the
.PN VisibilityChangeMask
bit in the event-mask attribute of the window. 
.LP
The structure for this event type contains:
.LP
.IN "XVisibilityEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* VisibiltyNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int state;
} XVisibilityEvent;
.De
.LP
The window member is set to the window whose visibility state changes.
The state member is set to the state of the window's visibility and can be
.PN VisibilityUnobscured ,
.PN VisibilityPartiallyObscured ,
or
.PN VisibilityFullyObscured .
The X server ignores all of a window's subwindows
when determining the visibility state of the window and processes 
.PN VisibilityNotify
events according to the following:
.IP \(bu 5
When the window changes state from partially obscured, fully obscured,
or not viewable to viewable and completely unobscured,
the X server generates the event with the state member of the
.PN XVisibilityEvent
structure set to
.PN VisibilityUnobscured .
.IP \(bu 5
When the window changes state from viewable and completely unobscured or 
not viewable to viewable and partially obscured,
the X server generates the event with the state member of the
.PN XVisibilityEvent
structure set to
.PN VisibilityPartiallyObscured .
.IP \(bu 5
When the window changes state from viewable and completely unobscured, 
viewable and partially obscured, or not viewable to viewable and 
fully obscured,
the X server generates the event with the state member of the
.PN XVisibilityEvent
structure set to
.PN VisibilityFullyObscured .
.NH 3
Structure Control Events
.XS
\*(SN Structure Control Events
.XE
.LP
This section discusses:
.IP \(bu 5
.PN CirculateRequest
events
.IP \(bu 5
.PN ConfigureRequest
events
.IP \(bu 5
.PN MapRequest 
events
.IP \(bu 5
.PN ResizeRequest 
events
.NH 4 
CirculateRequest Events
.XS
\*(SN CirculateRequest Events
.XE
.LP
.IN "Events" "CirculateRequest"
.IN "CirculateRequest" "" "@DEF@"
The X server can report
.PN CirculateRequest
events to clients wanting information about 
when another client initiates a circulate window request 
on a specified window.
The X server generates this event type whenever a client initiates a circulate
window request on a window and a subwindow actually needs to be restacked. 
The client initiates a circulate window request on the window by calling
.PN XCirculateSubwindows ,
.PN XCirculateSubwindowsUp ,
or
.PN XCirculateSubwindowsDown .
.LP
To receive
.PN CirculateRequest
events, set the
.PN SubstructureRedirectMask
in the event-mask attribute of the window. 
Then, in the future,
the circulate window request for the specified window is not executed,
and thus, any subwindow's position in the stack is not changed.
For example, suppose a client application calls
.PN XCirculateSubwindowsUp
to raise a subwindow to the top of the stack.
If you had selected
.PN SubstructureRedirectMask
on the window, the X server reports to you a
.PN CirculateRequest
event and does not raise the subwindow to the top of the stack.
.LP
The structure for this event type contains:
.LP
.IN "XCirculateRequestEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* CirculateRequest */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
	int place;	/* PlaceOnTop, PlaceOnBottom */
} XCirculateRequestEvent;
.De
.LP
The parent member is set to the parent window.
The window member is set to the subwindow to be restacked.
The place member is set to what the new position in the stacking order should be
and is either
.PN PlaceOnTop
or
.PN PlaceOnBottom .
If it is
.PN PlaceOnTop ,
the subwindow should be on top of all siblings.
If it is
.PN PlaceOnBottom ,
the subwindow should be below all siblings.
.NH 4
ConfigureRequest Events
.XS
\*(SN ConfigureRequest Events
.XE
.LP
.IN "Events" "ConfigureRequest"
.IN "ConfigureRequest" "" "@DEF@"
The X server can report
.PN ConfigureRequest
events to clients wanting information about when a different client initiates 
a configure window request on any child of a specified window. 
The configure window request attempts to 
reconfigure a window's size, position, border, and stacking order.
The X server generates this event whenever a different client initiates
a configure window request on a window by calling
.PN XConfigureWindow ,
.PN XLowerWindow ,
.PN XRaiseWindow ,
.PN XMapRaised ,
.PN XMoveResizeWindow ,
.PN XMoveWindow ,
.PN XResizeWindow ,
.PN XRestackWindows ,
or
.PN XSetWindowBorderWidth .
.LP
To receive
.PN ConfigureRequest
events, set the
.PN SubstructureRedirectMask
bit in the event-mask attribute of the window. 
.PN ConfigureRequest
events are generated when a
.PN ConfigureWindow
protocol request is issued on a child window by another client.
For example, suppose a client application calls
.PN XLowerWindow
to lower a window.
If you had selected
.PN SubstructureRedirectMask 
on the parent window and if the override-redirect attribute 
of the window is set to
.PN False ,
the X server reports a
.PN ConfigureRequest
event to you and does not lower the specified window.
.LP
The structure for this event type contains:
.LP
.IN "XConfigureRequestEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* ConfigureRequest */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
	int x, y;
	int width, height;
	int border_width;
	Window above;
	int detail;	/* Above, Below, TopIf, BottomIf, Opposite */
	unsigned long value_mask;
} XConfigureRequestEvent;
.De
.LP
The parent member is set to the parent window.
The window member is set to the window whose size, position, border width, 
and/or stacking order is to be reconfigured.
The value_mask member indicates which components were specified in the
.PN ConfigureWindow 
protocol request.
The corresponding values are reported as given in the request.
The remaining values are filled in from the current geometry of the window,
except in the case of above (sibling) and detail (stack-mode),
which are reported as
.PN Above
and
.PN None ,
respectively, if they are not given in the request.
.NH 4
MapRequest Events
.XS
\*(SN MapRequest Events
.XE
.LP
.IN "Events" "MapRequest"
.IN "MapRequest" "" "@DEF@"
The X server can report
.PN MapRequest
events to clients wanting information about a different client's desire 
to map windows.
A window is considered mapped when a map window request completes.
The X server generates this event whenever a different client initiates 
a map window request on an unmapped window whose override_redirect member 
is set to
.PN False .
Clients initiate map window requests by calling
.PN XMapWindow ,
.PN XMapRaised ,
or
.PN XMapSubwindows .
.LP
To receive
.PN MapRequest
events, set the
.PN SubstructureRedirectMask
bit in the event-mask attribute of the window. 
This means another client's attempts to map a child window by calling one of
the map window request functions is intercepted, and you are sent a 
.PN MapRequest
instead.
For example, suppose a client application calls
.PN XMapWindow
to map a window.
If you (usually a window manager) had selected
.PN SubstructureRedirectMask 
on the parent window and if the override-redirect attribute 
of the window is set to
.PN False ,
the X server reports a
.PN MapRequest
event to you 
and does not map the specified window.
Thus, this event gives your window manager client the ability 
to control the placement of subwindows.
.LP
The structure for this event type contains:
.LP
.IN "XMapRequestEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* MapRequest */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
} XMapRequestEvent;
.De
.LP
The parent member is set to the parent window.
The window member is set to the window to be mapped.
.NH 4
ResizeRequest Events
.XS
\*(SN ResizeRequest Events
.XE
.LP
.IN "Events" "ResizeRequest"
.IN "ResizeRequest" "" "@DEF@"
The X server can report
.PN ResizeRequest
events to clients wanting information about another client's attempts to change the
size of a window.
The X server generates this event whenever some other client attempts to change
the size of the specified window by calling
.PN XConfigureWindow ,
.PN XResizeWindow ,
or
.PN XMoveResizeWindow .
.LP
To receive
.PN ResizeRequest
events, set the
.PN ResizeRedirect
bit in the event-mask attribute of the window. 
Any attempts to change the size by other clients are then redirected.
.LP
The structure for this event type contains:
.LP
.IN "XResizeRequestEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* ResizeRequest */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int width, height;
} XResizeRequestEvent;
.De
.LP
The window member is set to the window whose size another 
client attempted to change.
The width and height members are set to the inside size of the window, 
excluding the border.
.NH 3
Colormap State Change Events
.XS
\*(SN Colormap State Change Events
.XE
.LP
.IN "Events" "ColormapNotify"
.IN "ColormapNotify" "" "@DEF@"
The X server can report
.PN ColormapNotify
events to clients wanting information about when the colormap changes 
and when a colormap is installed or uninstalled. 
The X server generates this event type whenever a client application:
.IP \(bu 5
Changes the colormap member of the
.PN XSetWindowAttributes
structure by 
calling
.PN XChangeWindowAttributes ,
.PN XFreeColormap ,
or
.PN XSetWindowColormap 
.IP \(bu 5
Installs or uninstalls the colormap by calling
.PN XInstallColormap
or
.PN XUninstallColormap 
.LP
To receive 
.PN ColormapNotify 
events, set the
.PN ColormapChangeMask
bit in the event-mask attribute of the window. 
.LP
The structure for this event type contains:
.LP
.IN "XColormapEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* ColormapNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Colormap colormap;	/* colormap or None */
	Bool new;
	int state;	/* ColormapInstalled, ColormapUninstalled */
} XColormapEvent;
.De
.LP
The window member is set to the window whose associated 
colormap is changed, installed, or uninstalled.
For a colormap that is changed, installed, or uninstalled,
the colormap member is set to the colormap associated with the window. 
For a colormap that is changed by a call to
.PN XFreeColormap ,
the colormap member is set to
.PN None .
The new member is set to indicate whether the colormap 
for the specified window was changed or installed or uninstalled
and can be 
.PN True
or
.PN False .
If it is
.PN True ,
the colormap was changed.
If it is
.PN False ,
the colormap was installed or uninstalled.
The state member is always set to indicate whether the colormap is installed or
uninstalled and can be 
.PN ColormapInstalled
or
.PN ColormapUninstalled .
.NH 3
Client Communication Events
.XS
\*(SN Client Communication Events
.XE
.LP
This section discusses:
.IP \(bu 5
.PN ClientMessage 
events
.IP \(bu 5
.PN PropertyNotify
events
.IP \(bu 5
.PN SelectionClear
events
.IP \(bu 5
.PN SelectionNotify
events
.IP \(bu 5
.PN SelectionRequest
events
.NH 4
ClientMessage Events
.XS
\*(SN ClientMessage Events
.XE
.LP
.IN "Events" "ClientMessage"
.IN "ClientMessage" "" "@DEF@"
The X server generates
.PN ClientMessage
events only when a client calls the function
.PN XSendEvent .
.LP
The structure for this event type contains:
.LP
.IN "XClientMessageEvent" "" "@DEF@"
.Ds 0
.TA .5i 1i 3i
.ta .5i 1i 3i
typedef struct {
	int type;	/* ClientMessage */
	unsigned long serial;		/* # of last request processed by server */
	Bool send_event;		/* true if this came from a SendEvent request */
	Display *display;		/* Display the event was read from */
	Window window;
	Atom message_type;
	int format;
	union {
		char b[20];
		short s[10];
		long l[5];
	        } data;
} XClientMessageEvent;
.De
.LP
The message_type member is set to an atom that indicates how the data 
should be interpreted by the receiving client.
The format member is set to 8, 16, or 32 and specifies whether the data
should be viewed as a list of bytes, shorts, or longs.
The data member is a union that contains the members b, s, and l.
The b, s, and l members represent data of 20 8-bit values, 
10 16-bit values, and 5 32-bit values.
Particular message types might not make use of all these values.
The X server places no interpretation on the values in the message_type or 
data members.
.NH 4
PropertyNotify Events
.XS
\*(SN PropertyNotify Events
.XE
.LP
.IN "Events" "PropertyNotify"
.IN "PropertyNotify" "" "@DEF@"
The X server can report
.PN PropertyNotify
events to clients wanting information about property changes 
for a specified window.
.LP
To receive
.PN PropertyNotify
events, set the
.PN PropertyChangeMask
bit in the event-mask attribute of the window. 
.LP
The structure for this event type contains:
.LP
.IN "XPropertyEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* PropertyNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom atom;
	Time time;
	int state;	/* PropertyNewValue or PropertyDeleted */
} XPropertyEvent;
.De
.LP
The window member is set to the window whose associated 
property was changed.
The atom member is set to the property's atom and indicates which
property was changed or desired.
The time member is set to the server time when the property was changed.
The state member is set to indicate whether the property was changed 
to a new value or deleted and can be
.PN PropertyNewValue
or
.PN PropertyDelete .
The state member is set to
.PN PropertyNewValue
when a property of the window is changed using
.PN XChangeProperty
or
.PN XRotateWindowProperties
(even when adding zero-length data using
.PN XChangeProperty )
and when replacing all or part of a property with identical data using
.PN XChangeProperty
or 
.PN XRotateWindowProperties .
The state member is set to
.PN PropertyDelete
when a property of the window is deleted using
.PN XDeleteProperty
or, if the delete argument is 
.PN True ,
.PN XGetWindowProperty .
.NH 4
SelectionClear Events
.XS
\*(SN SelectionClear Events
.XE
.LP
.IN "Events" "SelectionClear" 
.IN "SelectionClear" "" "@DEF@"
The X server reports
.PN SelectionClear
events to the current owner of a selection.
The X server generates this event type on the window losing ownership of the
selection to a new owner.
This sequence of events could occur whenever a client calls
.PN XSetSelectionOwner .
.LP
The structure for this event type contains:
.LP
.IN "XSelectionClearEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* SelectionClear */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom selection;
	Time time;
} XSelectionClearEvent;
.De
.LP
The window member is set to the window losing ownership of 
the selection.
The selection member is set to the selection atom.
The time member is set to the last change time recorded for the 
selection.
The owner member is the window that was specified by the current owner
in its
.PN XSetSelectionOwner
call.
.NH 4
SelectionRequest Events
.XS
\*(SN SelectionRequest Events
.XE
.LP
.IN "Events" "SelectionRequest"
.IN "SelectionRequest" "" "@DEF@"
The X server reports
.PN SelectionRequest
events to the owner of a selection.
The X server generates this event whenever a client 
requests a selection conversion by calling 
.PN XConvertSelection 
and the specified selection is owned by a window.
.LP
The structure for this event type contains:
.LP
.IN "XSelectionRequestEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* SelectionRequest */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window owner;
	Window requestor;
	Atom selection;
	Atom target;
	Atom property;
	Time time;
} XSelectionRequestEvent;
.De
.LP
The owner member is set to the window owning the selection
and is the window that was specified by the current owner in its
.PN XSetSelectionOwner
call.
The requestor member is set to the window requesting the selection.
The selection member is set to the atom that names the selection.
For example, PRIMARY is used to indicate the primary selection.
The target member is set to the atom that indicates the type
the selection is desired in.
The property member can be a property name or 
.PN None .
The time member is set to the time
and is a timestamp or 
.PN CurrentTime 
from the
.PN ConvertSelection
request.
.LP
The owner should convert the selection based on the specified target type
and send a
.PN SelectionNotify
event back to the requestor.
A complete specification for using selections is given in the X Consortium
standard \fIInter-Client Communication Conventions Manual\fP.
.NH 4
SelectionNotify Events
.XS
\*(SN SelectionNotify Events
.XE
.LP
.IN "Events" "SelectionNotify"
.IN "SelectionNotify" "" "@DEF@"
This event is generated by the X server in response to a
.PN ConvertSelection 
protocol request when there is no owner for the selection.
When there is an owner, it should be generated by the owner
of the selection by using
.PN XSendEvent .
The owner of a selection should send this event to a requestor when a selection
has been converted and stored as a property
or when a selection conversion could
not be performed (which is indicated by setting the property member to
.PN None ).
.LP
If
.PN None
is specified as the property in the 
.PN ConvertSelection
protocol request, the owner should choose a property name,
store the result as that property on the requestor window,
and then send a 
.PN SelectionNotify
giving that actual property name.
.LP
The structure for this event type contains:
.LP
.IN "XSelectionEvent" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	int type;	/* SelectionNotify */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window requestor;
	Atom selection;
	Atom target;
	Atom property;	/* atom or None */
	Time time;
} XSelectionEvent;
.De
.LP
The requestor member is set to the window associated with
the requestor of the selection.
The selection member is set to the atom that indicates the selection.
For example, PRIMARY is used for the primary selection.
The target member is set to the atom that indicates the converted type.
For example, PIXMAP is used for a pixmap.
The property member is set to the atom that indicates which
property the result was stored on.
If the conversion failed, 
the property member is set to
.PN None .
The time member is set to the time the conversion took place and
can be a timestamp or
.PN CurrentTime .
.NH 2
Selecting Events
.XS
\*(SN Selecting Events 
.XE
.LP
There are two ways to select the events you want reported to your client
application.
One way is to set the event_mask member of the
.PN XSetWindowAttributes
structure when you call
.PN XCreateWindow
and
.PN XChangeWindowAttributes .
Another way is to use
.PN XSelectInput . 
.IN "XSelectInput" "" "@DEF@"
.FD 0
.\" $Header: XSelectInput.f,v 1.2 88/05/04 06:25:22 mento Exp $
XSelectInput\^(\^\fIdisplay\fP, \fIw\fP\^, \fIevent_mask\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      Window \fIw\fP\^;
.br
      long \fIevent_mask\fP\^;
.FN	
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.ds Wi whose events you are interested in
.\" $Header: w_gen.a,v 1.4 88/08/04 11:21:56 mento Exp $
.IP \fIw\fP 1i
Specifies the window \*(Wi.
.\" $Header: eventmask.a,v 1.2 88/05/14 13:04:06 mento Exp $
.IP \fIevent_mask\fP 1i
Specifies the event mask.
.LP 
.\" $Header: XSelectInput.d,v 1.3 88/06/11 07:52:55 mento Exp $
The
.PN XSelectInput
function requests that the X server report the events associated with the 
specified event mask.
Initially, X will not report any of these events.
Events are reported relative to a window.
If a window is not interested in a device event, it usually propagates to
the closest ancestor that is interested,
unless the do_not_propagate mask prohibits it.
.IN "Event" "propagation"
.LP
Setting the event-mask attribute of a window overrides any previous call
for the same window but not for other clients.
Multiple clients can select for the same events on the same window
with the following restrictions:
.IP \(bu 5
Multiple clients can select events on the same window because their event masks
are disjoint.
When the X server generates an event, it reports it
to all interested clients.
.IP \(bu 5
Only one client at a time can select
.PN CirculateRequest ,
.PN ConfigureRequest ,
or
.PN MapRequest
events, which are associated with
the event mask
.PN SubstructureRedirectMask . 
.IP \(bu 5
Only one client at a time can select
a
.PN ResizeRequest
event, which is associated with
the event mask
.PN ResizeRedirectMask . 
.IP \(bu 5
Only one client at a time can select a 
.PN ButtonPress 
event, which is associated with
the event mask
.PN ButtonPressMask .
.LP
The server reports the event to all interested clients.
.LP
.PN XSelectInput
can generate a
.PN BadWindow 
error.
.NH 2
Handling the Output Buffer
.XS
\*(SN Handling the Output Buffer
.XE
.LP
The output buffer is an area used by Xlib to store requests.
The functions described in this section flush the output buffer
if the function would block or not return an event.
That is, all requests residing in the output buffer that
have not yet been sent are transmitted to the X server.
These functions differ in the additional tasks they might perform.
.LP
.sp
To flush the output buffer, use 
.PN XFlush .
.IN "XFlush" "" "@DEF@"
.FD 0
.\" $Header: XFlush.f,v 1.1 88/02/26 10:00:10 mento Exp $
XFlush\^(\^\fIdisplay\fP\^)
.br
      Display *\fIdisplay\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.LP
.\" $Header: XFlush.d,v 1.2 88/06/11 07:50:19 mento Exp $
The
.PN XFlush
function
flushes the output buffer.
Most client applications need not use this function because the output
buffer is automatically flushed as needed by calls to
.PN XPending ,
.PN XNextEvent ,
and
.PN XWindowEvent .
.IN "XPending"
.IN "XNextEvent"
.IN "XWindowEvent"
Events generated by the server may be enqueued into the library's event queue.
.LP
.sp
To flush the output buffer and then wait until all requests have been processed,
use 
.PN XSync .
.IN "XSync" "" "@DEF@"
.FD 0
.\" $Header: XSync.f,v 1.2 88/04/07 12:52:07 mento Exp $
XSync\^(\^\fIdisplay\fP, \fIdiscard\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      Bool \fIdiscard\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: discard.a,v 1.3 88/05/14 13:09:22 mento Exp $
.IP \fIdiscard\fP 1i
Specifies a Boolean value that indicates whether 
.PN XSync
discards all events on the event queue.
.LP
.\" $Header: XSync.d,v 1.2 88/06/11 07:53:53 mento Exp $
The
.PN XSync
function
flushes the output buffer and then waits until all requests have been received
and processed by the X server.
Any errors generated must be handled by the error handler.
For each error event received by Xlib,
.PN XSync
calls the client application's error handling routine (see section 8.12.2).
Any events generated by the server are enqueued into the library's 
event queue.
.LP
Finally, if you passed 
.PN False ,
.PN XSync
does not discard the events in the queue.
If you passed 
.PN True ,
.PN XSync 
discards all events in the queue,
including those events that were on the queue before
.PN XSync
was called.
Client applications seldom need to call
.PN XSync .
.NH 2
Event Queue Management
.XS
\*(SN Event Queue Management
.XE
.LP
Xlib maintains an event queue.
However, the operating system also may be buffering data 
in its network connection that is not yet read into the event queue.
.LP
.sp
To check the number of events in the event queue, use
.PN XEventsQueued .
.IN "XEventsQueued" "" "@DEF@"
.FD 0
int XEventsQueued\^(\^\fIdisplay\fP, \fImode\fP\^)
.br
     Display *\fIdisplay\fP\^;
.br
     int \fImode\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.IP \fImode\fP 1i
Specifies the mode.
You can pass
.PN QueuedAlready ,
.PN QueuedAfterFlush ,
or
.PN QueuedAfterReading .
.LP
If mode is 
.PN QueuedAlready ,
.PN XEventsQueued 
returns the number of events
already in the event queue (and never performs a system call).
If mode is 
.PN QueuedAfterFlush , 
.PN XEventsQueued
returns the number of events already in the queue if the number is nonzero.
If there are no events in the queue, 
.PN XEventsQueued
flushes the output buffer, 
attempts to read more events out of the application's connection,
and returns the number read.
If mode is 
.PN QueuedAfterReading , 
.PN XEventsQueued
returns the number of events already in the queue if the number is nonzero. 
If there are no events in the queue, 
.PN XEventsQueued
attempts to read more events out of the application's connection 
without flushing the output buffer and returns the number read.
.LP
.PN XEventsQueued
always returns immediately without I/O if there are events already in the
queue.
.PN XEventsQueued
with mode 
.PN QueuedAfterFlush
is identical in behavior to
.PN XPending .
.PN XEventsQueued
with mode
.PN QueuedAlready
is identical to the
.PN XQLength
function.
.LP
.sp
To return the number of events that are pending, use 
.PN XPending .
.IN "XPending" "" "@DEF@"
.FD 0
.\" $Header: XPending.f,v 1.1 88/02/26 10:01:44 mento Exp $
int XPending\^(\^\fIdisplay\fP\^)
.br
      Display *\fIdisplay\fP\^;
.FN	
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.LP
.\" $Header: XPending.d,v 1.2 88/06/11 07:52:06 mento Exp $
The
.PN XPending
function returns the number of events that have been received from the
X server but have not been removed from the event queue.
.PN XPending
is identical to
.PN XEventsQueued
with the mode
.PN QueuedAfterFlush
specified.
.NH 2
Manipulating the Event Queue
.XS
\*(SN Manipulating the Event Queue 
.XE
.LP
Xlib provides functions that let you manipulate the event queue.
The next three sections discuss how to:
.IP \(bu 5
Obtain events, in order, and remove them from the queue
.IP \(bu 5
Peek at events in the queue without removing them
.IP \(bu 5
Obtain events that match the event mask or the arbitrary
predicate procedures that you provide
.NH 3
Returning the Next Event
.XS
\*(SN Returning the Next Event
.XE
.LP
To get the next event and remove it from the queue, use
.PN XNextEvent .
.IN "XNextEvent" "" "@DEF@"
.FD 0
.\" $Header: XNextEvent.f,v 1.1 88/02/26 10:01:33 mento Exp $
XNextEvent\^(\^\fIdisplay\fP, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: event_next.a,v 1.1 88/04/08 14:22:34 mento Exp $
.IP \fIevent_return\fP 1i
Returns the next event in the queue.
.LP
.\" $Header: XNextEvent.d,v 1.2 88/06/11 07:52:01 mento Exp $
The
.PN XNextEvent
function copies the first event from the event queue into the specified
.PN XEvent
structure and then removes it from the queue.
If the event queue is empty,
.PN XNextEvent
flushes the output buffer and blocks until an event is received.
.LP
.sp
To peek at the event queue, use
.PN XPeekEvent .
.IN "XPeekEvent" "" "@DEF@"
.FD 0
.\" $Header: XPeekEvent.f,v 1.1 88/02/26 10:01:43 mento Exp $
XPeekEvent\^(\^\fIdisplay\fP, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.IP \fIevent_return\fP 1i
Returns a copy of the matched event's associated structure.
.LP
.\" $Header: XPeekEvent.d,v 1.2 88/06/11 07:52:05 mento Exp $
The
.PN XPeekEvent
function returns the first event from the event queue,
but it does not remove the event from the queue.
If the queue is empty,
.PN XPeekEvent
flushes the output buffer and blocks until an event is received.
It then copies the event into the client-supplied
.PN XEvent
structure without removing it from the event queue.
.NH 3
Selecting Events Using a Predicate Procedure
.XS
\*(SN Selecting Events Using a Predicate Procedure
.XE
.LP
Each of the functions discussed in this section requires you to
pass a predicate procedure that determines if an event matches 
what you want.
Your predicate procedure must decide only if the event is useful
and must not call Xlib functions.
In particular,
a predicate is called from inside the event routine,
which must lock data structures so that the event queue is consistent in a 
multi-threaded environment.
.LP
The predicate procedure and its associated arguments are:
.FD 0
Bool (\^*\fIpredicate\fP\^)\^(\^\fIdisplay\fP, \fIevent\fP, \fIarg\fP\^)
.br
     Display *\fIdisplay\fP\^;
.br
     XEvent *\fIevent\fP\^;
.br
     char *\fIarg\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.IP \fIevent\fP 1i
Specifies a pointer to the 
.PN XEvent
structure.
.IP \fIarg\fP 1i
Specifies the argument passed in from the 
.PN XIfEvent ,
.PN XCheckIfEvent ,
or
.PN XPeekIfEvent 
function.
.LP
The predicate procedure is called once for each
event in the queue until it finds a match. 
After finding a match, the predicate procedure must return 
.PN True .
If it did not find a match, it must return
.PN False .
.LP
.sp
To check the event queue for a matching event
and, if found, remove the event from the queue, use
.PN XIfEvent .
.IN "XIfEvent" "" "@DEF@"
.FD 0
XIfEvent\^(\^\fIdisplay\fP, \fIevent_return\fP, \fIpredicate\fP, \fIarg\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.br
      Bool (\^*\fIpredicate\fP\^)\^(\^)\^;
.br
      char *\fIarg\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: event.a,v 1.4 88/05/14 13:23:54 mento Exp $
.IP \fIevent_return\fP 1i
Returns the matched event's associated structure.
.IP \fIpredicate\fP 1i
Specifies the procedure that is to be called to determine
if the next event in the queue matches what you want.
.IP \fIarg\fP 1i
Specifies the user-supplied argument that will be passed to the predicate procedure.
.LP
.\" $Header: XIfEvent.d,v 1.2 88/06/11 07:51:39 mento Exp $
The
.PN XIfEvent
function completes only when the specified predicate
procedure returns 
.PN True 
for an event, 
which indicates an event in the queue matches.
.PN XIfEvent
flushes the output buffer if it blocks waiting for additional events.
.PN XIfEvent
removes the matching event from the queue 
and copies the structure into the client-supplied
.PN XEvent
structure.
.LP
.sp
To check the event queue for a matching event without blocking, use
.PN XCheckIfEvent .
.IN "XCheckIfEvent" "" "@DEF@"
.FD 0
Bool XCheckIfEvent\^(\^\fIdisplay\fP, \fIevent_return\fP, \fIpredicate\fP, \fIarg\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.br
      Bool (\^*\fIpredicate\fP\^)\^(\^)\^;
.br
      char *\fIarg\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.IP \fIevent_return\fP 1i
Returns a copy of the matched event's associated structure.
.IP \fIpredicate\fP 1i
Specifies the procedure that is to be called to determine
if the next event in the queue matches what you want.
.IP \fIarg\fP 1i
Specifies the user-supplied argument that will be passed to the predicate procedure.
.LP
.\" $Header: XCkIfEvent.d,v 1.2 88/06/11 07:49:21 mento Exp $
When the predicate procedure finds a match,
.PN XCheckIfEvent
copies the matched event into the client-supplied
.PN XEvent
structure and returns 
.PN True .
(This event is removed from the queue.)
If the predicate procedure finds no match,
.PN XCheckIfEvent
returns
.PN False ,
and the output buffer will have been flushed.
All earlier events stored in the queue are not discarded.
.LP
.sp
To check the event queue for a matching event
without removing the event from the queue, use
.PN XPeekIfEvent .
.IN "XPeekIfEvent" "" "@DEF@"
.FD 0
XPeekIfEvent\^(\^\fIdisplay\fP, \fIevent_return\fP, \fIpredicate\fP, \fIarg\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.br
      Bool (\^*\fIpredicate\fP\^)\^(\^)\^;
.br
      char *\fIarg\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.IP \fIevent_return\fP 1i
Returns a copy of the matched event's associated structure.
.IP \fIpredicate\fP 1i
Specifies the procedure that is to be called to determine
if the next event in the queue matches what you want.
.IP \fIarg\fP 1i
Specifies the user-supplied argument that will be passed to the predicate procedure.
.LP
.\" $Header: XPkIfEvent.d,v 1.3 88/06/11 07:52:13 mento Exp $
The
.PN XPeekIfEvent
function returns only when the specified predicate
procedure returns 
.PN True
for an event.
After the predicate procedure finds a match,
.PN XPeekIfEvent
copies the matched event into the client-supplied
.PN XEvent
structure without removing the event from the queue.
.PN XPeekIfEvent
flushes the output buffer if it blocks waiting for additional events.
.NH 3
Selecting Events Using a Window or Event Mask
.XS
\*(SN Selecting Events Using a Window or Event Mask
.XE
.LP
The functions discussed in this section let you select events by window 
or event types, allowing you to process events out of order.
.LP
.sp
To remove the next event that matches both a window and an event mask, use
.PN XWindowEvent .
.IN "XWindowEvent" "" "@DEF@"
.FD 0
.\" $Header: XWindowEvent.f,v 1.1 88/02/26 10:04:15 mento Exp $
XWindowEvent\^(\^\fIdisplay\fP, \fIw\fP\^, \fIevent_mask\fP\^, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      Window \fIw\fP\^;
.br
      long \fIevent_mask\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.ds Wi whose events you are interested in
.\" $Header: w_gen.a,v 1.4 88/08/04 11:21:56 mento Exp $
.IP \fIw\fP 1i
Specifies the window \*(Wi.
.\" $Header: eventmask.a,v 1.2 88/05/14 13:04:06 mento Exp $
.IP \fIevent_mask\fP 1i
Specifies the event mask.
.\" $Header: event.a,v 1.4 88/05/14 13:23:54 mento Exp $
.IP \fIevent_return\fP 1i
Returns the matched event's associated structure.
.LP
.\" $Header: XWindowEvent.d,v 1.2 88/06/11 07:54:37 mento Exp $
The
.PN XWindowEvent
function searches the event queue for an event that matches both the specified
window and event mask.
When it finds a match,
.PN XWindowEvent
removes that event from the queue and copies it into the specified
.PN XEvent
structure.
The other events stored in the queue are not discarded.
If a matching event is not in the queue,
.PN XWindowEvent
flushes the output buffer and blocks until one is received.
.LP
.sp
To remove the next event that matches both a window and an event mask (if any),
use
.PN XCheckWindowEvent .
.IN "XCheckWindowEvent"
This function is similar to
.PN XWindowEvent 
except that it never blocks and it returns a 
.PN Bool 
indicating if the event was returned.
.IN "XCheckWindowEvent" "" "@DEF@"
.FD 0
.\" $Header: XChkWinEvnt.f,v 1.2 88/05/04 06:26:26 mento Exp $
Bool XCheckWindowEvent\^(\^\fIdisplay\fP, \fIw\fP\^, \fIevent_mask\fP\^, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      Window \fIw\fP\^;
.br
      long \fIevent_mask\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.ds Wi whose events you are interested in
.\" $Header: w_gen.a,v 1.4 88/08/04 11:21:56 mento Exp $
.IP \fIw\fP 1i
Specifies the window \*(Wi.
.\" $Header: eventmask.a,v 1.2 88/05/14 13:04:06 mento Exp $
.IP \fIevent_mask\fP 1i
Specifies the event mask.
.\" $Header: event.a,v 1.4 88/05/14 13:23:54 mento Exp $
.IP \fIevent_return\fP 1i
Returns the matched event's associated structure.
.LP
.\" $Header: XChkWinEvnt.d,v 1.4 88/06/11 07:49:18 mento Exp $
The
.PN XCheckWindowEvent
function searches the event queue and then the events available 
on the server connection for the first event that matches the specified window
and event mask.
If it finds a match,
.PN XCheckWindowEvent
removes that event, copies it into the specified
.PN XEvent
structure, and returns
.PN True .
The other events stored in the queue are not discarded.
If the event you requested is not available,
.PN XCheckWindowEvent
returns
.PN False ,
and the output buffer will have been flushed.
.LP
.sp
To remove the next event that matches an event mask, use
.PN XMaskEvent .
.IN "XMaskEvent" "" "@DEF@"
.FD 0
.\" $Header: XMaskEvent.f,v 1.2 88/05/04 06:27:18 mento Exp $
XMaskEvent\^(\^\fIdisplay\fP, \fIevent_mask\fP\^, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      long \fIevent_mask\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: eventmask.a,v 1.2 88/05/14 13:04:06 mento Exp $
.IP \fIevent_mask\fP 1i
Specifies the event mask.
.PN XMaskEvent
.\" $Header: event.a,v 1.4 88/05/14 13:23:54 mento Exp $
.IP \fIevent_return\fP 1i
Returns the matched event's associated structure.
.LP
.\" $Header: XMaskEvent.d,v 1.3 88/06/11 07:51:58 mento Exp $
The
.PN XMaskEvent
function searches the event queue for the events associated with the 
specified mask.
When it finds a match,
.PN XMaskEvent
removes that event and copies it into the specified
.PN XEvent
structure.
The other events stored in the queue are not discarded.
If the event you requested is not in the queue,
.PN XMaskEvent
flushes the output buffer and blocks until one is received.
.LP
.sp
To return and remove the next event that matches an event mask (if any), use
.PN XCheckMaskEvent .
This function is similar to 
.PN XMaskEvent 
except that it never blocks and it returns a 
.PN Bool 
indicating if the event was returned.
.IN "XCheckMaskEvent" "" "@DEF@"
.FD 0
.\" $Header: XChkMskEvnt.f,v 1.2 88/05/04 06:28:11 mento Exp $
Bool XCheckMaskEvent\^(\^\fIdisplay\fP, \fIevent_mask\fP\^, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      long \fIevent_mask\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: eventmask.a,v 1.2 88/05/14 13:04:06 mento Exp $
.IP \fIevent_mask\fP 1i
Specifies the event mask.
.\" $Header: event.a,v 1.4 88/05/14 13:23:54 mento Exp $
.IP \fIevent_return\fP 1i
Returns the matched event's associated structure.
.LP
.\" $Header: XChkMskEvnt.d,v 1.4 88/06/11 07:49:13 mento Exp $
The
.PN XCheckMaskEvent
function searches the event queue and then any events available on the
server connection for the first event that matches the specified mask.
If it finds a match,
.PN XCheckMaskEvent
removes that event, copies it into the specified
.PN XEvent
structure, and returns
.PN True .
The other events stored in the queue are not discarded.
If the event you requested is not available,
.PN XCheckMaskEvent
returns
.PN False ,
and the output buffer will have been flushed.
.LP
.sp 
To return and remove the next event in the queue that matches an event type, use
.PN XCheckTypedEvent .
.IN "XCheckTypedEvent" "" "@DEF@"
.FD 0
.\" $Header: XChkTypEvnt.f,v 1.1 88/02/26 09:58:39 mento Exp $
Bool XCheckTypedEvent\^(\^\fIdisplay\fP, \fIevent_type\fP\^, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      int \fIevent_type\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: event_type.a,v 1.1 88/02/26 10:26:48 mento Exp $
.IP \fIevent_type\fP 1i
Specifies the event type to be compared.

.\" $Header: event.a,v 1.4 88/05/14 13:23:54 mento Exp $
.IP \fIevent_return\fP 1i
Returns the matched event's associated structure.
.LP
The
.PN XCheckTypedEvent
function searches the event queue and then any events available  
on the server connection for the first event that matches the specified type.
If it finds a match,
.PN XCheckTypedEvent
removes that event, copies it into the specified
.PN XEvent
structure, and returns
.PN True .
The other events in the queue are not discarded.
If the event is not available,
.PN XCheckTypedEvent
returns
.PN False ,
and the output buffer will have been flushed.
.LP
.sp
To return and remove the next event in the queue that matches an event type 
and a window, use
.PN XCheckTypedWindowEvent .
.IN "XCheckTypedWindowEvent" "" "@DEF@"
.FD 0
.\" $Header: XChkTypWEvnt.f,v 1.1 88/02/26 09:58:39 mento Exp $
Bool XCheckTypedWindowEvent\^(\^\fIdisplay\fP, \fIw\fP\^, \fIevent_type\fP\^, \fIevent_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      Window \fIw\fP\^;
.br
      int \fIevent_type\fP\^;
.br
      XEvent *\fIevent_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: w.a,v 1.2 88/05/07 11:35:31 mento Exp $
.IP \fIw\fP 1i
Specifies the window.
.\" $Header: event_type.a,v 1.1 88/02/26 10:26:48 mento Exp $
.IP \fIevent_type\fP 1i
Specifies the event type to be compared.

.\" $Header: event.a,v 1.4 88/05/14 13:23:54 mento Exp $
.IP \fIevent_return\fP 1i
Returns the matched event's associated structure.
.LP
The
.PN XCheckTypedWindowEvent
function searches the event queue and then any events available  
on the server connection for the first event that matches the specified
type and window.
If it finds a match,
.PN XCheckTypedWindowEvent
removes the event from the queue, copies it into the specified
.PN XEvent
structure, and returns
.PN True .
The other events in the queue are not discarded.
If the event is not available,
.PN XCheckTypedWindowEvent
returns
.PN False ,
and the output buffer will have been flushed.
.NH 2
Putting an Event Back into the Queue
.XS
\*(SN Putting an Event Back into the Queue 
.XE
.LP
To push an event back into the event queue, use
.PN XPutBackEvent .
.IN "XPutBackEvent" "" "@DEF@"
.FD 0
.\" $Header: XPutBckEvent.f,v 1.1 88/02/26 10:02:01 mento Exp $
XPutBackEvent\^(\^\fIdisplay\fP, \fIevent\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      XEvent *\fIevent\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.IP \fIevent\fP 1i
Specifies a pointer to the event.
.LP 
.\" $Header: XPutBckEvent.d,v 1.3 88/06/11 07:52:25 mento Exp $
The
.PN XPutBackEvent
function pushes an event back onto the head of the display's event queue
by copying the event into the queue.
This can be useful if you read an event and then decide that you
would rather deal with it later.
There is no limit to the number of times in succession that you can call
.PN XPutBackEvent .
.NH 2
Sending Events to Other Applications
.XS
\*(SN Sending Events to Other Applications
.XE
.LP
To send an event to a specified window, use
.PN XSendEvent .
.IN "XSendEvent"
This function is often used in selection processing.
For example, the owner of a selection should use
.PN XSendEvent
to send a
.PN SelectionNotify
event to a requestor when a selection has been converted 
and stored as a property.
.IN "XSendEvent" "" "@DEF@"
.FD 0
.\" $Header: XSendEvent.f,v 1.2 88/05/04 06:29:14 mento Exp $
Status XSendEvent\^(\^\fIdisplay\fP, \fIw\fP\^, \fIpropagate\fP\^, \fIevent_mask\fP\^, \fIevent_send\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      Window \fIw\fP\^;
.br
      Bool \fIpropagate\fP\^;
.br
      long \fIevent_mask\fP\^;
.br
      XEvent *\fIevent_send\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: w_send.a,v 1.1 88/05/14 13:40:46 mento Exp $
.IP \fIw\fP 1i
Specifies the window the event is to be sent to,
.PN PointerWindow ,
or
.PN InputFocus .
.\" $Header: propagate.a,v 1.3 88/05/14 13:42:06 mento Exp $
.IP \fIpropagate\fP 1i
Specifies a Boolean value.
.\" $Header: eventmask.a,v 1.2 88/05/14 13:04:06 mento Exp $
.IP \fIevent_mask\fP 1i
Specifies the event mask.
.IP \fIevent_send\fP 1i
Specifies a pointer to the event that is to be sent.
.LP
.\" $Header: XSendEvent.d,v 1.4 88/08/20 09:17:09 mento Exp $
The
.PN XSendEvent
function identifies the destination window, 
determines which clients should receive the specified events, 
and ignores any active grabs.
This function requires you to pass an event mask.
For a discussion of the valid event mask names,
see section 8.3.
This function uses the w argument to identify the destination window as follows:
.IP \(bu 5
If w is
.PN PointerWindow ,
the destination window is the window that contains the pointer.
.IP \(bu 5
If w is
.PN InputFocus 
and if the focus window contains the pointer, 
the destination window is the window that contains the pointer; 
otherwise, the destination window is the focus window.
.LP
To determine which clients should receive the specified events,
.PN XSendEvent
uses the propagate argument as follows:
.IP \(bu 5
If event_mask is the empty set,
the event is sent to the client that created the destination window.
If that client no longer exists,
no event is sent.
.IP \(bu 5
If propagate is 
.PN False ,
the event is sent to every client selecting on destination any of the event
types in the event_mask argument.
.IP \(bu 5
If propagate is 
.PN True 
and no clients have selected on destination any of
the event types in event-mask, the destination is replaced with the
closest ancestor of destination for which some client has selected a
type in event-mask and for which no intervening window has that type in its
do-not-propagate-mask. 
If no such window exists or if the window is
an ancestor of the focus window and 
.PN InputFocus 
was originally specified
as the destination, the event is not sent to any clients.
Otherwise, the event is reported to every client selecting on the final
destination any of the types specified in event_mask.
.LP
The event in the
.PN XEvent
structure must be one of the core events or one of the events
defined by an extension (or a 
.PN BadValue
error results) so that the X server can correctly byte-swap 
the contents as necessary.  
The contents of the event are
otherwise unaltered and unchecked by the X server except to force send_event to
.PN True
in the forwarded event and to set the serial number in the event correctly.
.LP
.PN XSendEvent
returns zero if the conversion to wire protocol format failed
and returns nonzero otherwise.
.LP
.PN XSendEvent
can generate
.PN BadValue
and 
.PN BadWindow 
errors.
.NH 2
Getting Pointer Motion History
.XS
\*(SN Getting Pointer Motion History
.XE
.LP
Some X server implementations will maintain a more complete
history of pointer motion than is reported by event notification.
The pointer position at each pointer hardware interrupt may be
stored in a buffer for later retrieval.
This buffer is called the motion history buffer.
For example, a few applications, such as paint programs,
want to have a precise history of where the pointer
traveled. 
However, this historical information is highly excessive for most applications.
.LP
.sp
To determine the approximate maximum number of elements in the motion buffer, 
use
.PN XDisplayMotionBufferSize .
.IN "XDisplayMotionBufferSize" "" "@DEF@"
.FD 0
unsigned long XDisplayMotionBufferSize\^(\^\fIdisplay\fP\^)
.br
        Display *\fIdisplay\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.LP
The server may retain the recent history of the pointer motion
and do so to a finer granularity than is reported by
.PN MotionNotify
events.
The
.PN XGetMotionEvents
function makes this history available.
.LP
.sp
To get the motion history for a specified window and time, use
.PN XGetMotionEvents .
.IN "XGetMotionEvents" "" "@DEF@"
.FD 0
.\" $Header: XGetMoEvents.f,v 1.1 88/02/26 10:00:51 mento Exp $
XTimeCoord *XGetMotionEvents\^(\^\fIdisplay\fP, \fIw\fP\^, \fIstart\fP\^, \fIstop\fP\^, \fInevents_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      Window \fIw\fP\^;
.br
      Time \fIstart\fP\^, \fIstop\fP\^;	
.br
      int *\fInevents_return\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: w.a,v 1.2 88/05/07 11:35:31 mento Exp $
.IP \fIw\fP 1i
Specifies the window.
.\" $Header: startstop.a,v 1.2 88/05/14 13:47:41 mento Exp $
.IP \fIstart\fP 1i
.br
.ns
.IP \fIstop\fP 1i
Specify the time interval in which the events are returned from the motion
history buffer.
You can pass a timestamp or
.PN CurrentTime .
.\" $Header: nevents.a,v 1.1 88/02/26 10:29:31 mento Exp $
.IP \fInevents_return\fP 1i
Returns the number of events from the motion history buffer.
.LP
.\" $Header: XGetMoEvents.d,v 1.3 88/06/11 07:51:11 mento Exp $
The
.PN XGetMotionEvents
function returns all events in the motion history buffer that fall between the
specified start and stop times, inclusive, and that have coordinates
that lie within the specified window (including its borders) at its present
placement.
If the start time is later than the stop time or if the start time is in the
future, no events are returned.
If the stop time is in the future, it is equivalent to specifying
.PN CurrentTime .
The return type for this function is a structure defined as follows:
.LP
.IN "XTimeCoord" "" "@DEF@"
.Ds 0
.TA .5i
.ta .5i
typedef struct {
	Time time;
	short x, y;
} XTimeCoord;
.De
.LP
The time member is set to the time, in milliseconds. 
The x and y members are set to the coordinates of the pointer and
are reported relative to the origin
of the specified window.
To free the data returned from this call, use
.PN XFree .
.LP
.PN XGetMotionEvents
can generate a
.PN BadWindow 
error.
.NH 2
Handling Error Events
.XS
\*(SN Handling Error Events 
.XE
.LP
Xlib provides functions that you can use to enable or disable synchronization
and to use the default error handlers.
.NH 3
Enabling or Disabling Synchronization
.XS
\*(SN Enabling or Disabling Synchronization 
.XE
.LP
When debugging X applications, 
it often is very convenient to require Xlib to behave synchronously
so that errors are reported as they occur.
The following function lets you disable or enable synchronous behavior.
Note that graphics may occur 30 or more times more slowly when 
synchronization is enabled.
.IN "_Xdebug"
On POSIX systems,
there is also a global variable 
.PN _Xdebug 
that, if set to nonzero before starting a program under a debugger, will force
synchronous library behavior.
.LP
After completing their work,
all Xlib functions that generate protocol requests call what is known as
an after function.
.PN XSetAfterFunction
sets which function is to be called.
.IN "XSetAfterFunction" "" "@DEF@"
.FD 0
.\" $Header: XSyncHandler.f,v 1.2 88/08/20 09:27:02 mento Exp $
int (*XSetAfterFunction\^(\^\fIdisplay\fP, \fIprocedure\fP\^))()
.br
      Display *\fIdisplay\fP\^;
.br
      int (\^*\^\fIprocedure\fP\^)\^();
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: func.a,v 1.2 88/08/20 09:26:05 mento Exp $
.IP \fIprocedure\fP 1i
Specifies the function to be called after an Xlib function that generates a
protocol request completes its work.
.LP
.\" $Header: XSyncHandler.d,v 1.8 88/08/20 09:25:04 mento Exp $
The specified procedure is called with only a display pointer.
.PN XSetAfterFunction
returns the previous after function.
.LP
To enable or disable synchronization, use 
.PN XSynchronize .
.IN "Debugging" "synchronous mode"
.IN "XSynchronize" "" "@DEF@"
.FD 0
.\" $Header: XSynchronize.f,v 1.2 88/05/14 13:57:23 mento Exp $
int (*XSynchronize\^(\^\fIdisplay\fP, \fIonoff\fP\^)\^)()
.br
      Display *\fIdisplay\fP\^;
.br
      Bool \fIonoff\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: onoff.a,v 1.2 88/05/14 13:58:45 mento Exp $
.IP \fIonoff\fP 1i
Specifies a Boolean value that indicates whether to enable 
or disable synchronization.
.LP
.\" $Header: XSynchronize.d,v 1.2 88/06/11 07:54:00 mento Exp $
The
.PN XSynchronize
function returns 
the previous after function.
If onoff is 
.PN True , 
.PN XSynchronize
turns on synchronous behavior.
If onoff is
.PN False ,
.PN XSynchronize 
turns off synchronous behavior.
.NH 3
Using the Default Error Handlers
.XS
\*(SN Using the Default Error Handlers 
.XE
.LP
.IN "Debugging" "error handlers"
.IN "Error" "handlers"
There are two default error handlers in Xlib: 
one to handle typically fatal conditions (for example, 
the connection to a display server dying because a machine crashed) 
and one to handle error events from the X server.
These error handlers can be changed to user-supplied routines if you
prefer your own error handling and can be changed as often as you like.
If either function is passed a NULL pointer, it will
reinvoke the default handler.
The action of the default handlers is to print an explanatory
message and exit.
.LP
.sp
To set the error handler, use
.PN XSetErrorHandler .
.IN "XSetErrorHandler" "" "@DEF@"
.FD 0
.\" $Header: XErrHndlr.f,v 1.1 88/02/26 09:59:49 mento Exp $
int (*XSetErrorHandler\^(\^\fIhandler\fP\^)\^)\^(\^)
.br
      int (\^*\^\fIhandler\fP\^)\^(Display *, XErrorEvent *)
.FN
.\" $Header: handler.a,v 1.1 88/02/26 10:27:49 mento Exp $
.IP \fIhandler\fP 1i
Specifies the program's supplied error handler.
.LP 
.\" $Header: XErrHndlr.d,v 1.2 88/06/11 07:50:10 mento Exp $
Xlib generally calls the program's
supplied error handler whenever an error is received.
It is not called on
.PN BadName
errors from
.PN OpenFont ,
.PN LookupColor ,
or
.PN AllocNamedColor
protocol requests or on
.PN BadFont
errors from a
.PN QueryFont
protocol request.
These errors generally are reflected back to the program through the
procedural interface.
Because this condition is not assumed to be fatal, 
it is acceptable for your error handler to return.
However, the error handler should not
call any functions (directly or indirectly) on the display
that will generate protocol requests or that will look for input events.
The previous error handler is returned.
.LP
The 
.PN XErrorEvent
structure contains:
.IN "Debugging" "error event"
.LP
.IN "XErrorEvent" "" "@DEF"
.Ds 0
.TA .5i 2.5i
.ta .5i 2.5i
typedef struct {
	int type;
	Display *display;	/* Display the event was read from */
	unsigned long serial;		/* serial number of failed request */
	unsigned char error_code;	/* error code of failed request */
	unsigned char request_code;	/* Major op-code of failed request */
	unsigned char minor_code;	/* Minor op-code of failed request */
	XID resourceid;		/* resource id */
} XErrorEvent;
.De
.LP
.IN "Serial Number"
The serial member is the number of requests, starting from one, 
sent over the network connection since it was opened. 
It is the number that was the value of 
.PN NextRequest 
immediately before the failing call was made.  
The request_code member is a protocol request
of the procedure that failed, as defined in 
.Pn < X11/Xproto.h >.
The following error codes can be returned by the functions described in this
chapter:
.IN "Debugging" "error numbers"
.IN "Error" "codes"
.\".CP T 3
.\"Error Codes
.IN "BadAccess" "" "@DEF@"
.IN "BadAlloc" "" "@DEF@"
.IN "BadAtom" "" "@DEF@"
.IN "BadColor" "" "@DEF@"
.IN "BadCursor" "" "@DEF@"
.IN "BadDrawable" "" "@DEF@"
.IN "BadFont" "" "@DEF@"
.IN "BadGC" "" "@DEF@"
.IN "BadIDChoice" "" "@DEF@"
.TS H
l c
lw(1.75i) lw(4i).
_
.sp 6p
.TB
Error Code	Description
.sp 6p
_
.sp 6p
.TH
.R
T{
.PN BadAccess
T}	T{
A client attempts to grab a key/button combination already grabbed 
by another client.
.sp 3p
A client attempts to free a colormap entry that it had not already allocated.
.sp 3p
A client attempts to store into a read-only or unallocated colormap entry.
.sp 3p
A client attempts to modify the access control list from other than the local 
(or otherwise authorized) host.
.sp 3p
A client attempts to select an event type that another client 
has already selected.
T}
.sp 3p
T{
.PN BadAlloc
T}	T{
The server fails to allocate the requested resource.
Note that the explicit listing of
.PN BadAlloc
errors in requests only covers allocation errors at a very coarse level
and is not intended to (nor can it in practice hope to) cover all cases of
a server running out of allocation space in the middle of service.
The semantics when a server runs out of allocation space are left unspecified,
but a server may generate a
.PN BadAlloc
error on any request for this reason,
and clients should be prepared to receive such errors and handle or discard
them.
T}
.sp 3p
T{
.PN BadAtom
T}	T{
A value for an atom argument does not name a defined atom.
T}
.sp 3p
T{
.PN BadColor
T}	T{
A value for a colormap argument does not name a defined colormap.
T}
.sp 3p
T{
.PN BadCursor
T}	T{
A value for a cursor argument does not name a defined cursor.
T}
.sp 3p
T{
.PN BadDrawable
T}	T{
A value for a drawable argument does not name a defined window or pixmap.
T}
.sp 3p
T{
.PN BadFont
T}	T{
A value for a font argument does not name a defined font (or, in some cases, 
.PN GContext ).
T}
.sp 3p
T{
.PN BadGC
T}	T{
A value for a 
.PN GContext 
argument does not name a defined 
.PN GContext .
T}
.sp 3p
T{
.PN BadIDChoice
T}	T{
The value chosen for a resource identifier either is not included in the 
range assigned to the client or is already in use.
Under normal circumstances,
this cannot occur and should be considered a server or Xlib error.
T}
.sp 3p
T{
.PN BadImplementation
T}	T{
The server does not implement some aspect of the request.
A server that generates this error for a core request is deficient.
As such, this error is not listed for any of the requests,
but clients should be prepared to receive such errors 
and handle or discard them.
T}
.sp 3p
T{
.PN BadLength
T}	T{
The length of a request is shorter or longer than that required to 
contain the arguments.
This is an internal Xlib or server error.
.sp 3p
The length of a request exceeds the maximum length accepted by the server.
T}
.sp 3p
T{
.PN BadMatch
T}	T{
In a graphics request,
the root and depth of the graphics context does not match that of the drawable.
.sp 3p
An 
.PN InputOnly 
window is used as a drawable.
.sp 3p
Some argument or pair of arguments has the correct type and range,
but it fails to match in some other way required by the request.
.sp 3p
An 
.PN InputOnly 
window lacks this attribute.
T}
.sp 3p
T{
.PN BadName
T}	T{
A font or color of the specified name does not exist.
T}
.sp 3p
T{
.PN BadPixmap
T}	T{
A value for a pixmap argument does not name a defined pixmap.
T}
.sp 3p
T{
.PN BadRequest
T}	T{
The major or minor opcode does not specify a valid request.
This usually is an Xlib or server error.
T}
.sp 3p
T{
.PN BadValue
T}	T{
Some numeric value falls outside of the range of values accepted 
by the request.  
Unless a specific range is specified for an argument,
the full range defined by the argument's type is accepted.
Any argument defined as a set of alternatives typically can generate
this error (due to the encoding).
T}
.sp 3p
T{
.PN BadWindow
T}	T{
A value for a window argument does not name a defined window.
T}
.sp 6p
_
.TE
.IN "BadImplementation" "" "@DEF@"
.IN "BadLength" "" "@DEF@"
.IN "BadMatch" "" "@DEF@"
.IN "BadName" "" "@DEF@"
.IN "BadPixmap" "" "@DEF@"
.IN "BadRequest" "" "@DEF@"
.IN "BadValue" "" "@DEF@"
.IN "BadWindow" "" "@DEF@"
.NT
The 
.PN BadAtom , 
.PN BadColor , 
.PN BadCursor , 
.PN BadDrawable , 
.PN BadFont , 
.PN BadGC , 
.PN BadPixmap , 
and 
.PN BadWindow
errors are also used when the argument type is extended by a set of
fixed alternatives.
.NE
.sp
.LP
To obtain textual descriptions of the specified error code, use 
.PN XGetErrorText .
.IN "XGetErrorText" "" "@DEF@"
.IN "Debugging" "error message strings"
.FD 0
.\" $Header: XErrDescrip.f,v 1.1 88/02/26 09:59:49 mento Exp $
XGetErrorText\^(\^\fIdisplay\fP, \fIcode\fP, \fIbuffer_return\fP, \fIlength\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      int \fIcode\fP\^;
.br
      char *\fIbuffer_return\fP\^;
.br
      int \fIlength\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: code.a,v 1.1 88/02/26 10:05:58 mento Exp $
.IP \fIcode\fP 1i
Specifies the error code for which you want to obtain a description.
.IP \fIbuffer_return\fP 1i
Returns the error description.
.IP \fIlength\fP 1i
Specifies the size of the buffer.
.LP 
.\" $Header: XErrDescrip.d,v 1.3 88/08/21 07:02:39 mento Exp $
The
.PN XGetErrorText
function copies a null-terminated string describing the specified error code
into the specified buffer.
It is recommended that you use this function to obtain an error description
because extensions to Xlib may define their own error codes
and error strings.
.LP
.sp
To obtain error messages from the error database, use
.PN XGetErrorDatabaseText .
.IN "XGetErrorDatabaseText" "" "@DEF@"
.FD 0
XGetErrorDatabaseText\^(\^\fIdisplay\fP, \fIname\fP, \fImessage\fP, \fIdefault_string\fP, \fIbuffer_return\fP, \fIlength\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      char *\fIname\fP, *\fImessage\fP\^;
.br
      char *\fIdefault_string\fP\^;
.br
      char *\fIbuffer_return\fP\^;
.br
      int \fIlength\fP\^;
.FN
.\" $Header: display.a,v 1.1 88/02/26 10:26:29 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: name_err.a,v 1.1 88/02/26 10:29:07 mento Exp $
.IP \fIname\fP 1i
Specifies the name of the application.
.\" $Header: type_err.a,v 1.1 88/02/26 10:31:50 mento Exp $
.IP \fImessage\fP 1i
Specifies the type of the error message.
.IP \fIdefault_string\fP 1i
Specifies the default error message if none is found in the database.
.IP \fIbuffer_return\fP 1i
Returns the error description.
.IP \fIlength\fP 1i
Specifies the size of the buffer.
.LP
The
.PN XGetErrorDatabaseText
function returns a message (or the default message) from the error message
database.
Xlib uses this function internally to look up its error messages.
On a POSIX system,
the error message database is
.PN /usr/lib/X11/XErrorDB .
.IN "Files" "/usr/lib/X11/XErrorDB"
.LP
The name argument should generally be the name of your application.
The message argument should indicate which type of error message you want.
Xlib uses three predefined message types to report errors
(uppercase and lowercase matter):
.IP XProtoError 1i
The protocol error number is used as a string for the message argument.
.IP XlibMessage 1i
These are the message strings that are used internally by the library.
.IP XRequest 1i
For a core protocol request,
the major request protocol number is used for the message argument.
For an extension request,
the extension name (as given by
.PN InitExtension )
followed by a period (\.) and the minor request protocol number 
is used for the message argument.
If no string is found in the error database,
the default_string is returned to the buffer argument.
.LP
.sp
To report an error to the user when the requested display does not exist, use
.PN XDisplayName .
.IN "XDisplayName" "" "@DEF@"
.FD 0
char *XDisplayName\^(\^\fIstring\fP\^)
.br
      char *\fIstring\fP\^;
.FN
.\" $Header: string.a,v 1.1 88/02/26 10:31:32 mento Exp $
.IP \fIstring\fP 1i
Specifies the character string.
.LP
.\" $Header: XDispName.d,v 1.3 88/06/11 07:50:03 mento Exp $
The
.PN XDisplayName
function returns the name of the display that 
.PN XOpenDisplay
would attempt to use.
If a NULL string is specified,
.PN XDisplayName
looks in the environment for the display and returns the display name that
.PN XOpenDisplay
would attempt to use.
This makes it easier to report to the user precisely which display the
program attempted to open when the initial connection attempt failed.
.LP
.sp
To handle fatal I/O errors, use
.PN XSetIOErrorHandler .
.IN "XSetIOErrorHandler" "" "@DEF@"
.FD 0
.\" $Header: XIOErrHnd.f,v 1.1 88/02/26 10:01:07 mento Exp $
int (*XSetIOErrorHandler\^(\^\fIhandler\fP\^)\^)\^(\^)
.br
      int (\^*\^\fIhandler\fP\^)(Display *);
.FN
.\" $Header: handler.a,v 1.1 88/02/26 10:27:49 mento Exp $
.IP \fIhandler\fP 1i
Specifies the program's supplied error handler.
.LP
.\" $Header: XIOErrHnd.d,v 1.3 88/08/20 09:36:21 mento Exp $
The
.PN XSetIOErrorHandler
sets the fatal I/O error handler.
Xlib calls the program's supplied error handler if any sort of system call
error occurs (for example, the connection to the server was lost).
This is assumed to be a fatal condition,
and the called routine should not return.
If the I/O error handler does return,
the client process exits.
.LP
Note that the previous error handler is returned.
.bp
